// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.2
//
// <auto-generated>
//
// Generated from file `TradeSession.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TradeSession_h__
#define __TradeSession_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/Identity.h>
#include <ice/Common.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Trade
{

class TdSessionCallBack;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Trade::TdSessionCallBack>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Trade::TdSessionCallBack*);

class TdSession;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Trade::TdSession>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Trade::TdSession*);

}

}

namespace Trade
{

class TdSessionCallBack;
::Ice::Object* upCast(::Trade::TdSessionCallBack*);
typedef ::IceInternal::Handle< ::Trade::TdSessionCallBack> TdSessionCallBackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Trade::TdSessionCallBack> TdSessionCallBackPrx;
void __patch(TdSessionCallBackPtr&, const ::Ice::ObjectPtr&);

class TdSession;
::Ice::Object* upCast(::Trade::TdSession*);
typedef ::IceInternal::Handle< ::Trade::TdSession> TdSessionPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Trade::TdSession> TdSessionPrx;
void __patch(TdSessionPtr&, const ::Ice::ObjectPtr&);

}

namespace Trade
{

class Callback_TdSessionCallBack_onDone_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSessionCallBack_onDone_Base> Callback_TdSessionCallBack_onDonePtr;

class Callback_TdSessionCallBack_onOrder_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSessionCallBack_onOrder_Base> Callback_TdSessionCallBack_onOrderPtr;

class Callback_TdSessionCallBack_onTradingday_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSessionCallBack_onTradingday_Base> Callback_TdSessionCallBack_onTradingdayPtr;

class Callback_TdSession_setCallBack_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_setCallBack_Base> Callback_TdSession_setCallBackPtr;

class Callback_TdSession_heartBeat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_heartBeat_Base> Callback_TdSession_heartBeatPtr;

class Callback_TdSession_queryAccount_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_queryAccount_Base> Callback_TdSession_queryAccountPtr;

class Callback_TdSession_queryAccountOne_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_queryAccountOne_Base> Callback_TdSession_queryAccountOnePtr;

class Callback_TdSession_queryPosition_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_queryPosition_Base> Callback_TdSession_queryPositionPtr;

class Callback_TdSession_queryOrder_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_queryOrder_Base> Callback_TdSession_queryOrderPtr;

class Callback_TdSession_queryDone_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_queryDone_Base> Callback_TdSession_queryDonePtr;

class Callback_TdSession_jsonQueryAccount_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_jsonQueryAccount_Base> Callback_TdSession_jsonQueryAccountPtr;

class Callback_TdSession_jsonQueryAccountOne_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_jsonQueryAccountOne_Base> Callback_TdSession_jsonQueryAccountOnePtr;

class Callback_TdSession_jsonQueryPosition_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_jsonQueryPosition_Base> Callback_TdSession_jsonQueryPositionPtr;

class Callback_TdSession_jsonQueryOrder_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_jsonQueryOrder_Base> Callback_TdSession_jsonQueryOrderPtr;

class Callback_TdSession_jsonQueryDone_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_jsonQueryDone_Base> Callback_TdSession_jsonQueryDonePtr;

class Callback_TdSession_doOrder_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_doOrder_Base> Callback_TdSession_doOrderPtr;

class Callback_TdSession_cancleOrder_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_cancleOrder_Base> Callback_TdSession_cancleOrderPtr;

class Callback_TdSession_updatePassword_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_updatePassword_Base> Callback_TdSession_updatePasswordPtr;

class Callback_TdSession_subscribe_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_subscribe_Base> Callback_TdSession_subscribePtr;

class Callback_TdSession_unSubscribe_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_unSubscribe_Base> Callback_TdSession_unSubscribePtr;

class Callback_TdSession_getTradingday_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_getTradingday_Base> Callback_TdSession_getTradingdayPtr;

class Callback_TdSession_QuerySession_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_QuerySession_Base> Callback_TdSession_QuerySessionPtr;

class Callback_TdSession_QuerySubCurrent_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TdSession_QuerySubCurrent_Base> Callback_TdSession_QuerySubCurrentPtr;

}

namespace IceProxy
{

namespace Trade
{

class TdSessionCallBack : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::Int onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position)
    {
        return onDone(__p_fundid, __p_done, __p_account, __p_position, 0);
    }
    ::Ice::Int onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::Context& __ctx)
    {
        return onDone(__p_fundid, __p_done, __p_account, __p_position, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_onDone(__p_fundid, __p_done, __p_account, __p_position, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_onDone(__p_fundid, __p_done, __p_account, __p_position, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position)
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::Context& __ctx)
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Trade::Callback_TdSessionCallBack_onDonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onDone(const ::std::string& __p_fundid, const ::CM::Done& __p_done, const ::CM::Account& __p_account, const ::CM::PositionList& __p_position, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSessionCallBack_onDonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onDone(__p_fundid, __p_done, __p_account, __p_position, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_onDone(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int onDone(const ::std::string&, const ::CM::Done&, const ::CM::Account&, const ::CM::PositionList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onDone(const ::std::string&, const ::CM::Done&, const ::CM::Account&, const ::CM::PositionList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order)
    {
        return onOrder(__p_fundid, __p_order, 0);
    }
    ::Ice::Int onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::Context& __ctx)
    {
        return onOrder(__p_fundid, __p_order, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_onOrder(__p_fundid, __p_order, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_onOrder(__p_fundid, __p_order, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_onOrder(__p_fundid, __p_order, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_onOrder(__p_fundid, __p_order, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order)
    {
        return begin_onOrder(__p_fundid, __p_order, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::Context& __ctx)
    {
        return begin_onOrder(__p_fundid, __p_order, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onOrder(__p_fundid, __p_order, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onOrder(__p_fundid, __p_order, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Trade::Callback_TdSessionCallBack_onOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onOrder(__p_fundid, __p_order, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onOrder(const ::std::string& __p_fundid, const ::CM::Order& __p_order, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSessionCallBack_onOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onOrder(__p_fundid, __p_order, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_onOrder(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int onOrder(const ::std::string&, const ::CM::Order&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onOrder(const ::std::string&, const ::CM::Order&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday)
    {
        return onTradingday(__p_fundid, __p_tradingday, 0);
    }
    ::Ice::Int onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::Context& __ctx)
    {
        return onTradingday(__p_fundid, __p_tradingday, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_onTradingday(__p_fundid, __p_tradingday, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_onTradingday(__p_fundid, __p_tradingday, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday)
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::Context& __ctx)
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Trade::Callback_TdSessionCallBack_onTradingdayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onTradingday(const ::std::string& __p_fundid, const ::std::string& __p_tradingday, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSessionCallBack_onTradingdayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onTradingday(__p_fundid, __p_tradingday, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_onTradingday(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int onTradingday(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onTradingday(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_secure(bool __secure) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_twoway() const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_oneway() const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_batchOneway() const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_datagram() const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_batchDatagram() const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_compress(bool __compress) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_timeout(int __timeout) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TdSessionCallBack> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<TdSessionCallBack*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class TdSession : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::Int setCallBack(const ::Ice::Identity& __p_ident)
    {
        return setCallBack(__p_ident, 0);
    }
    ::Ice::Int setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::Context& __ctx)
    {
        return setCallBack(__p_ident, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setCallBack(const ::Ice::Identity& __p_ident, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setCallBack(__p_ident, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setCallBack(const ::Ice::Identity& __p_ident, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setCallBack(__p_ident, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setCallBack(__p_ident, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setCallBack(__p_ident, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setCallBack(const ::Ice::Identity& __p_ident)
    {
        return begin_setCallBack(__p_ident, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::Context& __ctx)
    {
        return begin_setCallBack(__p_ident, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallBack(__p_ident, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallBack(__p_ident, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Trade::Callback_TdSession_setCallBackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallBack(__p_ident, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCallBack(const ::Ice::Identity& __p_ident, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_setCallBackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCallBack(__p_ident, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_setCallBack(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int setCallBack(const ::Ice::Identity&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setCallBack(const ::Ice::Identity&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int heartBeat()
    {
        return heartBeat(0);
    }
    ::Ice::Int heartBeat(const ::Ice::Context& __ctx)
    {
        return heartBeat(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_heartBeat(const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_heartBeat(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_heartBeat(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_heartBeat(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_heartBeat(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_heartBeat(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_heartBeat(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_heartBeat(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_heartBeat(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_heartBeat()
    {
        return begin_heartBeat(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_heartBeat(const ::Ice::Context& __ctx)
    {
        return begin_heartBeat(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_heartBeat(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_heartBeat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_heartBeat(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_heartBeat(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_heartBeat(const ::Trade::Callback_TdSession_heartBeatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_heartBeat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_heartBeat(const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_heartBeatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_heartBeat(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_heartBeat(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int heartBeat(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_heartBeat(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::CM::AccountList queryAccount()
    {
        return queryAccount(0);
    }
    ::CM::AccountList queryAccount(const ::Ice::Context& __ctx)
    {
        return queryAccount(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryAccount(const ::IceInternal::Function<void (const ::CM::AccountList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryAccount(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryAccount(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryAccount(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryAccount(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::CM::AccountList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryAccount(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryAccount(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryAccount(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryAccount(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::CM::AccountList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryAccount()
    {
        return begin_queryAccount(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryAccount(const ::Ice::Context& __ctx)
    {
        return begin_queryAccount(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryAccount(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccount(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryAccount(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccount(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryAccount(const ::Trade::Callback_TdSession_queryAccountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccount(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryAccount(const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_queryAccountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccount(&__ctx, __del, __cookie);
    }

    ::CM::AccountList end_queryAccount(const ::Ice::AsyncResultPtr&);
    
private:

    ::CM::AccountList queryAccount(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryAccount(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::CM::Account queryAccountOne(const ::std::string& __p_fundid)
    {
        return queryAccountOne(__p_fundid, 0);
    }
    ::CM::Account queryAccountOne(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return queryAccountOne(__p_fundid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryAccountOne(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::CM::Account&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryAccountOne(__p_fundid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryAccountOne(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryAccountOne(__p_fundid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryAccountOne(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::CM::Account&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryAccountOne(__p_fundid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryAccountOne(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryAccountOne(__p_fundid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryAccountOne(const ::std::string& __p_fundid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::CM::Account&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryAccountOne(const ::std::string& __p_fundid)
    {
        return begin_queryAccountOne(__p_fundid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryAccountOne(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return begin_queryAccountOne(__p_fundid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryAccountOne(const ::std::string& __p_fundid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccountOne(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryAccountOne(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccountOne(__p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryAccountOne(const ::std::string& __p_fundid, const ::Trade::Callback_TdSession_queryAccountOnePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccountOne(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryAccountOne(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_queryAccountOnePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryAccountOne(__p_fundid, &__ctx, __del, __cookie);
    }

    ::CM::Account end_queryAccountOne(const ::Ice::AsyncResultPtr&);
    
private:

    ::CM::Account queryAccountOne(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryAccountOne(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::CM::PositionList queryPosition(const ::std::string& __p_fundid)
    {
        return queryPosition(__p_fundid, 0);
    }
    ::CM::PositionList queryPosition(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return queryPosition(__p_fundid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryPosition(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::CM::PositionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryPosition(__p_fundid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryPosition(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryPosition(__p_fundid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryPosition(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::CM::PositionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryPosition(__p_fundid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryPosition(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryPosition(__p_fundid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryPosition(const ::std::string& __p_fundid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::CM::PositionList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryPosition(const ::std::string& __p_fundid)
    {
        return begin_queryPosition(__p_fundid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryPosition(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return begin_queryPosition(__p_fundid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryPosition(const ::std::string& __p_fundid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryPosition(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryPosition(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryPosition(__p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryPosition(const ::std::string& __p_fundid, const ::Trade::Callback_TdSession_queryPositionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryPosition(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryPosition(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_queryPositionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryPosition(__p_fundid, &__ctx, __del, __cookie);
    }

    ::CM::PositionList end_queryPosition(const ::Ice::AsyncResultPtr&);
    
private:

    ::CM::PositionList queryPosition(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryPosition(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::CM::OrderList queryOrder(const ::std::string& __p_fundid)
    {
        return queryOrder(__p_fundid, 0);
    }
    ::CM::OrderList queryOrder(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return queryOrder(__p_fundid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryOrder(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::CM::OrderList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryOrder(__p_fundid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryOrder(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryOrder(__p_fundid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryOrder(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::CM::OrderList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryOrder(__p_fundid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryOrder(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryOrder(__p_fundid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryOrder(const ::std::string& __p_fundid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::CM::OrderList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryOrder(const ::std::string& __p_fundid)
    {
        return begin_queryOrder(__p_fundid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryOrder(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return begin_queryOrder(__p_fundid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryOrder(const ::std::string& __p_fundid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryOrder(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryOrder(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryOrder(__p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryOrder(const ::std::string& __p_fundid, const ::Trade::Callback_TdSession_queryOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryOrder(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryOrder(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_queryOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryOrder(__p_fundid, &__ctx, __del, __cookie);
    }

    ::CM::OrderList end_queryOrder(const ::Ice::AsyncResultPtr&);
    
private:

    ::CM::OrderList queryOrder(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryOrder(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::CM::DoneList queryDone(const ::std::string& __p_fundid)
    {
        return queryDone(__p_fundid, 0);
    }
    ::CM::DoneList queryDone(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return queryDone(__p_fundid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryDone(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::CM::DoneList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryDone(__p_fundid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryDone(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryDone(__p_fundid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryDone(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::CM::DoneList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryDone(__p_fundid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryDone(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryDone(__p_fundid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryDone(const ::std::string& __p_fundid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::CM::DoneList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryDone(const ::std::string& __p_fundid)
    {
        return begin_queryDone(__p_fundid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryDone(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return begin_queryDone(__p_fundid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryDone(const ::std::string& __p_fundid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryDone(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryDone(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryDone(__p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryDone(const ::std::string& __p_fundid, const ::Trade::Callback_TdSession_queryDonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryDone(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryDone(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_queryDonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryDone(__p_fundid, &__ctx, __del, __cookie);
    }

    ::CM::DoneList end_queryDone(const ::Ice::AsyncResultPtr&);
    
private:

    ::CM::DoneList queryDone(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryDone(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string jsonQueryAccount(::Ice::Int __p_from)
    {
        return jsonQueryAccount(__p_from, 0);
    }
    ::std::string jsonQueryAccount(::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return jsonQueryAccount(__p_from, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccount(::Ice::Int __p_from, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryAccount(__p_from, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccount(::Ice::Int __p_from, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryAccount(__p_from, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccount(::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryAccount(__p_from, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccount(::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryAccount(__p_from, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_jsonQueryAccount(::Ice::Int __p_from, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_jsonQueryAccount(::Ice::Int __p_from)
    {
        return begin_jsonQueryAccount(__p_from, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccount(::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return begin_jsonQueryAccount(__p_from, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccount(::Ice::Int __p_from, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccount(__p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccount(::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccount(__p_from, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccount(::Ice::Int __p_from, const ::Trade::Callback_TdSession_jsonQueryAccountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccount(__p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccount(::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_jsonQueryAccountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccount(__p_from, &__ctx, __del, __cookie);
    }

    ::std::string end_jsonQueryAccount(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string jsonQueryAccount(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_jsonQueryAccount(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return jsonQueryAccountOne(__p_fundid, __p_from, 0);
    }
    ::std::string jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return jsonQueryAccountOne(__p_fundid, __p_from, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryAccountOne(__p_fundid, __p_from, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryAccountOne(__p_fundid, __p_from, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Trade::Callback_TdSession_jsonQueryAccountOnePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryAccountOne(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_jsonQueryAccountOnePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryAccountOne(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::std::string end_jsonQueryAccountOne(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string jsonQueryAccountOne(const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_jsonQueryAccountOne(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return jsonQueryPosition(__p_fundid, __p_from, 0);
    }
    ::std::string jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return jsonQueryPosition(__p_fundid, __p_from, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryPosition(__p_fundid, __p_from, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryPosition(__p_fundid, __p_from, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Trade::Callback_TdSession_jsonQueryPositionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryPosition(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_jsonQueryPositionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryPosition(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::std::string end_jsonQueryPosition(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string jsonQueryPosition(const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_jsonQueryPosition(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return jsonQueryOrder(__p_fundid, __p_from, 0);
    }
    ::std::string jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return jsonQueryOrder(__p_fundid, __p_from, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryOrder(__p_fundid, __p_from, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryOrder(__p_fundid, __p_from, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Trade::Callback_TdSession_jsonQueryOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryOrder(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_jsonQueryOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryOrder(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::std::string end_jsonQueryOrder(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string jsonQueryOrder(const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_jsonQueryOrder(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return jsonQueryDone(__p_fundid, __p_from, 0);
    }
    ::std::string jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return jsonQueryDone(__p_fundid, __p_from, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryDone(__p_fundid, __p_from, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_jsonQueryDone(__p_fundid, __p_from, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from)
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx)
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Trade::Callback_TdSession_jsonQueryDonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_jsonQueryDone(const ::std::string& __p_fundid, ::Ice::Int __p_from, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_jsonQueryDonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_jsonQueryDone(__p_fundid, __p_from, &__ctx, __del, __cookie);
    }

    ::std::string end_jsonQueryDone(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string jsonQueryDone(const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_jsonQueryDone(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int doOrder(const ::CM::DoOrder& __p_do)
    {
        return doOrder(__p_do, 0);
    }
    ::Ice::Int doOrder(const ::CM::DoOrder& __p_do, const ::Ice::Context& __ctx)
    {
        return doOrder(__p_do, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_doOrder(const ::CM::DoOrder& __p_do, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_doOrder(__p_do, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_doOrder(const ::CM::DoOrder& __p_do, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_doOrder(__p_do, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_doOrder(const ::CM::DoOrder& __p_do, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_doOrder(__p_do, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_doOrder(const ::CM::DoOrder& __p_do, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_doOrder(__p_do, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_doOrder(const ::CM::DoOrder& __p_do, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_doOrder(const ::CM::DoOrder& __p_do)
    {
        return begin_doOrder(__p_do, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_doOrder(const ::CM::DoOrder& __p_do, const ::Ice::Context& __ctx)
    {
        return begin_doOrder(__p_do, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_doOrder(const ::CM::DoOrder& __p_do, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_doOrder(__p_do, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_doOrder(const ::CM::DoOrder& __p_do, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_doOrder(__p_do, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_doOrder(const ::CM::DoOrder& __p_do, const ::Trade::Callback_TdSession_doOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_doOrder(__p_do, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_doOrder(const ::CM::DoOrder& __p_do, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_doOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_doOrder(__p_do, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_doOrder(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int doOrder(const ::CM::DoOrder&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_doOrder(const ::CM::DoOrder&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno)
    {
        return cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, 0);
    }
    ::Ice::Int cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::Context& __ctx)
    {
        return cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno)
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::Context& __ctx)
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Trade::Callback_TdSession_cancleOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cancleOrder(const ::std::string& __p_fundid, const ::std::string& __p_sessionid, const ::std::string& __p_instrumentid, const ::std::string& __p_privateno, const ::std::string& __p_orderno, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_cancleOrderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancleOrder(__p_fundid, __p_sessionid, __p_instrumentid, __p_privateno, __p_orderno, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_cancleOrder(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int cancleOrder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_cancleOrder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd)
    {
        return updatePassword(__p_oldpwd, __p_newpwd, 0);
    }
    ::Ice::Int updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::Context& __ctx)
    {
        return updatePassword(__p_oldpwd, __p_newpwd, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatePassword(__p_oldpwd, __p_newpwd, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updatePassword(__p_oldpwd, __p_newpwd, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd)
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::Context& __ctx)
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Trade::Callback_TdSession_updatePasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updatePassword(const ::std::string& __p_oldpwd, const ::std::string& __p_newpwd, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_updatePasswordPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updatePassword(__p_oldpwd, __p_newpwd, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_updatePassword(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int updatePassword(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updatePassword(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid)
    {
        return subscribe(__p_moduleName, __p_fundid, 0);
    }
    ::Ice::Int subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return subscribe(__p_moduleName, __p_fundid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_subscribe(__p_moduleName, __p_fundid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_subscribe(__p_moduleName, __p_fundid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_subscribe(__p_moduleName, __p_fundid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_subscribe(__p_moduleName, __p_fundid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid)
    {
        return begin_subscribe(__p_moduleName, __p_fundid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return begin_subscribe(__p_moduleName, __p_fundid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(__p_moduleName, __p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(__p_moduleName, __p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Trade::Callback_TdSession_subscribePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(__p_moduleName, __p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string& __p_moduleName, const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_subscribePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_subscribe(__p_moduleName, __p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_subscribe(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int subscribe(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_subscribe(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int unSubscribe(const ::std::string& __p_fundid)
    {
        return unSubscribe(__p_fundid, 0);
    }
    ::Ice::Int unSubscribe(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return unSubscribe(__p_fundid, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_unSubscribe(const ::std::string& __p_fundid, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_unSubscribe(__p_fundid, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_unSubscribe(const ::std::string& __p_fundid, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_unSubscribe(__p_fundid, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_unSubscribe(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_unSubscribe(__p_fundid, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_unSubscribe(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_unSubscribe(__p_fundid, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_unSubscribe(const ::std::string& __p_fundid, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_unSubscribe(const ::std::string& __p_fundid)
    {
        return begin_unSubscribe(__p_fundid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unSubscribe(const ::std::string& __p_fundid, const ::Ice::Context& __ctx)
    {
        return begin_unSubscribe(__p_fundid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unSubscribe(const ::std::string& __p_fundid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unSubscribe(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unSubscribe(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unSubscribe(__p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unSubscribe(const ::std::string& __p_fundid, const ::Trade::Callback_TdSession_unSubscribePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unSubscribe(__p_fundid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unSubscribe(const ::std::string& __p_fundid, const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_unSubscribePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unSubscribe(__p_fundid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_unSubscribe(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int unSubscribe(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unSubscribe(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getTradingday()
    {
        return getTradingday(0);
    }
    ::std::string getTradingday(const ::Ice::Context& __ctx)
    {
        return getTradingday(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTradingday(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTradingday(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTradingday(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTradingday(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTradingday(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTradingday(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTradingday(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTradingday(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTradingday(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTradingday()
    {
        return begin_getTradingday(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTradingday(const ::Ice::Context& __ctx)
    {
        return begin_getTradingday(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTradingday(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTradingday(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTradingday(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTradingday(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTradingday(const ::Trade::Callback_TdSession_getTradingdayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTradingday(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTradingday(const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_getTradingdayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTradingday(&__ctx, __del, __cookie);
    }

    ::std::string end_getTradingday(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getTradingday(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTradingday(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string QuerySession()
    {
        return QuerySession(0);
    }
    ::std::string QuerySession(const ::Ice::Context& __ctx)
    {
        return QuerySession(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_QuerySession(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QuerySession(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QuerySession(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QuerySession(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_QuerySession(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QuerySession(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QuerySession(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QuerySession(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_QuerySession(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_QuerySession()
    {
        return begin_QuerySession(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QuerySession(const ::Ice::Context& __ctx)
    {
        return begin_QuerySession(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QuerySession(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySession(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QuerySession(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySession(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QuerySession(const ::Trade::Callback_TdSession_QuerySessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySession(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QuerySession(const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_QuerySessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySession(&__ctx, __del, __cookie);
    }

    ::std::string end_QuerySession(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string QuerySession(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_QuerySession(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string QuerySubCurrent()
    {
        return QuerySubCurrent(0);
    }
    ::std::string QuerySubCurrent(const ::Ice::Context& __ctx)
    {
        return QuerySubCurrent(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_QuerySubCurrent(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QuerySubCurrent(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QuerySubCurrent(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QuerySubCurrent(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_QuerySubCurrent(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QuerySubCurrent(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QuerySubCurrent(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QuerySubCurrent(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_QuerySubCurrent(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_QuerySubCurrent()
    {
        return begin_QuerySubCurrent(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QuerySubCurrent(const ::Ice::Context& __ctx)
    {
        return begin_QuerySubCurrent(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QuerySubCurrent(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySubCurrent(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QuerySubCurrent(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySubCurrent(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QuerySubCurrent(const ::Trade::Callback_TdSession_QuerySubCurrentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySubCurrent(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QuerySubCurrent(const ::Ice::Context& __ctx, const ::Trade::Callback_TdSession_QuerySubCurrentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QuerySubCurrent(&__ctx, __del, __cookie);
    }

    ::std::string end_QuerySubCurrent(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string QuerySubCurrent(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_QuerySubCurrent(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<TdSession> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_secure(bool __secure) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_twoway() const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_oneway() const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_batchOneway() const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_datagram() const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_batchDatagram() const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_compress(bool __compress) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_timeout(int __timeout) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TdSession> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<TdSession*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace Trade
{

class TdSessionCallBack : virtual public ::Ice::Object
{
public:

    typedef TdSessionCallBackPrx ProxyType;
    typedef TdSessionCallBackPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int onDone(const ::std::string&, const ::CM::Done&, const ::CM::Account&, const ::CM::PositionList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onDone(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int onOrder(const ::std::string&, const ::CM::Order&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onOrder(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int onTradingday(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onTradingday(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const TdSessionCallBack& l, const TdSessionCallBack& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const TdSessionCallBack& l, const TdSessionCallBack& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class TdSession : virtual public ::Ice::Object
{
public:

    typedef TdSessionPrx ProxyType;
    typedef TdSessionPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int setCallBack(const ::Ice::Identity&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setCallBack(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int heartBeat(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___heartBeat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::CM::AccountList queryAccount(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryAccount(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::CM::Account queryAccountOne(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryAccountOne(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::CM::PositionList queryPosition(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryPosition(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::CM::OrderList queryOrder(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryOrder(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::CM::DoneList queryDone(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryDone(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string jsonQueryAccount(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___jsonQueryAccount(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string jsonQueryAccountOne(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___jsonQueryAccountOne(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string jsonQueryPosition(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___jsonQueryPosition(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string jsonQueryOrder(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___jsonQueryOrder(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string jsonQueryDone(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___jsonQueryDone(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int doOrder(const ::CM::DoOrder&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___doOrder(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int cancleOrder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___cancleOrder(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int updatePassword(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updatePassword(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int subscribe(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___subscribe(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int unSubscribe(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unSubscribe(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getTradingday(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTradingday(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string QuerySession(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___QuerySession(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string QuerySubCurrent(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___QuerySubCurrent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const TdSession& l, const TdSession& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const TdSession& l, const TdSession& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Trade
{

template<class T>
class CallbackNC_TdSessionCallBack_onDone : public Callback_TdSessionCallBack_onDone_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSessionCallBack_onDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionCallBackPrx __proxy = ::Trade::TdSessionCallBackPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_onDone(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSessionCallBack_onDonePtr
newCallback_TdSessionCallBack_onDone(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSessionCallBack_onDone<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSessionCallBack_onDonePtr
newCallback_TdSessionCallBack_onDone(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSessionCallBack_onDone<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSessionCallBack_onDone : public Callback_TdSessionCallBack_onDone_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSessionCallBack_onDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionCallBackPrx __proxy = ::Trade::TdSessionCallBackPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_onDone(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSessionCallBack_onDonePtr
newCallback_TdSessionCallBack_onDone(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSessionCallBack_onDone<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSessionCallBack_onDonePtr
newCallback_TdSessionCallBack_onDone(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSessionCallBack_onDone<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSessionCallBack_onOrder : public Callback_TdSessionCallBack_onOrder_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSessionCallBack_onOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionCallBackPrx __proxy = ::Trade::TdSessionCallBackPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_onOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSessionCallBack_onOrderPtr
newCallback_TdSessionCallBack_onOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSessionCallBack_onOrder<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSessionCallBack_onOrderPtr
newCallback_TdSessionCallBack_onOrder(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSessionCallBack_onOrder<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSessionCallBack_onOrder : public Callback_TdSessionCallBack_onOrder_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSessionCallBack_onOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionCallBackPrx __proxy = ::Trade::TdSessionCallBackPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_onOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSessionCallBack_onOrderPtr
newCallback_TdSessionCallBack_onOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSessionCallBack_onOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSessionCallBack_onOrderPtr
newCallback_TdSessionCallBack_onOrder(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSessionCallBack_onOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSessionCallBack_onTradingday : public Callback_TdSessionCallBack_onTradingday_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSessionCallBack_onTradingday(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionCallBackPrx __proxy = ::Trade::TdSessionCallBackPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_onTradingday(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSessionCallBack_onTradingdayPtr
newCallback_TdSessionCallBack_onTradingday(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSessionCallBack_onTradingday<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSessionCallBack_onTradingdayPtr
newCallback_TdSessionCallBack_onTradingday(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSessionCallBack_onTradingday<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSessionCallBack_onTradingday : public Callback_TdSessionCallBack_onTradingday_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSessionCallBack_onTradingday(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionCallBackPrx __proxy = ::Trade::TdSessionCallBackPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_onTradingday(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSessionCallBack_onTradingdayPtr
newCallback_TdSessionCallBack_onTradingday(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSessionCallBack_onTradingday<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSessionCallBack_onTradingdayPtr
newCallback_TdSessionCallBack_onTradingday(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSessionCallBack_onTradingday<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_setCallBack : public Callback_TdSession_setCallBack_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSession_setCallBack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setCallBack(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_setCallBackPtr
newCallback_TdSession_setCallBack(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_setCallBack<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_setCallBackPtr
newCallback_TdSession_setCallBack(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_setCallBack<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_setCallBack : public Callback_TdSession_setCallBack_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSession_setCallBack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setCallBack(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_setCallBackPtr
newCallback_TdSession_setCallBack(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_setCallBack<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_setCallBackPtr
newCallback_TdSession_setCallBack(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_setCallBack<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_heartBeat : public Callback_TdSession_heartBeat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSession_heartBeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_heartBeat(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_heartBeatPtr
newCallback_TdSession_heartBeat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_heartBeat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_heartBeatPtr
newCallback_TdSession_heartBeat(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_heartBeat<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_heartBeat : public Callback_TdSession_heartBeat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSession_heartBeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_heartBeat(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_heartBeatPtr
newCallback_TdSession_heartBeat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_heartBeat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_heartBeatPtr
newCallback_TdSession_heartBeat(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_heartBeat<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_queryAccount : public Callback_TdSession_queryAccount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::CM::AccountList&);

    CallbackNC_TdSession_queryAccount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::AccountList __ret;
        try
        {
            __ret = __proxy->end_queryAccount(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_queryAccountPtr
newCallback_TdSession_queryAccount(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::AccountList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryAccount<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_queryAccountPtr
newCallback_TdSession_queryAccount(T* instance, void (T::*cb)(const ::CM::AccountList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryAccount<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_queryAccount : public Callback_TdSession_queryAccount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::CM::AccountList&, const CT&);

    Callback_TdSession_queryAccount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::AccountList __ret;
        try
        {
            __ret = __proxy->end_queryAccount(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_queryAccountPtr
newCallback_TdSession_queryAccount(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::AccountList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryAccount<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_queryAccountPtr
newCallback_TdSession_queryAccount(T* instance, void (T::*cb)(const ::CM::AccountList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryAccount<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_queryAccountOne : public Callback_TdSession_queryAccountOne_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::CM::Account&);

    CallbackNC_TdSession_queryAccountOne(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::Account __ret;
        try
        {
            __ret = __proxy->end_queryAccountOne(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_queryAccountOnePtr
newCallback_TdSession_queryAccountOne(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::Account&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryAccountOne<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_queryAccountOnePtr
newCallback_TdSession_queryAccountOne(T* instance, void (T::*cb)(const ::CM::Account&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryAccountOne<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_queryAccountOne : public Callback_TdSession_queryAccountOne_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::CM::Account&, const CT&);

    Callback_TdSession_queryAccountOne(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::Account __ret;
        try
        {
            __ret = __proxy->end_queryAccountOne(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_queryAccountOnePtr
newCallback_TdSession_queryAccountOne(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::Account&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryAccountOne<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_queryAccountOnePtr
newCallback_TdSession_queryAccountOne(T* instance, void (T::*cb)(const ::CM::Account&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryAccountOne<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_queryPosition : public Callback_TdSession_queryPosition_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::CM::PositionList&);

    CallbackNC_TdSession_queryPosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::PositionList __ret;
        try
        {
            __ret = __proxy->end_queryPosition(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_queryPositionPtr
newCallback_TdSession_queryPosition(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::PositionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryPosition<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_queryPositionPtr
newCallback_TdSession_queryPosition(T* instance, void (T::*cb)(const ::CM::PositionList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryPosition<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_queryPosition : public Callback_TdSession_queryPosition_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::CM::PositionList&, const CT&);

    Callback_TdSession_queryPosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::PositionList __ret;
        try
        {
            __ret = __proxy->end_queryPosition(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_queryPositionPtr
newCallback_TdSession_queryPosition(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::PositionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryPosition<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_queryPositionPtr
newCallback_TdSession_queryPosition(T* instance, void (T::*cb)(const ::CM::PositionList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryPosition<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_queryOrder : public Callback_TdSession_queryOrder_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::CM::OrderList&);

    CallbackNC_TdSession_queryOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::OrderList __ret;
        try
        {
            __ret = __proxy->end_queryOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_queryOrderPtr
newCallback_TdSession_queryOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::OrderList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryOrder<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_queryOrderPtr
newCallback_TdSession_queryOrder(T* instance, void (T::*cb)(const ::CM::OrderList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryOrder<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_queryOrder : public Callback_TdSession_queryOrder_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::CM::OrderList&, const CT&);

    Callback_TdSession_queryOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::OrderList __ret;
        try
        {
            __ret = __proxy->end_queryOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_queryOrderPtr
newCallback_TdSession_queryOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::OrderList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_queryOrderPtr
newCallback_TdSession_queryOrder(T* instance, void (T::*cb)(const ::CM::OrderList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_queryDone : public Callback_TdSession_queryDone_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::CM::DoneList&);

    CallbackNC_TdSession_queryDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::DoneList __ret;
        try
        {
            __ret = __proxy->end_queryDone(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_queryDonePtr
newCallback_TdSession_queryDone(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::DoneList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryDone<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_queryDonePtr
newCallback_TdSession_queryDone(T* instance, void (T::*cb)(const ::CM::DoneList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_queryDone<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_queryDone : public Callback_TdSession_queryDone_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::CM::DoneList&, const CT&);

    Callback_TdSession_queryDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::CM::DoneList __ret;
        try
        {
            __ret = __proxy->end_queryDone(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_queryDonePtr
newCallback_TdSession_queryDone(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::CM::DoneList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryDone<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_queryDonePtr
newCallback_TdSession_queryDone(T* instance, void (T::*cb)(const ::CM::DoneList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_queryDone<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_jsonQueryAccount : public Callback_TdSession_jsonQueryAccount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_jsonQueryAccount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryAccount(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_jsonQueryAccountPtr
newCallback_TdSession_jsonQueryAccount(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryAccount<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_jsonQueryAccountPtr
newCallback_TdSession_jsonQueryAccount(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryAccount<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_jsonQueryAccount : public Callback_TdSession_jsonQueryAccount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_jsonQueryAccount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryAccount(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_jsonQueryAccountPtr
newCallback_TdSession_jsonQueryAccount(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryAccount<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_jsonQueryAccountPtr
newCallback_TdSession_jsonQueryAccount(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryAccount<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_jsonQueryAccountOne : public Callback_TdSession_jsonQueryAccountOne_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_jsonQueryAccountOne(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryAccountOne(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_jsonQueryAccountOnePtr
newCallback_TdSession_jsonQueryAccountOne(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryAccountOne<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_jsonQueryAccountOnePtr
newCallback_TdSession_jsonQueryAccountOne(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryAccountOne<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_jsonQueryAccountOne : public Callback_TdSession_jsonQueryAccountOne_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_jsonQueryAccountOne(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryAccountOne(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_jsonQueryAccountOnePtr
newCallback_TdSession_jsonQueryAccountOne(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryAccountOne<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_jsonQueryAccountOnePtr
newCallback_TdSession_jsonQueryAccountOne(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryAccountOne<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_jsonQueryPosition : public Callback_TdSession_jsonQueryPosition_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_jsonQueryPosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryPosition(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_jsonQueryPositionPtr
newCallback_TdSession_jsonQueryPosition(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryPosition<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_jsonQueryPositionPtr
newCallback_TdSession_jsonQueryPosition(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryPosition<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_jsonQueryPosition : public Callback_TdSession_jsonQueryPosition_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_jsonQueryPosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryPosition(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_jsonQueryPositionPtr
newCallback_TdSession_jsonQueryPosition(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryPosition<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_jsonQueryPositionPtr
newCallback_TdSession_jsonQueryPosition(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryPosition<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_jsonQueryOrder : public Callback_TdSession_jsonQueryOrder_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_jsonQueryOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_jsonQueryOrderPtr
newCallback_TdSession_jsonQueryOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryOrder<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_jsonQueryOrderPtr
newCallback_TdSession_jsonQueryOrder(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryOrder<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_jsonQueryOrder : public Callback_TdSession_jsonQueryOrder_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_jsonQueryOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_jsonQueryOrderPtr
newCallback_TdSession_jsonQueryOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_jsonQueryOrderPtr
newCallback_TdSession_jsonQueryOrder(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_jsonQueryDone : public Callback_TdSession_jsonQueryDone_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_jsonQueryDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryDone(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_jsonQueryDonePtr
newCallback_TdSession_jsonQueryDone(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryDone<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_jsonQueryDonePtr
newCallback_TdSession_jsonQueryDone(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_jsonQueryDone<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_jsonQueryDone : public Callback_TdSession_jsonQueryDone_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_jsonQueryDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_jsonQueryDone(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_jsonQueryDonePtr
newCallback_TdSession_jsonQueryDone(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryDone<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_jsonQueryDonePtr
newCallback_TdSession_jsonQueryDone(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_jsonQueryDone<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_doOrder : public Callback_TdSession_doOrder_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSession_doOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_doOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_doOrderPtr
newCallback_TdSession_doOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_doOrder<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_doOrderPtr
newCallback_TdSession_doOrder(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_doOrder<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_doOrder : public Callback_TdSession_doOrder_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSession_doOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_doOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_doOrderPtr
newCallback_TdSession_doOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_doOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_doOrderPtr
newCallback_TdSession_doOrder(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_doOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_cancleOrder : public Callback_TdSession_cancleOrder_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSession_cancleOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_cancleOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_cancleOrderPtr
newCallback_TdSession_cancleOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_cancleOrder<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_cancleOrderPtr
newCallback_TdSession_cancleOrder(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_cancleOrder<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_cancleOrder : public Callback_TdSession_cancleOrder_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSession_cancleOrder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_cancleOrder(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_cancleOrderPtr
newCallback_TdSession_cancleOrder(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_cancleOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_cancleOrderPtr
newCallback_TdSession_cancleOrder(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_cancleOrder<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_updatePassword : public Callback_TdSession_updatePassword_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSession_updatePassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_updatePassword(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_updatePasswordPtr
newCallback_TdSession_updatePassword(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_updatePassword<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_updatePasswordPtr
newCallback_TdSession_updatePassword(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_updatePassword<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_updatePassword : public Callback_TdSession_updatePassword_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSession_updatePassword(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_updatePassword(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_updatePasswordPtr
newCallback_TdSession_updatePassword(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_updatePassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_updatePasswordPtr
newCallback_TdSession_updatePassword(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_updatePassword<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_subscribe : public Callback_TdSession_subscribe_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSession_subscribe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_subscribe(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_subscribePtr
newCallback_TdSession_subscribe(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_subscribe<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_subscribePtr
newCallback_TdSession_subscribe(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_subscribe<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_subscribe : public Callback_TdSession_subscribe_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSession_subscribe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_subscribe(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_subscribePtr
newCallback_TdSession_subscribe(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_subscribe<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_subscribePtr
newCallback_TdSession_subscribe(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_subscribe<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_unSubscribe : public Callback_TdSession_unSubscribe_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_TdSession_unSubscribe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_unSubscribe(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_unSubscribePtr
newCallback_TdSession_unSubscribe(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_unSubscribe<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_unSubscribePtr
newCallback_TdSession_unSubscribe(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_unSubscribe<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_unSubscribe : public Callback_TdSession_unSubscribe_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_TdSession_unSubscribe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_unSubscribe(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_unSubscribePtr
newCallback_TdSession_unSubscribe(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_unSubscribe<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_unSubscribePtr
newCallback_TdSession_unSubscribe(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_unSubscribe<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_getTradingday : public Callback_TdSession_getTradingday_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_getTradingday(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getTradingday(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_getTradingdayPtr
newCallback_TdSession_getTradingday(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_getTradingday<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_getTradingdayPtr
newCallback_TdSession_getTradingday(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_getTradingday<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_getTradingday : public Callback_TdSession_getTradingday_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_getTradingday(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getTradingday(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_getTradingdayPtr
newCallback_TdSession_getTradingday(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_getTradingday<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_getTradingdayPtr
newCallback_TdSession_getTradingday(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_getTradingday<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_QuerySession : public Callback_TdSession_QuerySession_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_QuerySession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_QuerySession(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_QuerySessionPtr
newCallback_TdSession_QuerySession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_QuerySession<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_QuerySessionPtr
newCallback_TdSession_QuerySession(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_QuerySession<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_QuerySession : public Callback_TdSession_QuerySession_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_QuerySession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_QuerySession(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_QuerySessionPtr
newCallback_TdSession_QuerySession(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_QuerySession<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_QuerySessionPtr
newCallback_TdSession_QuerySession(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_QuerySession<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TdSession_QuerySubCurrent : public Callback_TdSession_QuerySubCurrent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TdSession_QuerySubCurrent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_QuerySubCurrent(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TdSession_QuerySubCurrentPtr
newCallback_TdSession_QuerySubCurrent(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_QuerySubCurrent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TdSession_QuerySubCurrentPtr
newCallback_TdSession_QuerySubCurrent(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TdSession_QuerySubCurrent<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TdSession_QuerySubCurrent : public Callback_TdSession_QuerySubCurrent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TdSession_QuerySubCurrent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Trade::TdSessionPrx __proxy = ::Trade::TdSessionPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_QuerySubCurrent(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TdSession_QuerySubCurrentPtr
newCallback_TdSession_QuerySubCurrent(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_QuerySubCurrent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TdSession_QuerySubCurrentPtr
newCallback_TdSession_QuerySubCurrent(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TdSession_QuerySubCurrent<T, CT>(instance, cb, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif

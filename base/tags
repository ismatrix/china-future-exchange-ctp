!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AGENT_ATTR_NODE	Attr_API.c	/^} AGENT_ATTR_NODE;$/;"	t	typeref:union:__anon24	file:
AGENT_ATTR_SET_SHM_KEY	Attr_API.c	26;"	d	file:
AGENT_ATTR_SHM_HASH_LEN	Attr_API.c	29;"	d	file:
AGENT_ATTR_SHM_HASH_TIMES	Attr_API.c	30;"	d	file:
AGENT_ATTR_SHM_SIZE	Attr_API.c	/^const int AGENT_ATTR_SHM_SIZE = sizeof(AGENT_ATTR_NODE) * AGENT_ATTR_SHM_HASH_LEN * AGENT_ATTR_SHM_HASH_TIMES;$/;"	v
AGENT_ATTR_SUM_SHM_KEY	Attr_API.c	25;"	d	file:
ATTR_API_H	Attr_API.h	23;"	d
ATTR_CREATE	ut_mysql.cpp	10;"	d	file:
ATTR_DESTROY	ut_mysql.cpp	11;"	d	file:
ATTR_EXE_DATA	Attr_API_Str.c	27;"	d	file:
ATTR_EXE_STR	Attr_API_Str.c	29;"	d	file:
ATTR_ON_CONNECT	ut_mysql.cpp	12;"	d	file:
ATTR_ON_CONNECT_FAIL	ut_mysql.cpp	14;"	d	file:
ATTR_ON_DISCONNECT	ut_mysql.cpp	13;"	d	file:
ATTR_ON_QUERY_ERR	ut_mysql.cpp	15;"	d	file:
AddObjectPool	multi_object_pool.h	/^		void AddObjectPool( string opname );$/;"	p	class:MultiObjectPool	access:protected	signature:( string opname )
AddObjectPool	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::AddObjectPool( string opname )$/;"	f	class:MultiObjectPool	signature:( string opname )
AttrProfile	Attr_API.h	/^	int AttrProfile(int iId, int iAttrId1, int iAttrId2);$/;"	p	signature:(int iId, int iAttrId1, int iAttrId2)
AttrProfile	Attr_API_Str.c	/^int AttrProfile(int iId, int iAttrId1, int iAttrId2)$/;"	f	signature:(int iId, int iAttrId1, int iAttrId2)
Attr_API	Attr_API.c	/^int Attr_API(int iAttrId, int iValue)$/;"	f	signature:(int iAttrId, int iValue)
Attr_API	Attr_API.h	/^	int Attr_API(int iAttrId, int iValue);$/;"	p	signature:(int iAttrId, int iValue)
Attr_API_Alarm	Attr_API.h	/^	int Attr_API_Alarm(int iAttrId, int iLen, char *pvalue);$/;"	p	signature:(int iAttrId, int iLen, char *pvalue)
Attr_API_Alarm	Attr_API_Str.c	/^Attr_API_Alarm(int attr_id, int len, char *pvalue)$/;"	f	signature:(int attr_id, int len, char *pvalue)
Attr_API_EX	Attr_API.c	/^int Attr_API_EX(int iAttrId, int iValue, int *piCurValue)$/;"	f	signature:(int iAttrId, int iValue, int *piCurValue)
Attr_API_EX	Attr_API.h	/^	int Attr_API_EX(int iAttrId, int iValue, int *piCurValue);$/;"	p	signature:(int iAttrId, int iValue, int *piCurValue)
Attr_API_Get	Attr_API.c	/^int Attr_API_Get(int iAttrId, int* piValue)$/;"	f	signature:(int iAttrId, int* piValue)
Attr_API_Get	Attr_API.h	/^	int Attr_API_Get(int iAttrId, int *piValue);$/;"	p	signature:(int iAttrId, int *piValue)
Attr_API_Set	Attr_API.c	/^int Attr_API_Set(int iAttrId, int iValue)$/;"	f	signature:(int iAttrId, int iValue)
Attr_API_Set	Attr_API.h	/^	int Attr_API_Set(int iAttrId, int iValue);$/;"	p	signature:(int iAttrId, int iValue)
Attr_API_Set_Var	Attr_API.h	/^	int Attr_API_Set_Var(int iAttrId, int iVarKey, int iValue);$/;"	p	signature:(int iAttrId, int iVarKey, int iValue)
Attr_API_Set_Var	Attr_API_Var.c	/^int Attr_API_Set_Var(int iAttrId, int iVarKey, int iValue)$/;"	f	signature:(int iAttrId, int iVarKey, int iValue)
Attr_API_Var	Attr_API.h	/^	int Attr_API_Var(int iAttrId, int iVarKey, int iValue);$/;"	p	signature:(int iAttrId, int iVarKey, int iValue)
Attr_API_Var	Attr_API_Var.c	/^int Attr_API_Var(int iAttrId, int iVarKey, int iValue)$/;"	f	signature:(int iAttrId, int iVarKey, int iValue)
Attr_API_Var_EX	Attr_API_Var.c	/^int Attr_API_Var_EX(int iAttrId, int iVarKey, int iValue, int *piCurValue)$/;"	f	signature:(int iAttrId, int iVarKey, int iValue, int *piCurValue)
Attr_Time_Span_Usec	Attr_API.c	/^void Attr_Time_Span_Usec(int iBaseAttr, uint32_t iTimeSpan)$/;"	f	signature:(int iBaseAttr, uint32_t iTimeSpan)
Attr_Time_Span_Usec	Attr_API.h	/^    void Attr_Time_Span_Usec(int iBaseAttr, uint32_t iTimeSpan);$/;"	p	signature:(int iBaseAttr, uint32_t iTimeSpan)
BDelete	mongoc_json.h	/^		int BDelete();$/;"	p	class:CMongodb	access:public	signature:()
BInsert	mongoc_json.h	/^		int BInsert();$/;"	p	class:CMongodb	access:public	signature:()
BUpdate	mongoc_json.h	/^		int BUpdate();$/;"	p	class:CMongodb	access:public	signature:()
CALLBACK	http.c	72;"	d	file:
CALLBACK2	http.c	56;"	d	file:
CAS2_IMPL	CAS_64bit.h	/^static bool CAS2_IMPL(uint64_t* addr, $/;"	f	signature:(uint64_t* addr, uint32_t* old_value, uint32_t* new_value)
CAS_64bit	CAS_64bit.h	24;"	d
CAS_64bit	CAS_64bit.h	26;"	d
CC	Makefile	/^CC      := gcc$/;"	m
CC	Makefile	/^CC = gcc -O3 -Wall -fno-strict-aliasing -fomit-frame-pointer -fasynchronous-unwind-tables -fPIC $/;"	m
CDayLog	RollLog.cpp	/^CDayLog::CDayLog()$/;"	f	class:CDayLog	signature:()
CDayLog	RollLog.h	/^	CDayLog();$/;"	p	class:CDayLog	access:public	signature:()
CDayLog	RollLog.h	/^	CDayLog(const CDayLog&);$/;"	p	class:CDayLog	access:public	signature:(const CDayLog&)
CDayLog	RollLog.h	/^class CDayLog$/;"	c
CDayLog::CDayLog	RollLog.cpp	/^CDayLog::CDayLog()$/;"	f	class:CDayLog	signature:()
CDayLog::CDayLog	RollLog.h	/^	CDayLog();$/;"	p	class:CDayLog	access:public	signature:()
CDayLog::CDayLog	RollLog.h	/^	CDayLog(const CDayLog&);$/;"	p	class:CDayLog	access:public	signature:(const CDayLog&)
CDayLog::FLUSH_COUNT	RollLog.h	/^	static const unsigned FLUSH_COUNT = 32;$/;"	m	class:CDayLog	access:protected
CDayLog::F_Module	RollLog.h	/^		F_Module = 1,$/;"	e	enum:CDayLog::title_flag
CDayLog::F_PID	RollLog.h	/^		F_PID = 2$/;"	e	enum:CDayLog::title_flag
CDayLog::F_Time	RollLog.h	/^		F_Time = 0,$/;"	e	enum:CDayLog::title_flag
CDayLog::Init	RollLog.cpp	/^int CDayLog::Init(const string& sPreFix,const string& module)$/;"	f	class:CDayLog	signature:(const string& sPreFix,const string& module)
CDayLog::Init	RollLog.h	/^	int Init(const std::string& sPreFix,const std::string& module);$/;"	p	class:CDayLog	access:public	signature:(const std::string& sPreFix,const std::string& module)
CDayLog::Lock	RollLog.cpp	/^bool CDayLog::Lock()$/;"	f	class:CDayLog	signature:()
CDayLog::Lock	RollLog.h	/^	bool Lock();$/;"	p	class:CDayLog	access:protected	signature:()
CDayLog::UnLock	RollLog.cpp	/^void CDayLog::UnLock()$/;"	f	class:CDayLog	signature:()
CDayLog::UnLock	RollLog.h	/^	void UnLock();\/\/{if(_lock) {if(_os.is_open()) _os<<unlock; _lock = false;} }$/;"	p	class:CDayLog	access:protected	signature:()
CDayLog::_fd	RollLog.h	/^	int _fd;$/;"	m	class:CDayLog	access:protected
CDayLog::_filename	RollLog.h	/^	std::string _filename;$/;"	m	class:CDayLog	access:protected
CDayLog::_flags	RollLog.h	/^	bool _flags[3];$/;"	m	class:CDayLog	access:protected
CDayLog::_last	RollLog.h	/^	time_t _last;$/;"	m	class:CDayLog	access:protected
CDayLog::_lock	RollLog.h	/^	bool _lock;$/;"	m	class:CDayLog	access:protected
CDayLog::_log_buffer	RollLog.h	/^	std::string _log_buffer;$/;"	m	class:CDayLog	access:protected
CDayLog::_module	RollLog.h	/^	std::string _module;$/;"	m	class:CDayLog	access:protected
CDayLog::_pid	RollLog.h	/^	unsigned _pid;$/;"	m	class:CDayLog	access:protected
CDayLog::_time_format	RollLog.h	/^	std::string _time_format;$/;"	m	class:CDayLog	access:protected
CDayLog::clear_titleflag	RollLog.h	/^	void clear_titleflag(title_flag f) {_flags[f] = false;}$/;"	f	class:CDayLog	access:public	signature:(title_flag f)
CDayLog::endl	RollLog.h	/^	friend CDayLog& endl(CDayLog& log);$/;"	p	class:CDayLog	access:friend	signature:(CDayLog& log)
CDayLog::is_same_day	RollLog.h	/^	bool is_same_day(time_t t1,time_t t2);$/;"	p	class:CDayLog	access:protected	signature:(time_t t1,time_t t2)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(char n)$/;"	f	class:CDayLog	signature:(char n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(const string& s)$/;"	f	class:CDayLog	signature:(const string& s)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(double n)$/;"	f	class:CDayLog	signature:(double n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(float n)$/;"	f	class:CDayLog	signature:(float n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(int n)$/;"	f	class:CDayLog	signature:(int n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(long long n)$/;"	f	class:CDayLog	signature:(long long n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(long n)$/;"	f	class:CDayLog	signature:(long n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(short n)$/;"	f	class:CDayLog	signature:(short n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned char n) $/;"	f	class:CDayLog	signature:(unsigned char n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned int n)$/;"	f	class:CDayLog	signature:(unsigned int n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned long long n)$/;"	f	class:CDayLog	signature:(unsigned long long n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned long n)$/;"	f	class:CDayLog	signature:(unsigned long n)
CDayLog::operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned short n)$/;"	f	class:CDayLog	signature:(unsigned short n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(__Day_Func func){ return (*func)(*this);}$/;"	f	class:CDayLog	access:public	signature:(__Day_Func func)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(char n);$/;"	p	class:CDayLog	access:public	signature:(char n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(const std::string& s);$/;"	p	class:CDayLog	access:public	signature:(const std::string& s)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(double n);$/;"	p	class:CDayLog	access:public	signature:(double n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(float n);$/;"	p	class:CDayLog	access:public	signature:(float n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(int n);$/;"	p	class:CDayLog	access:public	signature:(int n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(long long n);$/;"	p	class:CDayLog	access:public	signature:(long long n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(long n);$/;"	p	class:CDayLog	access:public	signature:(long n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(short n);$/;"	p	class:CDayLog	access:public	signature:(short n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned char n);$/;"	p	class:CDayLog	access:public	signature:(unsigned char n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned int n);$/;"	p	class:CDayLog	access:public	signature:(unsigned int n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned long long n);$/;"	p	class:CDayLog	access:public	signature:(unsigned long long n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned long n);$/;"	p	class:CDayLog	access:public	signature:(unsigned long n)
CDayLog::operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned short n);$/;"	p	class:CDayLog	access:public	signature:(unsigned short n)
CDayLog::s_day	RollLog.cpp	/^inline string CDayLog::s_day(time_t t)$/;"	f	class:CDayLog	signature:(time_t t)
CDayLog::s_day	RollLog.h	/^	std::string s_day(time_t t);$/;"	p	class:CDayLog	access:protected	signature:(time_t t)
CDayLog::s_time	RollLog.cpp	/^inline string CDayLog::s_time(time_t t)$/;"	f	class:CDayLog	signature:(time_t t)
CDayLog::s_time	RollLog.h	/^	std::string s_time(time_t t);$/;"	p	class:CDayLog	access:protected	signature:(time_t t)
CDayLog::set_titleflag	RollLog.cpp	/^void CDayLog::set_titleflag(title_flag f)$/;"	f	class:CDayLog	signature:(title_flag f)
CDayLog::set_titleflag	RollLog.h	/^	void set_titleflag(title_flag f);$/;"	p	class:CDayLog	access:public	signature:(title_flag f)
CDayLog::t_day	RollLog.cpp	/^inline time_t CDayLog::t_day(time_t t)$/;"	f	class:CDayLog	signature:(time_t t)
CDayLog::t_day	RollLog.h	/^	time_t t_day(time_t t);$/;"	p	class:CDayLog	access:protected	signature:(time_t t)
CDayLog::time_format	RollLog.h	/^	void time_format(const std::string& format="[%H:%M:%S]") {_time_format = format;}$/;"	f	class:CDayLog	access:public	signature:(const std::string& format=”)
CDayLog::title_flag	RollLog.h	/^	enum title_flag {$/;"	g	class:CDayLog	access:public
CDayLog::~CDayLog	RollLog.cpp	/^CDayLog::~CDayLog()$/;"	f	class:CDayLog	signature:()
CDayLog::~CDayLog	RollLog.h	/^	~CDayLog();$/;"	p	class:CDayLog	access:public	signature:()
CFLAGS	Makefile	/^CFLAGS  := -Wall -Wno-strict-aliasing -Wno-uninitialized $(DEFINES) $(INCLUDE)$/;"	m
CFileLock	file_lock.cpp	/^CFileLock::CFileLock(void)$/;"	f	class:CFileLock	signature:(void)
CFileLock	file_lock.h	/^    CFileLock(void);$/;"	p	class:CFileLock	access:public	signature:(void)
CFileLock	file_lock.h	/^class CFileLock$/;"	c
CFileLock::CFileLock	file_lock.cpp	/^CFileLock::CFileLock(void)$/;"	f	class:CFileLock	signature:(void)
CFileLock::CFileLock	file_lock.h	/^    CFileLock(void);$/;"	p	class:CFileLock	access:public	signature:(void)
CFileLock::ERROR	file_lock.h	/^    const static int ERROR = -1;$/;"	m	class:CFileLock	access:public
CFileLock::E_FILE_LOCK_CREATE_FILE	file_lock.h	/^    const static int E_FILE_LOCK_CREATE_FILE = -201;$/;"	m	class:CFileLock	access:public
CFileLock::FILE_LOCK_READ	file_lock.h	/^    const static int FILE_LOCK_READ = 1;$/;"	m	class:CFileLock	access:public
CFileLock::FILE_LOCK_WRITE	file_lock.h	/^    const static int FILE_LOCK_WRITE = 2;$/;"	m	class:CFileLock	access:public
CFileLock::Init	file_lock.cpp	/^int CFileLock::Init(const char *pszFileName)$/;"	f	class:CFileLock	signature:(const char *pszFileName)
CFileLock::Init	file_lock.h	/^    int Init(const char *pszFileName);$/;"	p	class:CFileLock	access:public	signature:(const char *pszFileName)
CFileLock::Lock	file_lock.cpp	/^int CFileLock::Lock(int iType, int iOffSet, int iSize, int iWaitFlag \/*= 1*\/)$/;"	f	class:CFileLock	signature:(int iType, int iOffSet, int iSize, int iWaitFlag )
CFileLock::Lock	file_lock.h	/^    int Lock(int iType, int iOffSet, int iSize, int iWaitFlag = 1);$/;"	p	class:CFileLock	access:public	signature:(int iType, int iOffSet, int iSize, int iWaitFlag = 1)
CFileLock::SUCCESS	file_lock.h	/^    const static int SUCCESS = 0;$/;"	m	class:CFileLock	access:public
CFileLock::UnLock	file_lock.cpp	/^int CFileLock::UnLock(int iOffSet, int iSize)$/;"	f	class:CFileLock	signature:(int iOffSet, int iSize)
CFileLock::UnLock	file_lock.h	/^    int UnLock(int iOffSet, int iSize);$/;"	p	class:CFileLock	access:public	signature:(int iOffSet, int iSize)
CFileLock::m_iFile	file_lock.h	/^    int m_iFile;$/;"	m	class:CFileLock	access:private
CFileLock::~CFileLock	file_lock.cpp	/^CFileLock::~CFileLock(void)$/;"	f	class:CFileLock	signature:(void)
CFileLock::~CFileLock	file_lock.h	/^    ~CFileLock(void);$/;"	p	class:CFileLock	access:public	signature:(void)
CHUNKED	http.c	94;"	d	file:
CLOSE	http.c	96;"	d	file:
CMongodb	mongoc_json.cpp	/^CMongodb::CMongodb()$/;"	f	class:CMongodb	signature:()
CMongodb	mongoc_json.cpp	/^CMongodb::CMongodb(const char* uri, const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* uri, const char* db, const char* collection)
CMongodb	mongoc_json.h	/^		CMongodb();$/;"	p	class:CMongodb	access:public	signature:()
CMongodb	mongoc_json.h	/^		CMongodb(const char* uri, const char* db, const char* collection);$/;"	p	class:CMongodb	access:public	signature:(const char* uri, const char* db, const char* collection)
CMongodb	mongoc_json.h	/^class CMongodb$/;"	c
CMongodb::BDelete	mongoc_json.h	/^		int BDelete();$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::BInsert	mongoc_json.h	/^		int BInsert();$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::BUpdate	mongoc_json.h	/^		int BUpdate();$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::CMongodb	mongoc_json.cpp	/^CMongodb::CMongodb()$/;"	f	class:CMongodb	signature:()
CMongodb::CMongodb	mongoc_json.cpp	/^CMongodb::CMongodb(const char* uri, const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* uri, const char* db, const char* collection)
CMongodb::CMongodb	mongoc_json.h	/^		CMongodb();$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::CMongodb	mongoc_json.h	/^		CMongodb(const char* uri, const char* db, const char* collection);$/;"	p	class:CMongodb	access:public	signature:(const char* uri, const char* db, const char* collection)
CMongodb::ChangeCollection	mongoc_json.cpp	/^int CMongodb::ChangeCollection(const char* collection)$/;"	f	class:CMongodb	signature:(const char* collection)
CMongodb::ChangeCollection	mongoc_json.h	/^		int		ChangeCollection(const char* collection);$/;"	p	class:CMongodb	access:public	signature:(const char* collection)
CMongodb::Delete	mongoc_json.cpp	/^int  CMongodb::Delete(string json)$/;"	f	class:CMongodb	signature:(string json)
CMongodb::Delete	mongoc_json.h	/^		int		Delete(string json);									\/\/Âà†Èô§$/;"	p	class:CMongodb	access:public	signature:(string json)
CMongodb::GetCount	mongoc_json.cpp	/^int CMongodb::GetCount()$/;"	f	class:CMongodb	signature:()
CMongodb::GetCount	mongoc_json.h	/^		int		GetCount();		\/\/Ëé∑ÂèñÂèóÂΩ±ÂìçÁöÑË°å$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::GetLastCode	mongoc_json.cpp	/^int  CMongodb::GetLastCode()$/;"	f	class:CMongodb	signature:()
CMongodb::GetLastCode	mongoc_json.h	/^		int  	GetLastCode();	\/\/Ëé∑ÂèñÊúÄÂêé‰∏ÄÊù°ÈîôËØØ‰ª£Á†Å$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::GetLastErr	mongoc_json.cpp	/^const char*  CMongodb::GetLastErr()$/;"	f	class:CMongodb	signature:()
CMongodb::GetLastErr	mongoc_json.h	/^		const char*  GetLastErr();	\/\/Ëé∑ÂèñÊúÄÂêé‰∏ÄÊù°ÈîôËØØ‰ø°ÊÅØ$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::GetResult	mongoc_json.cpp	/^char* CMongodb::GetResult()$/;"	f	class:CMongodb	signature:()
CMongodb::GetResult	mongoc_json.h	/^		char*   GetResult();	\/\/Ëé∑ÂèñÊü•ËØ¢ÁªìÊûú$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::Init	mongoc_json.cpp	/^int CMongodb::Init(const char* uri, const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* uri, const char* db, const char* collection)
CMongodb::Init	mongoc_json.h	/^		int 	Init(const char* uri, const char* db, const char* collection);	\/\/ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* uri, const char* db, const char* collection)
CMongodb::Insert	mongoc_json.cpp	/^int CMongodb::Insert(string json)$/;"	f	class:CMongodb	signature:(string json)
CMongodb::Insert	mongoc_json.h	/^		int		Insert(string json);									\/\/ÊèíÂÖ•$/;"	p	class:CMongodb	access:public	signature:(string json)
CMongodb::Instance	mongoc_json.cpp	/^CMongodb& CMongodb::Instance()$/;"	f	class:CMongodb	signature:()
CMongodb::Instance	mongoc_json.h	/^		static CMongodb& Instance();	\/\/Âçï‰æãÊ®°Âºè ÈúÄË¶ÅInit$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::Next	mongoc_json.cpp	/^bool CMongodb::Next()$/;"	f	class:CMongodb	signature:()
CMongodb::Next	mongoc_json.h	/^		bool	Next();			\/\/ÁßªÂä®Ê∏∏Ê†áÂà∞‰∏ã‰∏ÄÊù°$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::Query	mongoc_json.cpp	/^int  CMongodb::Query(string json, uint32_t skip, uint32_t limit)$/;"	f	class:CMongodb	signature:(string json, uint32_t skip, uint32_t limit)
CMongodb::Query	mongoc_json.h	/^		int		Query(string json, uint32_t skip=0, uint32_t limit=0); 	\/\/Êü•ËØ¢$/;"	p	class:CMongodb	access:public	signature:(string json, uint32_t skip=0, uint32_t limit=0)
CMongodb::ReInit	mongoc_json.cpp	/^int CMongodb::ReInit(const char* collection)$/;"	f	class:CMongodb	signature:(const char* collection)
CMongodb::ReInit	mongoc_json.cpp	/^int CMongodb::ReInit(const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* db, const char* collection)
CMongodb::ReInit	mongoc_json.cpp	/^int CMongodb::ReInit(const char* uri, const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* uri, const char* db, const char* collection)
CMongodb::ReInit	mongoc_json.h	/^		int 	ReInit(const char* collection);					\/\/ÈáçÊñ∞ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* collection)
CMongodb::ReInit	mongoc_json.h	/^		int 	ReInit(const char* db, const char* collection);					\/\/ÈáçÊñ∞ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* db, const char* collection)
CMongodb::ReInit	mongoc_json.h	/^		int 	ReInit(const char* uri, const char* db, const char* collection);\/\/ÈáçÊñ∞ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* uri, const char* db, const char* collection)
CMongodb::Release	mongoc_json.cpp	/^void CMongodb::Release()$/;"	f	class:CMongodb	signature:()
CMongodb::Release	mongoc_json.h	/^		void	Release();		\/\/ÈáäÊîæÊú¨Ê¨°Êü•ËØ¢Áõ∏ÂÖ≥ÂÜÖÂ≠ò$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::UnInit	mongoc_json.cpp	/^int CMongodb::UnInit()$/;"	f	class:CMongodb	signature:()
CMongodb::UnInit	mongoc_json.h	/^		int 	UnInit();$/;"	p	class:CMongodb	access:public	signature:()
CMongodb::Update	mongoc_json.cpp	/^int CMongodb::Update(string json_set, string json_query, bool upsert)$/;"	f	class:CMongodb	signature:(string json_set, string json_query, bool upsert)
CMongodb::Update	mongoc_json.h	/^		int		Update(string json_set, string json_query, bool upsert=false);	\/\/Êõ¥Êñ∞ upsert=true‰∏çÂ≠òÂú®Â∞±ÊèíÂÖ•$/;"	p	class:CMongodb	access:public	signature:(string json_set, string json_query, bool upsert=false)
CMongodb::_retry	mongoc_json.h	/^		int _retry;$/;"	m	class:CMongodb	access:private
CMongodb::m_client	mongoc_json.h	/^		mongoc_client_t*		m_client;		\/\/ÂÆ¢Êà∑Á´Ø$/;"	m	class:CMongodb	access:private
CMongodb::m_collection	mongoc_json.h	/^		mongoc_collection_t*	m_collection;	\/\/Êü•ËØ¢ÈõÜÂêà$/;"	m	class:CMongodb	access:private
CMongodb::m_connected	mongoc_json.h	/^		bool					m_connected;	\/\/ÊòØÂê¶ËøûÊé•Áä∂ÊÄÅ$/;"	m	class:CMongodb	access:private
CMongodb::m_cursor	mongoc_json.h	/^		mongoc_cursor_t*		m_cursor;		\/\/Êü•ËØ¢Êó∂ÁöÑÊ∏∏Ê†á$/;"	m	class:CMongodb	access:private
CMongodb::m_db	mongoc_json.h	/^		string					m_db;			\/\/dbÂêçÂ≠ó$/;"	m	class:CMongodb	access:private
CMongodb::m_error	mongoc_json.h	/^		bson_error_t 			m_error;			\/\/ÈîôËØØ‰ø°ÊÅØÂ≠òÂÇ®$/;"	m	class:CMongodb	access:private
CMongodb::m_instance	mongoc_json.cpp	/^CMongodb*    CMongodb::m_instance = NULL;	$/;"	m	class:CMongodb	file:
CMongodb::m_instance	mongoc_json.h	/^		static CMongodb*    m_instance;	$/;"	m	class:CMongodb	access:private
CMongodb::m_pjson	mongoc_json.h	/^		char* 					m_pjson;		\/\/Êü•ËØ¢next‰πãÂêéÁöÑÂÜÖÂ≠ò $/;"	m	class:CMongodb	access:private
CMongodb::m_query	mongoc_json.h	/^		const bson_t*			m_query;		\/\/bson_t queryÂØπË±°$/;"	m	class:CMongodb	access:private
CMongodb::m_result	mongoc_json.h	/^		 bson_t*				m_result;		\/\/bson_t queryÂØπË±°$/;"	m	class:CMongodb	access:private
CMongodb::m_uri	mongoc_json.h	/^		string					m_uri;			\/\/mongodbËøûÊé•Âú∞ÂùÄ$/;"	m	class:CMongodb	access:private
CMongodb::~CMongodb	mongoc_json.cpp	/^CMongodb::~CMongodb()$/;"	f	class:CMongodb	signature:()
CMongodb::~CMongodb	mongoc_json.h	/^		~CMongodb();$/;"	p	class:CMongodb	access:public	signature:()
CODE_CONVERT_H	convert.h	2;"	d
CONNECTION	http.c	90;"	d	file:
CONTENT_LENGTH	http.c	91;"	d	file:
CR	http.c	319;"	d	file:
CRollLog	RollLog.cpp	/^CRollLog::CRollLog()$/;"	f	class:CRollLog	signature:()
CRollLog	RollLog.h	/^	CRollLog();$/;"	p	class:CRollLog	access:public	signature:()
CRollLog	RollLog.h	/^	CRollLog(const CRollLog&);$/;"	p	class:CRollLog	access:public	signature:(const CRollLog&)
CRollLog	RollLog.h	/^class CRollLog$/;"	c
CRollLog::CRollLog	RollLog.cpp	/^CRollLog::CRollLog()$/;"	f	class:CRollLog	signature:()
CRollLog::CRollLog	RollLog.h	/^	CRollLog();$/;"	p	class:CRollLog	access:public	signature:()
CRollLog::CRollLog	RollLog.h	/^	CRollLog(const CRollLog&);$/;"	p	class:CRollLog	access:public	signature:(const CRollLog&)
CRollLog::DEBUG_LOG	RollLog.h	/^		DEBUG_LOG = 4  $/;"	e	enum:CRollLog::Log_Level
CRollLog::ERROR_LOG	RollLog.h	/^		ERROR_LOG = 2,  $/;"	e	enum:CRollLog::Log_Level
CRollLog::FLUSH_COUNT	RollLog.h	/^	static const unsigned FLUSH_COUNT = 32;$/;"	m	class:CRollLog	access:protected
CRollLog::F_DEBUGTIP	RollLog.h	/^		F_DEBUGTIP = 3$/;"	e	enum:CRollLog::title_flag
CRollLog::F_Module	RollLog.h	/^		F_Module = 1,$/;"	e	enum:CRollLog::title_flag
CRollLog::F_PID	RollLog.h	/^		F_PID = 2,$/;"	e	enum:CRollLog::title_flag
CRollLog::F_Time	RollLog.h	/^		F_Time = 0,$/;"	e	enum:CRollLog::title_flag
CRollLog::Init	RollLog.cpp	/^int CRollLog::Init(const string & sPreFix, const string & module, size_t maxsize, size_t maxnum)$/;"	f	class:CRollLog	signature:(const string & sPreFix, const string & module, size_t maxsize, size_t maxnum)
CRollLog::Init	RollLog.h	/^	int Init(const std::string& sPreFix,const std::string& module,size_t maxsize,size_t maxnum=10);$/;"	p	class:CRollLog	access:public	signature:(const std::string& sPreFix,const std::string& module,size_t maxsize,size_t maxnum=10)
CRollLog::Log_Level	RollLog.h	/^	enum Log_Level{$/;"	g	class:CRollLog	access:public
CRollLog::NORMAL_LOG	RollLog.h	/^		NORMAL_LOG = 3, $/;"	e	enum:CRollLog::Log_Level
CRollLog::NO_LOG	RollLog.h	/^		NO_LOG = 1,  $/;"	e	enum:CRollLog::Log_Level
CRollLog::_buf_count	RollLog.h	/^	unsigned _buf_count;$/;"	m	class:CRollLog	access:protected
CRollLog::_debugtip	RollLog.h	/^	std::string _debugtip;$/;"	m	class:CRollLog	access:protected
CRollLog::_fd	RollLog.h	/^	int _fd;$/;"	m	class:CRollLog	access:protected
CRollLog::_filename	RollLog.h	/^	std::string _filename;$/;"	m	class:CRollLog	access:protected
CRollLog::_flags	RollLog.h	/^	bool _flags[4];$/;"	m	class:CRollLog	access:protected
CRollLog::_level	RollLog.h	/^	Log_Level _level;$/;"	m	class:CRollLog	access:protected
CRollLog::_lock	RollLog.h	/^	bool _lock;$/;"	m	class:CRollLog	access:protected
CRollLog::_log_buffer	RollLog.h	/^	std::string _log_buffer;$/;"	m	class:CRollLog	access:protected
CRollLog::_max_log_num	RollLog.h	/^	unsigned _max_log_num;$/;"	m	class:CRollLog	access:protected
CRollLog::_max_log_size	RollLog.h	/^	unsigned _max_log_size;$/;"	m	class:CRollLog	access:protected
CRollLog::_module	RollLog.h	/^	std::string _module;$/;"	m	class:CRollLog	access:protected
CRollLog::_pid	RollLog.h	/^	unsigned _pid;$/;"	m	class:CRollLog	access:protected
CRollLog::_setlevel	RollLog.h	/^	Log_Level _setlevel;$/;"	m	class:CRollLog	access:protected
CRollLog::_time_format	RollLog.h	/^	std::string _time_format;$/;"	m	class:CRollLog	access:protected
CRollLog::adderror	RollLog.h	/^	friend CRollLog& adderror(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
CRollLog::check_level	RollLog.cpp	/^bool CRollLog::check_level()$/;"	f	class:CRollLog	signature:()
CRollLog::check_level	RollLog.h	/^	bool check_level(); $/;"	p	class:CRollLog	access:protected	signature:()
CRollLog::clear_titleflag	RollLog.h	/^	void clear_titleflag(title_flag f) {_flags[f] = false;}$/;"	f	class:CRollLog	access:public	signature:(title_flag f)
CRollLog::cur_time	RollLog.cpp	/^inline string CRollLog::cur_time()$/;"	f	class:CRollLog	signature:()
CRollLog::cur_time	RollLog.h	/^	std::string cur_time();$/;"	p	class:CRollLog	access:protected	signature:()
CRollLog::debug	RollLog.h	/^	friend CRollLog& debug(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
CRollLog::endl	RollLog.h	/^	friend CRollLog& endl(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
CRollLog::nolog	RollLog.h	/^	friend CRollLog& nolog(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
CRollLog::normal	RollLog.h	/^	friend CRollLog& normal(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(char n)$/;"	f	class:CRollLog	signature:(char n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(const string& s)$/;"	f	class:CRollLog	signature:(const string& s)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(double n)$/;"	f	class:CRollLog	signature:(double n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(float n)$/;"	f	class:CRollLog	signature:(float n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(int n)$/;"	f	class:CRollLog	signature:(int n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(long long n)$/;"	f	class:CRollLog	signature:(long long n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(long n)$/;"	f	class:CRollLog	signature:(long n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(short n)$/;"	f	class:CRollLog	signature:(short n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned char n) $/;"	f	class:CRollLog	signature:(unsigned char n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned int n)$/;"	f	class:CRollLog	signature:(unsigned int n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned long long n)$/;"	f	class:CRollLog	signature:(unsigned long long n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned long n)$/;"	f	class:CRollLog	signature:(unsigned long n)
CRollLog::operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned short n)$/;"	f	class:CRollLog	signature:(unsigned short n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(__Roll_Func func){ return (*func)(*this);}$/;"	f	class:CRollLog	access:public	signature:(__Roll_Func func)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(char n);$/;"	p	class:CRollLog	access:public	signature:(char n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(const std::string& s);$/;"	p	class:CRollLog	access:public	signature:(const std::string& s)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(double n);$/;"	p	class:CRollLog	access:public	signature:(double n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(float n);$/;"	p	class:CRollLog	access:public	signature:(float n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(int n);$/;"	p	class:CRollLog	access:public	signature:(int n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(long long n);$/;"	p	class:CRollLog	access:public	signature:(long long n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(long n);$/;"	p	class:CRollLog	access:public	signature:(long n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(short n);$/;"	p	class:CRollLog	access:public	signature:(short n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned char n);$/;"	p	class:CRollLog	access:public	signature:(unsigned char n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned int n);$/;"	p	class:CRollLog	access:public	signature:(unsigned int n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned long long n);$/;"	p	class:CRollLog	access:public	signature:(unsigned long long n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned long n);$/;"	p	class:CRollLog	access:public	signature:(unsigned long n)
CRollLog::operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned short n);$/;"	p	class:CRollLog	access:public	signature:(unsigned short n)
CRollLog::set_level	RollLog.h	/^	void set_level(Log_Level l){_setlevel = l;}$/;"	f	class:CRollLog	access:public	signature:(Log_Level l)
CRollLog::set_module	RollLog.h	/^	void set_module(const std::string& module){_module = module;}$/;"	f	class:CRollLog	access:public	signature:(const std::string& module)
CRollLog::set_titleflag	RollLog.cpp	/^void CRollLog::set_titleflag(title_flag f)$/;"	f	class:CRollLog	signature:(title_flag f)
CRollLog::set_titleflag	RollLog.h	/^	void set_titleflag(title_flag f); $/;"	p	class:CRollLog	access:public	signature:(title_flag f)
CRollLog::time_format	RollLog.h	/^	void time_format(const std::string& format="[%Y-%m-%d %H:%M:%S]") {_time_format = format;}$/;"	f	class:CRollLog	access:public	signature:(const std::string& format=”)
CRollLog::title_flag	RollLog.h	/^	enum title_flag {$/;"	g	class:CRollLog	access:public
CRollLog::~CRollLog	RollLog.cpp	/^CRollLog::~CRollLog()$/;"	f	class:CRollLog	signature:()
CRollLog::~CRollLog	RollLog.h	/^	~CRollLog();$/;"	p	class:CRollLog	access:public	signature:()
CalcKey	Attr_API_Var.c	/^static inline int CalcKey(int iAttrId, int iVarKey, int iMod)$/;"	f	file:	signature:(int iAttrId, int iVarKey, int iMod)
ChangeCollection	mongoc_json.cpp	/^int CMongodb::ChangeCollection(const char* collection)$/;"	f	class:CMongodb	signature:(const char* collection)
ChangeCollection	mongoc_json.h	/^		int		ChangeCollection(const char* collection);$/;"	p	class:CMongodb	access:public	signature:(const char* collection)
CodeConvert	convert.cpp	/^int  CodeConvert(const char* from, const char* to, char* src, size_t inlen, char* dest, size_t outlen)$/;"	f	signature:(const char* from, const char* to, char* src, size_t inlen, char* dest, size_t outlen)
Conf	conf.cpp	/^Conf::Conf(void)$/;"	f	class:Conf	signature:(void)
Conf	conf.h	/^	Conf(void);$/;"	p	class:Conf	access:public	signature:(void)
Conf	conf.h	/^class Conf$/;"	c
Conf::Conf	conf.cpp	/^Conf::Conf(void)$/;"	f	class:Conf	signature:(void)
Conf::Conf	conf.h	/^	Conf(void);$/;"	p	class:Conf	access:public	signature:(void)
Conf::cnf_section_t	conf.h	/^	typedef std::map< std::string, std::string > cnf_section_t;$/;"	t	class:Conf	access:private
Conf::config	conf.h	/^	section_map_t config;$/;"	m	class:Conf	access:private
Conf::get	conf.cpp	/^char* Conf::get(const std::string& section, const std::string& name, char* value, const std::string& def)$/;"	f	class:Conf	signature:(const std::string& section, const std::string& name, char* value, const std::string& def)
Conf::get	conf.cpp	/^std::string& Conf::get(const std::string& section, const std::string& name, std::string& value, const std::string& def)$/;"	f	class:Conf	signature:(const std::string& section, const std::string& name, std::string& value, const std::string& def)
Conf::get	conf.h	/^	T& get(const std::string& section, const std::string& name, T& value, const std::string& def = "")$/;"	f	class:Conf	access:public	signature:(const std::string& section, const std::string& name, T& value, const std::string& def = ”)
Conf::get	conf.h	/^	char* get(const std::string& section, const std::string& name, char* value, const std::string& def = "");$/;"	p	class:Conf	access:public	signature:(const std::string& section, const std::string& name, char* value, const std::string& def = ”)
Conf::get	conf.h	/^	std::string& get(const std::string& section, const std::string& name, std::string& value, const std::string& def = "");$/;"	p	class:Conf	access:public	signature:(const std::string& section, const std::string& name, std::string& value, const std::string& def = ”)
Conf::load	conf.cpp	/^bool Conf::load(const std::string& file_name)$/;"	f	class:Conf	signature:(const std::string& file_name)
Conf::load	conf.h	/^	bool load(const std::string& file_name);$/;"	p	class:Conf	access:public	signature:(const std::string& file_name)
Conf::load_data_from_stream	conf.cpp	/^bool Conf::load_data_from_stream(std::basic_istream<char>& ifs)$/;"	f	class:Conf	signature:(std::basic_istream<char>& ifs)
Conf::load_data_from_stream	conf.h	/^	bool load_data_from_stream(std::basic_istream<char>& stream);$/;"	p	class:Conf	access:private	signature:(std::basic_istream<char>& stream)
Conf::parse	conf.cpp	/^bool Conf::parse(const std::string& data)$/;"	f	class:Conf	signature:(const std::string& data)
Conf::parse	conf.h	/^	bool parse(const std::string& data);$/;"	p	class:Conf	access:public	signature:(const std::string& data)
Conf::section_map_t	conf.h	/^	typedef std::map< std::string, cnf_section_t > section_map_t;$/;"	t	class:Conf	access:private
Conf::~Conf	conf.cpp	/^Conf::~Conf(void)$/;"	f	class:Conf	signature:(void)
Conf::~Conf	conf.h	/^	~Conf(void);$/;"	p	class:Conf	access:public	signature:(void)
CreateObject	object_pool.h	/^		virtual TObject * CreateObject( );$/;"	p	class:ObjectPool	access:private	signature:( )
CreateObject	object_pool.h	/^TObject * ObjectPool<TObject, ConstructorType>::CreateObject( )$/;"	f	class:ObjectPool	signature:( )
CreateOrUpdateNode	Attr_API.c	/^static int CreateOrUpdateNode(volatile void* pShm, uint32_t dwAttrId, uint32_t dwNewVal, UPDATE_METHOD_PTR UpdateNode, uint32_t dwRecurDepth, uint32_t* pdwValue)$/;"	f	file:	signature:(volatile void* pShm, uint32_t dwAttrId, uint32_t dwNewVal, UPDATE_METHOD_PTR UpdateNode, uint32_t dwRecurDepth, uint32_t* pdwValue)
CreateOrUpdateNode	Attr_API_Var.c	/^int CreateOrUpdateNode(volatile void* pShm, int iAttrId, int iVarKey, uint32_t dwNewVal, UPDATE_METHOD_PTR UpdateNode, uint32_t* pdwValue)$/;"	f	signature:(volatile void* pShm, int iAttrId, int iVarKey, uint32_t dwNewVal, UPDATE_METHOD_PTR UpdateNode, uint32_t* pdwValue)
DEBUG_LOG	RollLog.h	/^		DEBUG_LOG = 4  $/;"	e	enum:CRollLog::Log_Level
DEFAULT_BUCKET	object_pool.h	30;"	d
DEFAULT_POOL_SIZE	object_pool.h	29;"	d
DEFAULT_RESERVE_TIMEOUT	object_pool.h	31;"	d
DEFINES	Makefile	/^DEFINES :=$/;"	m
DELTA	crypt_tea.cpp	21;"	d	file:
DEP_ATTTIBUTE_BASE	Attr_API_Str.c	22;"	d	file:
DEP_SHM_ID	Attr_API_Str.c	21;"	d	file:
DEP_SHM_LOCK_ID	Attr_API_Str.c	20;"	d	file:
DES3_dec_test	crypt_3des.c	/^static unsigned char DES3_dec_test[3][8] =$/;"	v	file:
DES3_enc_test	crypt_3des.c	/^static unsigned char DES3_enc_test[3][8] =$/;"	v	file:
DES3_init	crypt_3des.c	/^static unsigned char DES3_init[8] =$/;"	v	file:
DES3_keys	crypt_3des.c	/^static unsigned char DES3_keys[3][8] =$/;"	v	file:
DES_FP	crypt_3des.c	222;"	d	file:
DES_IP	crypt_3des.c	209;"	d	file:
DES_ROUND	crypt_3des.c	235;"	d	file:
DO_PACKF	pack.c	253;"	d	file:
DO_UNPACKF	pack.c	557;"	d	file:
DecreaseUsing	object_pool.h	/^		void DecreaseUsing( void )$/;"	f	class:ObjectPool	access:protected	signature:( void )
Delete	mongoc_json.cpp	/^int  CMongodb::Delete(string json)$/;"	f	class:CMongodb	signature:(string json)
Delete	mongoc_json.h	/^		int		Delete(string json);									\/\/Âà†Èô§$/;"	p	class:CMongodb	access:public	signature:(string json)
DetachShm	Attr_API.c	/^static void DetachShm(void)$/;"	f	file:	signature:(void)
DetachShm	Attr_API_Var.c	/^static void DetachShm(void)$/;"	f	file:	signature:(void)
DumpHex	debug.c	/^const char *DumpHex(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen)$/;"	f	signature:(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen)
DumpHex	debug.h	/^const char *DumpHex(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen);$/;"	p	signature:(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen)
DumpMemory	debug.c	/^const char *DumpMemory(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen)$/;"	f	signature:(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen)
DumpMemory	debug.h	/^const char *DumpMemory(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen);$/;"	p	signature:(void *pMem, uint32_t uDumpOffset, uint32_t uDumpLen)
DumpPackage	debug.c	/^const char *DumpPackage(void *pPkg, int iPkgLen)$/;"	f	signature:(void *pPkg, int iPkgLen)
DumpPackage	debug.h	/^const char *DumpPackage(void *pPkg, int iPkgLen);$/;"	p	signature:(void *pPkg, int iPkgLen)
ERROR	file_lock.h	/^    const static int ERROR = -1;$/;"	m	class:CFileLock	access:public
ERROR_LOG	RollLog.h	/^		ERROR_LOG = 2,  $/;"	e	enum:CRollLog::Log_Level
ERR_RET_FMT	pack.c	37;"	d	file:
ERR_RET_PRINT	pack.c	53;"	d	file:
E_FILE_LOCK_CREATE_FILE	file_lock.h	/^    const static int E_FILE_LOCK_CREATE_FILE = -201;$/;"	m	class:CFileLock	access:public
F	crypt_sha1.c	108;"	d	file:
F	crypt_sha1.c	110;"	d	file:
F	crypt_sha1.c	135;"	d	file:
F	crypt_sha1.c	137;"	d	file:
F	crypt_sha1.c	162;"	d	file:
F	crypt_sha1.c	164;"	d	file:
F	crypt_sha1.c	189;"	d	file:
F	crypt_sha1.c	83;"	d	file:
F	md5.cpp	/^inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
F	md5.h	/^  static inline uint4 F(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
F0	crypt_sha256.c	73;"	d	file:
F1	crypt_md5.c	151;"	d	file:
F1	crypt_sha256.c	74;"	d	file:
F2	crypt_md5.c	152;"	d	file:
F3	crypt_md5.c	153;"	d	file:
F4	crypt_md5.c	154;"	d	file:
FF	md5.cpp	/^inline void MD5::FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
FF	md5.h	/^  static inline void FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
FILE_LOCK_READ	file_lock.h	/^    const static int FILE_LOCK_READ = 1;$/;"	m	class:CFileLock	access:public
FILE_LOCK_WRITE	file_lock.h	/^    const static int FILE_LOCK_WRITE = 2;$/;"	m	class:CFileLock	access:public
FLUSH_COUNT	RollLog.h	/^	static const unsigned FLUSH_COUNT = 32;$/;"	m	class:CDayLog	access:protected
FLUSH_COUNT	RollLog.h	/^	static const unsigned FLUSH_COUNT = 32;$/;"	m	class:CRollLog	access:protected
FROM_ARG	pack.c	21;"	d	file:
FROM_PTR	pack.c	22;"	d	file:
F_CHUNKED	http.h	/^  { F_CHUNKED = 1 << 0$/;"	e	enum:flags
F_CONNECTION_CLOSE	http.h	/^  , F_CONNECTION_CLOSE = 1 << 2$/;"	e	enum:flags
F_CONNECTION_KEEP_ALIVE	http.h	/^  , F_CONNECTION_KEEP_ALIVE = 1 << 1$/;"	e	enum:flags
F_DEBUGTIP	RollLog.h	/^		F_DEBUGTIP = 3$/;"	e	enum:CRollLog::title_flag
F_Module	RollLog.h	/^		F_Module = 1,$/;"	e	enum:CDayLog::title_flag
F_Module	RollLog.h	/^		F_Module = 1,$/;"	e	enum:CRollLog::title_flag
F_PID	RollLog.h	/^		F_PID = 2$/;"	e	enum:CDayLog::title_flag
F_PID	RollLog.h	/^		F_PID = 2,$/;"	e	enum:CRollLog::title_flag
F_SKIPBODY	http.h	/^  , F_SKIPBODY = 1 << 5$/;"	e	enum:flags
F_TRAILING	http.h	/^  , F_TRAILING = 1 << 3$/;"	e	enum:flags
F_Time	RollLog.h	/^		F_Time = 0,$/;"	e	enum:CDayLog::title_flag
F_Time	RollLog.h	/^		F_Time = 0,$/;"	e	enum:CRollLog::title_flag
F_UPGRADE	http.h	/^  , F_UPGRADE = 1 << 4$/;"	e	enum:flags
Fifo	fifo.h	/^} Fifo;$/;"	t	typeref:struct:__anon1
FreeObject	multi_object_pool.h	/^		void FreeObject( TObject * cpoTObject );$/;"	p	class:MultiObjectPool	access:public	signature:( TObject * cpoTObject )
FreeObject	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::FreeObject( TObject * apoTObject )$/;"	f	class:MultiObjectPool	signature:( TObject * apoTObject )
FreeObject	object_pool.h	/^		virtual void FreeObject( TObject * apoTConn );$/;"	p	class:ObjectPool	access:public	signature:( TObject * apoTConn )
FreeObject	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::FreeObject( TObject * apoTConn )$/;"	f	class:ObjectPool	signature:( TObject * apoTConn )
FreeSize	object_pool.h	/^		int FreeSize( );$/;"	p	class:ObjectPool	access:public	signature:( )
FreeSize	object_pool.h	/^int ObjectPool<TObject, ConstructorType>::FreeSize( void )$/;"	f	class:ObjectPool	signature:( void )
G	md5.cpp	/^inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
G	md5.h	/^  static inline uint4 G(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
GBK2UTF8	convert.cpp	/^int GBK2UTF8(char* src, int inlen, char* dest, int outlen)$/;"	f	signature:(char* src, int inlen, char* dest, int outlen)
GBK2UTF8	convert.h	/^int GBK2UTF8(char* src, int inlen, char* dest, int outlen);$/;"	p	signature:(char* src, int inlen, char* dest, int outlen)
GET_LV	pack.c	547;"	d	file:
GET_LV_LEN	pack.c	540;"	d	file:
GET_UINT32	crypt_3des.c	191;"	d	file:
GET_UINT32	crypt_sha1.c	14;"	d	file:
GET_uint32_t	crypt_sha256.c	11;"	d	file:
GG	md5.cpp	/^inline void MD5::GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
GG	md5.h	/^  static inline void GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
GetCount	mongoc_json.cpp	/^int CMongodb::GetCount()$/;"	f	class:CMongodb	signature:()
GetCount	mongoc_json.h	/^		int		GetCount();		\/\/Ëé∑ÂèñÂèóÂΩ±ÂìçÁöÑË°å$/;"	p	class:CMongodb	access:public	signature:()
GetLastCode	mongoc_json.cpp	/^int  CMongodb::GetLastCode()$/;"	f	class:CMongodb	signature:()
GetLastCode	mongoc_json.h	/^		int  	GetLastCode();	\/\/Ëé∑ÂèñÊúÄÂêé‰∏ÄÊù°ÈîôËØØ‰ª£Á†Å$/;"	p	class:CMongodb	access:public	signature:()
GetLastErr	mongoc_json.cpp	/^const char*  CMongodb::GetLastErr()$/;"	f	class:CMongodb	signature:()
GetLastErr	mongoc_json.h	/^		const char*  GetLastErr();	\/\/Ëé∑ÂèñÊúÄÂêé‰∏ÄÊù°ÈîôËØØ‰ø°ÊÅØ$/;"	p	class:CMongodb	access:public	signature:()
GetObject	multi_object_pool.h	/^		TObject * GetObject( string opname );$/;"	p	class:MultiObjectPool	access:public	signature:( string opname )
GetObject	multi_object_pool.h	/^TObject * MultiObjectPool<TObject, ConstructorType, TObjectPool>::GetObject( string opname)$/;"	f	class:MultiObjectPool	signature:( string opname)
GetObject	object_pool.h	/^		virtual TObject * GetObject( );$/;"	p	class:ObjectPool	access:public	signature:( )
GetObject	object_pool.h	/^TObject * ObjectPool<TObject, ConstructorType>::GetObject( )$/;"	f	class:ObjectPool	signature:( )
GetReadOnlyShm	shm.c	/^char* GetReadOnlyShm(int iKey, int iSize)$/;"	f	signature:(int iKey, int iSize)
GetReadOnlyShm	shm.h	/^char* GetReadOnlyShm(int iKey, int iSize);$/;"	p	signature:(int iKey, int iSize)
GetResult	mongoc_json.cpp	/^char* CMongodb::GetResult()$/;"	f	class:CMongodb	signature:()
GetResult	mongoc_json.h	/^		char*   GetResult();	\/\/Ëé∑ÂèñÊü•ËØ¢ÁªìÊûú$/;"	p	class:CMongodb	access:public	signature:()
GetShm	shm.c	/^char* GetShm(int iKey, int iSize, int iFlag)$/;"	f	signature:(int iKey, int iSize, int iFlag)
GetShm	shm.h	/^char* GetShm(int iKey, int iSize, int iFlag);$/;"	p	signature:(int iKey, int iSize, int iFlag)
GetShm2	shm.c	/^int GetShm2(void **pstShm, int iShmID, int iSize, int iFlag)$/;"	f	signature:(void **pstShm, int iShmID, int iSize, int iFlag)
GetShm2	shm.h	/^int GetShm2(void **pstShm, int iShmID, int iSize, int iFlag);$/;"	p	signature:(void **pstShm, int iShmID, int iSize, int iFlag)
GetShm3	shm.c	/^int GetShm3(void **pstShm, int iShmID, int iSize, int iFlag)$/;"	f	signature:(void **pstShm, int iShmID, int iSize, int iFlag)
GetShm3	shm.h	/^int GetShm3(void **pstShm, int iShmID, int iSize, int iFlag);$/;"	p	signature:(void **pstShm, int iShmID, int iSize, int iFlag)
GetShm4	shm.c	/^char* GetShm4(int iKey, int iSize, int iFlag, int *piShmID)$/;"	f	signature:(int iKey, int iSize, int iFlag, int *piShmID)
GetShm4	shm.h	/^char* GetShm4(int iKey, int iSize, int iFlag, int *piShmID);$/;"	p	signature:(int iKey, int iSize, int iFlag, int *piShmID)
H	md5.cpp	/^inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
H	md5.h	/^  static inline uint4 H(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
HH	md5.cpp	/^inline void MD5::HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
HH	md5.h	/^  static inline void HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
HIGHFIRST	crypt_md5.c	13;"	d	file:
HIGHFIRST	crypt_md5.c	17;"	d	file:
HTTP_BOTH	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	e	enum:http_parser_type
HTTP_CHECKOUT	http.h	/^  , HTTP_CHECKOUT$/;"	e	enum:http_method
HTTP_CONNECT	http.h	/^  , HTTP_CONNECT$/;"	e	enum:http_method
HTTP_COPY	http.h	/^  , HTTP_COPY$/;"	e	enum:http_method
HTTP_DELETE	http.h	/^  { HTTP_DELETE = 0$/;"	e	enum:http_method
HTTP_ERRNO_GEN	http.h	177;"	d
HTTP_ERRNO_GEN	http.h	181;"	d
HTTP_ERRNO_MAP	http.h	/^  HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)$/;"	e	enum:http_errno
HTTP_ERRNO_MAP	http.h	133;"	d
HTTP_GET	http.h	/^  , HTTP_GET$/;"	e	enum:http_method
HTTP_HEAD	http.h	/^  , HTTP_HEAD$/;"	e	enum:http_method
HTTP_LOCK	http.h	/^  , HTTP_LOCK$/;"	e	enum:http_method
HTTP_MAX_HEADER_SIZE	http.h	58;"	d
HTTP_MERGE	http.h	/^  , HTTP_MERGE$/;"	e	enum:http_method
HTTP_MKACTIVITY	http.h	/^  , HTTP_MKACTIVITY$/;"	e	enum:http_method
HTTP_MKCOL	http.h	/^  , HTTP_MKCOL$/;"	e	enum:http_method
HTTP_MOVE	http.h	/^  , HTTP_MOVE$/;"	e	enum:http_method
HTTP_MSEARCH	http.h	/^  , HTTP_MSEARCH$/;"	e	enum:http_method
HTTP_NOTIFY	http.h	/^  , HTTP_NOTIFY$/;"	e	enum:http_method
HTTP_OPTIONS	http.h	/^  , HTTP_OPTIONS$/;"	e	enum:http_method
HTTP_PARSER_DEBUG	http.h	54;"	d
HTTP_PARSER_ERRNO	http.h	185;"	d
HTTP_PARSER_ERRNO_LINE	http.h	189;"	d
HTTP_PARSER_ERRNO_LINE	http.h	191;"	d
HTTP_PARSER_STRICT	http.h	47;"	d
HTTP_PARSER_VERSION_MAJOR	http.h	40;"	d
HTTP_PARSER_VERSION_MINOR	http.h	41;"	d
HTTP_PATCH	http.h	/^  , HTTP_PATCH$/;"	e	enum:http_method
HTTP_POST	http.h	/^  , HTTP_POST$/;"	e	enum:http_method
HTTP_PROPFIND	http.h	/^  , HTTP_PROPFIND$/;"	e	enum:http_method
HTTP_PROPPATCH	http.h	/^  , HTTP_PROPPATCH$/;"	e	enum:http_method
HTTP_PUT	http.h	/^  , HTTP_PUT$/;"	e	enum:http_method
HTTP_REPORT	http.h	/^  , HTTP_REPORT$/;"	e	enum:http_method
HTTP_REQUEST	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	e	enum:http_parser_type
HTTP_RESPONSE	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	e	enum:http_parser_type
HTTP_STRERROR_GEN	http.c	357;"	d	file:
HTTP_STRERROR_GEN	http.c	364;"	d	file:
HTTP_SUBSCRIBE	http.h	/^  , HTTP_SUBSCRIBE$/;"	e	enum:http_method
HTTP_TRACE	http.h	/^  , HTTP_TRACE$/;"	e	enum:http_method
HTTP_UNLOCK	http.h	/^  , HTTP_UNLOCK$/;"	e	enum:http_method
HTTP_UNSUBSCRIBE	http.h	/^  , HTTP_UNSUBSCRIBE$/;"	e	enum:http_method
I	md5.cpp	/^inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
I	md5.h	/^  static inline uint4 I(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
IF_LESS	pack.c	59;"	d	file:
II	md5.cpp	/^inline void MD5::II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
II	md5.h	/^  static inline void II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
IS_ALPHA	http.c	323;"	d	file:
IS_ALPHANUM	http.c	325;"	d	file:
IS_HOST_CHAR	http.c	329;"	d	file:
IS_HOST_CHAR	http.c	333;"	d	file:
IS_NUM	http.c	324;"	d	file:
IS_URL_CHAR	http.c	328;"	d	file:
IS_URL_CHAR	http.c	331;"	d	file:
IncreaseUsing	object_pool.h	/^		void IncreaseUsing( void )$/;"	f	class:ObjectPool	access:protected	signature:( void )
Init	RollLog.cpp	/^int CDayLog::Init(const string& sPreFix,const string& module)$/;"	f	class:CDayLog	signature:(const string& sPreFix,const string& module)
Init	RollLog.cpp	/^int CRollLog::Init(const string & sPreFix, const string & module, size_t maxsize, size_t maxnum)$/;"	f	class:CRollLog	signature:(const string & sPreFix, const string & module, size_t maxsize, size_t maxnum)
Init	RollLog.h	/^	int Init(const std::string& sPreFix,const std::string& module);$/;"	p	class:CDayLog	access:public	signature:(const std::string& sPreFix,const std::string& module)
Init	RollLog.h	/^	int Init(const std::string& sPreFix,const std::string& module,size_t maxsize,size_t maxnum=10);$/;"	p	class:CRollLog	access:public	signature:(const std::string& sPreFix,const std::string& module,size_t maxsize,size_t maxnum=10)
Init	file_lock.cpp	/^int CFileLock::Init(const char *pszFileName)$/;"	f	class:CFileLock	signature:(const char *pszFileName)
Init	file_lock.h	/^    int Init(const char *pszFileName);$/;"	p	class:CFileLock	access:public	signature:(const char *pszFileName)
Init	mongoc_json.cpp	/^int CMongodb::Init(const char* uri, const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* uri, const char* db, const char* collection)
Init	mongoc_json.h	/^		int 	Init(const char* uri, const char* db, const char* collection);	\/\/ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* uri, const char* db, const char* collection)
InitOnce	Attr_API.c	/^static void InitOnce(void)$/;"	f	file:	signature:(void)
InitOnce	Attr_API_Var.c	/^static void InitOnce(void)$/;"	f	file:	signature:(void)
InitShm	Attr_API.c	/^static void InitShm(void) $/;"	f	file:	signature:(void)
InitShm	Attr_API_Var.c	/^static void InitShm(void) $/;"	f	file:	signature:(void)
Initialize	multi_object_pool.h	/^		int Initialize( ConstructorType aConstructorType = ConstructorType() );$/;"	p	class:MultiObjectPool	access:public	signature:( ConstructorType aConstructorType = ConstructorType() )
Initialize	multi_object_pool.h	/^int MultiObjectPool<TObject, ConstructorType, TObjectPool>::Initialize( ConstructorType aConstructorType )$/;"	f	class:MultiObjectPool	signature:( ConstructorType aConstructorType )
Initialize	object_pool.h	/^		int Initialize( int aiPoolSize = DEFAULT_POOL_SIZE, int aiMaxConn = DEFAULT_POOL_SIZE, int aiReserveTimeout = 0, ConstructorType aConstructorType = ConstructorType());$/;"	p	class:ObjectPool	access:public	signature:( int aiPoolSize = DEFAULT_POOL_SIZE, int aiMaxConn = DEFAULT_POOL_SIZE, int aiReserveTimeout = 0, ConstructorType aConstructorType = ConstructorType())
Initialize	object_pool.h	/^int ObjectPool<TObject, ConstructorType>::Initialize( int aiPoolSize, int aiMaxConn, $/;"	f	class:ObjectPool	signature:( int aiPoolSize, int aiMaxConn, int aiReserveTimeout, ConstructorType aConstructorType )
Insert	mongoc_json.cpp	/^int CMongodb::Insert(string json)$/;"	f	class:CMongodb	signature:(string json)
Insert	mongoc_json.h	/^		int		Insert(string json);									\/\/ÊèíÂÖ•$/;"	p	class:CMongodb	access:public	signature:(string json)
Instance	mongoc_json.cpp	/^CMongodb& CMongodb::Instance()$/;"	f	class:CMongodb	signature:()
Instance	mongoc_json.h	/^		static CMongodb& Instance();	\/\/Âçï‰æãÊ®°Âºè ÈúÄË¶ÅInit$/;"	p	class:CMongodb	access:public	signature:()
Instance	singleton.h	/^		static T& Instance()$/;"	f	class:Singleton	access:public	signature:()
K	crypt_sha1.c	107;"	d	file:
K	crypt_sha1.c	111;"	d	file:
K	crypt_sha1.c	134;"	d	file:
K	crypt_sha1.c	138;"	d	file:
K	crypt_sha1.c	161;"	d	file:
K	crypt_sha1.c	165;"	d	file:
K	crypt_sha1.c	188;"	d	file:
K	crypt_sha1.c	84;"	d	file:
KEEP_ALIVE	http.c	95;"	d	file:
LDFLAGS	Makefile	/^LDFLAGS :=$/;"	m
LF	http.c	320;"	d	file:
LHs	crypt_3des.c	/^static uint32_t LHs[16] =$/;"	v	file:
LOG	RollLog.h	370;"	d
LOG_DEBUG	RollLog.h	374;"	d
LOG_ERROR	RollLog.h	373;"	d
LOG_INFO	RollLog.h	371;"	d
LOG_INIT	RollLog.h	364;"	d
LOG_LEVEL_CALL	object_pool.h	/^	LOG_LEVEL_CALL,$/;"	e	enum:__anon16
LOG_LEVEL_ERROR	object_pool.h	/^	LOG_LEVEL_ERROR = 1,$/;"	e	enum:__anon16
LOG_LEVEL_INFO	object_pool.h	/^	LOG_LEVEL_INFO,$/;"	e	enum:__anon16
LOG_LEVEL_RET	object_pool.h	/^	LOG_LEVEL_RET,$/;"	e	enum:__anon16
LOG_LEVEL_STAT	object_pool.h	/^	LOG_LEVEL_STAT,$/;"	e	enum:__anon16
LOG_LEVEL_TRACE	object_pool.h	/^	LOG_LEVEL_TRACE$/;"	e	enum:__anon16
LOG_LEVEL_WARN	object_pool.h	/^	LOG_LEVEL_WARN,$/;"	e	enum:__anon16
LOG_NORMAL	RollLog.h	372;"	d
LOG_ROUNDS	crypt_tea.cpp	24;"	d	file:
LOWER	http.c	321;"	d	file:
Lock	RollLog.cpp	/^bool CDayLog::Lock()$/;"	f	class:CDayLog	signature:()
Lock	RollLog.h	/^	bool Lock();$/;"	p	class:CDayLog	access:protected	signature:()
Lock	file_lock.cpp	/^int CFileLock::Lock(int iType, int iOffSet, int iSize, int iWaitFlag \/*= 1*\/)$/;"	f	class:CFileLock	signature:(int iType, int iOffSet, int iSize, int iWaitFlag )
Lock	file_lock.h	/^    int Lock(int iType, int iOffSet, int iSize, int iWaitFlag = 1);$/;"	p	class:CFileLock	access:public	signature:(int iType, int iOffSet, int iSize, int iWaitFlag = 1)
Log_Level	RollLog.h	/^	enum Log_Level{$/;"	g	class:CRollLog	access:public
MARK	http.c	67;"	d	file:
MAX_ATTEMPT_TIMES	Attr_API.c	33;"	d	file:
MAX_DEP_SHMEM_LEN	Attr_API_Str.c	23;"	d	file:
MAX_DEP_VALUE_LEN	Attr_API_Str.c	24;"	d	file:
MD5	md5.cpp	/^MD5::MD5()$/;"	f	class:MD5	signature:()
MD5	md5.cpp	/^MD5::MD5(const std::string &text)$/;"	f	class:MD5	signature:(const std::string &text)
MD5	md5.h	/^  MD5();$/;"	p	class:MD5	access:public	signature:()
MD5	md5.h	/^  MD5(const std::string& text);$/;"	p	class:MD5	access:public	signature:(const std::string& text)
MD5	md5.h	/^class MD5$/;"	c
MD5::F	md5.cpp	/^inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
MD5::F	md5.h	/^  static inline uint4 F(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
MD5::FF	md5.cpp	/^inline void MD5::FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::FF	md5.h	/^  static inline void FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::G	md5.cpp	/^inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
MD5::G	md5.h	/^  static inline uint4 G(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
MD5::GG	md5.cpp	/^inline void MD5::GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::GG	md5.h	/^  static inline void GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::H	md5.cpp	/^inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
MD5::H	md5.h	/^  static inline uint4 H(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
MD5::HH	md5.cpp	/^inline void MD5::HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::HH	md5.h	/^  static inline void HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::I	md5.cpp	/^inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) {$/;"	f	class:MD5	signature:(uint4 x, uint4 y, uint4 z)
MD5::I	md5.h	/^  static inline uint4 I(uint4 x, uint4 y, uint4 z);$/;"	p	class:MD5	access:private	signature:(uint4 x, uint4 y, uint4 z)
MD5::II	md5.cpp	/^inline void MD5::II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {$/;"	f	class:MD5	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::II	md5.h	/^  static inline void II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);$/;"	p	class:MD5	access:private	signature:(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac)
MD5::MD5	md5.cpp	/^MD5::MD5()$/;"	f	class:MD5	signature:()
MD5::MD5	md5.cpp	/^MD5::MD5(const std::string &text)$/;"	f	class:MD5	signature:(const std::string &text)
MD5::MD5	md5.h	/^  MD5();$/;"	p	class:MD5	access:public	signature:()
MD5::MD5	md5.h	/^  MD5(const std::string& text);$/;"	p	class:MD5	access:public	signature:(const std::string& text)
MD5::blocksize	md5.h	/^  enum {blocksize = 64}; \/\/ VC6 won't eat a const static int here$/;"	e	enum:MD5::__anon20
MD5::buffer	md5.h	/^  uint1 buffer[blocksize]; \/\/ bytes that didn't fit in last 64 byte chunk$/;"	m	class:MD5	access:private
MD5::count	md5.h	/^  uint4 count[2];   \/\/ 64bit counter for number of bits (lo, hi)$/;"	m	class:MD5	access:private
MD5::decode	md5.cpp	/^void MD5::decode(uint4 output[], const uint1 input[], size_type len)$/;"	f	class:MD5	signature:(uint4 output[], const uint1 input[], size_type len)
MD5::decode	md5.h	/^  static void decode(uint4 output[], const uint1 input[], size_type len);$/;"	p	class:MD5	access:private	signature:(uint4 output[], const uint1 input[], size_type len)
MD5::digest	md5.h	/^  uint1 digest[16]; \/\/ the result$/;"	m	class:MD5	access:private
MD5::encode	md5.cpp	/^void MD5::encode(uint1 output[], const uint4 input[], size_type len)$/;"	f	class:MD5	signature:(uint1 output[], const uint4 input[], size_type len)
MD5::encode	md5.h	/^  static void encode(uint1 output[], const uint4 input[], size_type len);$/;"	p	class:MD5	access:private	signature:(uint1 output[], const uint4 input[], size_type len)
MD5::finalize	md5.cpp	/^MD5& MD5::finalize()$/;"	f	class:MD5	signature:()
MD5::finalize	md5.h	/^  MD5& finalize();$/;"	p	class:MD5	access:public	signature:()
MD5::finalized	md5.h	/^  bool finalized;$/;"	m	class:MD5	access:private
MD5::hexdigest	md5.cpp	/^std::string MD5::hexdigest() const$/;"	f	class:MD5	signature:() const
MD5::hexdigest	md5.h	/^  std::string hexdigest() const;$/;"	p	class:MD5	access:public	signature:() const
MD5::init	md5.cpp	/^void MD5::init()$/;"	f	class:MD5	signature:()
MD5::init	md5.h	/^  void init();$/;"	p	class:MD5	access:private	signature:()
MD5::operator <<	md5.h	/^  friend std::ostream& operator<<(std::ostream&, MD5 md5);$/;"	p	class:MD5	access:friend	signature:(std::ostream&, MD5 md5)
MD5::rotate_left	md5.cpp	/^inline MD5::uint4 MD5::rotate_left(uint4 x, int n) {$/;"	f	class:MD5	signature:(uint4 x, int n)
MD5::rotate_left	md5.h	/^  static inline uint4 rotate_left(uint4 x, int n);$/;"	p	class:MD5	access:private	signature:(uint4 x, int n)
MD5::size_type	md5.h	/^  typedef unsigned int size_type; \/\/ must be 32bit$/;"	t	class:MD5	access:public
MD5::state	md5.h	/^  uint4 state[4];   \/\/ digest so far$/;"	m	class:MD5	access:private
MD5::transform	md5.cpp	/^void MD5::transform(const uint1 block[blocksize])$/;"	f	class:MD5	signature:(const uint1 block[blocksize])
MD5::transform	md5.h	/^  void transform(const uint1 block[blocksize]);$/;"	p	class:MD5	access:private	signature:(const uint1 block[blocksize])
MD5::uint1	md5.h	/^  typedef unsigned char uint1; \/\/  8bit$/;"	t	class:MD5	access:private
MD5::uint4	md5.h	/^  typedef unsigned int uint4;  \/\/ 32bit$/;"	t	class:MD5	access:private
MD5::update	md5.cpp	/^void MD5::update(const char input[], size_type length)$/;"	f	class:MD5	signature:(const char input[], size_type length)
MD5::update	md5.cpp	/^void MD5::update(const unsigned char input[], size_type length)$/;"	f	class:MD5	signature:(const unsigned char input[], size_type length)
MD5::update	md5.h	/^  void update(const char *buf, size_type length);$/;"	p	class:MD5	access:public	signature:(const char *buf, size_type length)
MD5::update	md5.h	/^  void update(const unsigned char *buf, size_type length);$/;"	p	class:MD5	access:public	signature:(const unsigned char *buf, size_type length)
MD5Bin2Hex	crypt_md5.c	/^void MD5Bin2Hex(uint8_t hex[32], const uint8_t bin[16])$/;"	f	signature:(uint8_t hex[32], const uint8_t bin[16])
MD5Bin2Hex	crypt_md5.h	/^void MD5Bin2Hex(uint8_t hex[32], const uint8_t bin[16]);$/;"	p	signature:(uint8_t hex[32], const uint8_t bin[16])
MD5Context	crypt_md5.h	/^struct MD5Context {$/;"	s
MD5Context::bits	crypt_md5.h	/^        uint32_t bits[2];$/;"	m	struct:MD5Context	access:public
MD5Context::buf	crypt_md5.h	/^        uint32_t buf[4];$/;"	m	struct:MD5Context	access:public
MD5Context::in	crypt_md5.h	/^        unsigned char in[64];$/;"	m	struct:MD5Context	access:public
MD5Final	crypt_md5.c	/^void MD5Final(uint8_t digest[16], struct MD5Context *ctx)$/;"	f	signature:(uint8_t digest[16], struct MD5Context *ctx)
MD5Final	crypt_md5.h	/^void MD5Final(uint8_t digest[16], struct MD5Context *ctx);$/;"	p	signature:(uint8_t digest[16], struct MD5Context *ctx)
MD5Hex2Bin	crypt_md5.c	/^int MD5Hex2Bin(uint8_t bin[16], const uint8_t hex[32])$/;"	f	signature:(uint8_t bin[16], const uint8_t hex[32])
MD5Hex2Bin	crypt_md5.h	/^int MD5Hex2Bin(uint8_t bin[16], const uint8_t hex[32]);$/;"	p	signature:(uint8_t bin[16], const uint8_t hex[32])
MD5Init	crypt_md5.c	/^void MD5Init(struct MD5Context *ctx)$/;"	f	signature:(struct MD5Context *ctx)
MD5Init	crypt_md5.h	/^void MD5Init(struct MD5Context *ctx);$/;"	p	signature:(struct MD5Context *ctx)
MD5STEP	crypt_md5.c	157;"	d	file:
MD5Transform	crypt_md5.c	/^void MD5Transform(uint32_t buf[4], uint32_t in[16])$/;"	f	signature:(uint32_t buf[4], uint32_t in[16])
MD5Transform	crypt_md5.c	/^void MD5Transform(uint32_t buf[4], uint32_t in[16]);$/;"	p	file:	signature:(uint32_t buf[4], uint32_t in[16])
MD5Update	crypt_md5.c	/^void MD5Update(struct MD5Context *ctx, const uint8_t *buf, uint32_t len)$/;"	f	signature:(struct MD5Context *ctx, const uint8_t *buf, uint32_t len)
MD5Update	crypt_md5.h	/^void MD5Update(struct MD5Context *ctx, const uint8_t *buf, uint32_t len);$/;"	p	signature:(struct MD5Context *ctx, const uint8_t *buf, uint32_t len)
MD5_CTX	crypt_md5.h	/^typedef struct MD5Context MD5_CTX;$/;"	t	typeref:struct:MD5Context
MD5_H	md5.h	34;"	d
MIN	http.c	38;"	d	file:
MultiObjectPool	multi_object_pool.h	/^		MultiObjectPool( );$/;"	p	class:MultiObjectPool	access:public	signature:( )
MultiObjectPool	multi_object_pool.h	/^	MultiObjectPool<TObject, ConstructorType, TObjectPool>::MultiObjectPool( )$/;"	f	class:MultiObjectPool	signature:( )
MultiObjectPool	multi_object_pool.h	/^class MultiObjectPool $/;"	c
MultiObjectPool::AddObjectPool	multi_object_pool.h	/^		void AddObjectPool( string opname );$/;"	p	class:MultiObjectPool	access:protected	signature:( string opname )
MultiObjectPool::AddObjectPool	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::AddObjectPool( string opname )$/;"	f	class:MultiObjectPool	signature:( string opname )
MultiObjectPool::FreeObject	multi_object_pool.h	/^		void FreeObject( TObject * cpoTObject );$/;"	p	class:MultiObjectPool	access:public	signature:( TObject * cpoTObject )
MultiObjectPool::FreeObject	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::FreeObject( TObject * apoTObject )$/;"	f	class:MultiObjectPool	signature:( TObject * apoTObject )
MultiObjectPool::GetObject	multi_object_pool.h	/^		TObject * GetObject( string opname );$/;"	p	class:MultiObjectPool	access:public	signature:( string opname )
MultiObjectPool::GetObject	multi_object_pool.h	/^TObject * MultiObjectPool<TObject, ConstructorType, TObjectPool>::GetObject( string opname)$/;"	f	class:MultiObjectPool	signature:( string opname)
MultiObjectPool::Initialize	multi_object_pool.h	/^		int Initialize( ConstructorType aConstructorType = ConstructorType() );$/;"	p	class:MultiObjectPool	access:public	signature:( ConstructorType aConstructorType = ConstructorType() )
MultiObjectPool::Initialize	multi_object_pool.h	/^int MultiObjectPool<TObject, ConstructorType, TObjectPool>::Initialize( ConstructorType aConstructorType )$/;"	f	class:MultiObjectPool	signature:( ConstructorType aConstructorType )
MultiObjectPool::MultiObjectPool	multi_object_pool.h	/^		MultiObjectPool( );$/;"	p	class:MultiObjectPool	access:public	signature:( )
MultiObjectPool::MultiObjectPool	multi_object_pool.h	/^	MultiObjectPool<TObject, ConstructorType, TObjectPool>::MultiObjectPool( )$/;"	f	class:MultiObjectPool	signature:( )
MultiObjectPool::ReleaseObject	multi_object_pool.h	/^		void ReleaseObject( TObject * cpoTObject );$/;"	p	class:MultiObjectPool	access:public	signature:( TObject * cpoTObject )
MultiObjectPool::ReleaseObject	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::ReleaseObject( TObject * apoTObject )$/;"	f	class:MultiObjectPool	signature:( TObject * apoTObject )
MultiObjectPool::RemoveObjectPool	multi_object_pool.h	/^		void RemoveObjectPool( string opname );$/;"	p	class:MultiObjectPool	access:protected	signature:( string opname )
MultiObjectPool::RemoveObjectPool	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::RemoveObjectPool( string opname)$/;"	f	class:MultiObjectPool	signature:( string opname)
MultiObjectPool::coCheckOutConnection	multi_object_pool.h	/^		map<size_t,stObjectOfGroup> coCheckOutConnection; \/\/ size_tºÊ»›64Œªª˙∆˜£¨≥§∂»ø…“‘»›ƒ…÷∏’Î$/;"	m	class:MultiObjectPool	access:private
MultiObjectPool::coConnectionGroup	multi_object_pool.h	/^		map<string,TObjectPool *> coConnectionGroup;$/;"	m	class:MultiObjectPool	access:private
MultiObjectPool::coConstructorType	multi_object_pool.h	/^		ConstructorType coConstructorType;$/;"	m	class:MultiObjectPool	access:private
MultiObjectPool::ctCheckOutMutex	multi_object_pool.h	/^		pthread_mutex_t ctCheckOutMutex;$/;"	m	class:MultiObjectPool	access:private
MultiObjectPool::ctGroupMutex	multi_object_pool.h	/^		pthread_mutex_t ctGroupMutex;$/;"	m	class:MultiObjectPool	access:private
MultiObjectPool::stObjectOfGroup	multi_object_pool.h	/^		struct stObjectOfGroup {$/;"	s	class:MultiObjectPool	access:public
MultiObjectPool::stObjectOfGroup::cpoTObject	multi_object_pool.h	/^			TObject * cpoTObject;$/;"	m	struct:MultiObjectPool::stObjectOfGroup	access:public
MultiObjectPool::stObjectOfGroup::csName	multi_object_pool.h	/^			string csName;$/;"	m	struct:MultiObjectPool::stObjectOfGroup	access:public
MultiObjectPool::~MultiObjectPool	multi_object_pool.h	/^		virtual ~MultiObjectPool( );$/;"	p	class:MultiObjectPool	access:public	signature:( )
MultiObjectPool::~MultiObjectPool	multi_object_pool.h	/^MultiObjectPool<TObject, ConstructorType, TObjectPool>::~MultiObjectPool( )$/;"	f	class:MultiObjectPool	signature:( )
MyMultiMyObjectPoolConstructor	objpools/objectpool/examples/test_multi_object_pool.cpp	/^struct MyMultiMyObjectPoolConstructor$/;"	s	file:
MyMultiMyObjectPoolConstructor::operator ()	objpools/objectpool/examples/test_multi_object_pool.cpp	/^	MyObjectPool* operator () ( std::string gname)$/;"	f	struct:MyMultiMyObjectPoolConstructor	access:public	signature:( std::string gname)
MyObject	objpools/objectpool/examples/test_multi_object_pool.cpp	/^class MyObject$/;"	c	file:
MyObject	objpools/test_object_pool.cpp	/^class MyObject$/;"	c	file:
MyObject::attrA	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int attrA;$/;"	m	class:MyObject	file:	access:private
MyObject::attrA	objpools/test_object_pool.cpp	/^		int attrA;$/;"	m	class:MyObject	file:	access:private
MyObject::attrB	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int attrB;$/;"	m	class:MyObject	file:	access:private
MyObject::attrB	objpools/test_object_pool.cpp	/^		int attrB;$/;"	m	class:MyObject	file:	access:private
MyObject::init	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int init() {attrA = 5, attrB = 10; return 0;};$/;"	f	class:MyObject	access:public	signature:()
MyObject::init	objpools/test_object_pool.cpp	/^		int init() {attrA = 5, attrB = 10; return 0;};$/;"	f	class:MyObject	access:public	signature:()
MyObject::sum	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int sum() {return attrA+attrB;};$/;"	f	class:MyObject	access:public	signature:()
MyObject::sum	objpools/test_object_pool.cpp	/^		int sum() {return attrA+attrB;};$/;"	f	class:MyObject	access:public	signature:()
MyObjectPool	objpools/objectpool/examples/test_multi_object_pool.cpp	/^typedef ObjectPool<MyObject, MyObjectPoolConstructor> MyObjectPool;$/;"	t	file:
MyObjectPoolConstructor	objpools/objectpool/examples/test_multi_object_pool.cpp	/^struct MyObjectPoolConstructor$/;"	s	file:
MyObjectPoolConstructor	objpools/test_object_pool.cpp	/^struct MyObjectPoolConstructor$/;"	s	file:
MyObjectPoolConstructor::operator ()	objpools/objectpool/examples/test_multi_object_pool.cpp	/^	MyObject* operator()()$/;"	f	struct:MyObjectPoolConstructor	access:public	signature:()
MyObjectPoolConstructor::operator ()	objpools/test_object_pool.cpp	/^	MyObject* operator()()$/;"	f	struct:MyObjectPoolConstructor	access:public	signature:()
NEG_RET	pack.c	64;"	d	file:
NEG_RET_LN	pack.h	242;"	d
NEW_MESSAGE	http.c	349;"	d	file:
NEW_MESSAGE	http.c	352;"	d	file:
NORMAL_LOG	RollLog.h	/^		NORMAL_LOG = 3, $/;"	e	enum:CRollLog::Log_Level
NO_LOG	RollLog.h	/^		NO_LOG = 1,  $/;"	e	enum:CRollLog::Log_Level
NO_SWAP	pack.c	132;"	d	file:
Next	mongoc_json.cpp	/^bool CMongodb::Next()$/;"	f	class:CMongodb	signature:()
Next	mongoc_json.h	/^		bool	Next();			\/\/ÁßªÂä®Ê∏∏Ê†áÂà∞‰∏ã‰∏ÄÊù°$/;"	p	class:CMongodb	access:public	signature:()
OBJCPP	Makefile	/^OBJCPP=  conf.o crypto.o crypt_tea.o md5.o mongoc_json.o RollLog.o convert.o util.o $/;"	m
OBJS	Makefile	/^OBJS    := $(patsubst %.c,%.o,$(patsubst %.cpp,%.o,$(SOURCE)))$/;"	m
OBJS	Makefile	/^OBJS=$(OBJSC) $(OBJCPP)$/;"	m
OBJSC	Makefile	/^OBJSC= Attr_API.o Attr_API_Str.o Attr_API_Var.o base64.o crc32.o crypt_3des.o  crypt_md5.o crypt_sha1.o crypt_sha256.o debug.o fifo.o http.o pack.o py.o  shm.o utf8.o wry.o ut_str.o$/;"	m
OI_GetShm	comm_def.h	/^static char* OI_GetShm(int iKey, int iSize, int iFlag) $/;"	f	signature:(int iKey, int iSize, int iFlag)
OI_GetShm2	comm_def.h	/^static int OI_GetShm2(void **pstShm, int iKey, int iSize, int iFlag) $/;"	f	signature:(void **pstShm, int iKey, int iSize, int iFlag)
ObjectNode	object_pool.h	/^		struct ObjectNode{$/;"	s	class:ObjectPool	access:private
ObjectPool	object_pool.h	/^		ObjectPool( );$/;"	p	class:ObjectPool	access:public	signature:( )
ObjectPool	object_pool.h	/^		ObjectPool( int iPoolSize, int iMaxObject, int iReserveTimeout = 0 );$/;"	p	class:ObjectPool	access:public	signature:( int iPoolSize, int iMaxObject, int iReserveTimeout = 0 )
ObjectPool	object_pool.h	/^ObjectPool<TObject, ConstructorType>::ObjectPool( )$/;"	f	class:ObjectPool	signature:( )
ObjectPool	object_pool.h	/^ObjectPool<TObject, ConstructorType>::ObjectPool( int aiPoolSize, int aiMaxConn,$/;"	f	class:ObjectPool	signature:( int aiPoolSize, int aiMaxConn, int aiReserveTimeout )
ObjectPool	object_pool.h	/^class ObjectPool $/;"	c
ObjectPool::CreateObject	object_pool.h	/^		virtual TObject * CreateObject( );$/;"	p	class:ObjectPool	access:private	signature:( )
ObjectPool::CreateObject	object_pool.h	/^TObject * ObjectPool<TObject, ConstructorType>::CreateObject( )$/;"	f	class:ObjectPool	signature:( )
ObjectPool::DecreaseUsing	object_pool.h	/^		void DecreaseUsing( void )$/;"	f	class:ObjectPool	access:protected	signature:( void )
ObjectPool::FreeObject	object_pool.h	/^		virtual void FreeObject( TObject * apoTConn );$/;"	p	class:ObjectPool	access:public	signature:( TObject * apoTConn )
ObjectPool::FreeObject	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::FreeObject( TObject * apoTConn )$/;"	f	class:ObjectPool	signature:( TObject * apoTConn )
ObjectPool::FreeSize	object_pool.h	/^		int FreeSize( );$/;"	p	class:ObjectPool	access:public	signature:( )
ObjectPool::FreeSize	object_pool.h	/^int ObjectPool<TObject, ConstructorType>::FreeSize( void )$/;"	f	class:ObjectPool	signature:( void )
ObjectPool::GetObject	object_pool.h	/^		virtual TObject * GetObject( );$/;"	p	class:ObjectPool	access:public	signature:( )
ObjectPool::GetObject	object_pool.h	/^TObject * ObjectPool<TObject, ConstructorType>::GetObject( )$/;"	f	class:ObjectPool	signature:( )
ObjectPool::IncreaseUsing	object_pool.h	/^		void IncreaseUsing( void )$/;"	f	class:ObjectPool	access:protected	signature:( void )
ObjectPool::Initialize	object_pool.h	/^		int Initialize( int aiPoolSize = DEFAULT_POOL_SIZE, int aiMaxConn = DEFAULT_POOL_SIZE, int aiReserveTimeout = 0, ConstructorType aConstructorType = ConstructorType());$/;"	p	class:ObjectPool	access:public	signature:( int aiPoolSize = DEFAULT_POOL_SIZE, int aiMaxConn = DEFAULT_POOL_SIZE, int aiReserveTimeout = 0, ConstructorType aConstructorType = ConstructorType())
ObjectPool::Initialize	object_pool.h	/^int ObjectPool<TObject, ConstructorType>::Initialize( int aiPoolSize, int aiMaxConn, $/;"	f	class:ObjectPool	signature:( int aiPoolSize, int aiMaxConn, int aiReserveTimeout, ConstructorType aConstructorType )
ObjectPool::ObjectNode	object_pool.h	/^		struct ObjectNode{$/;"	s	class:ObjectPool	access:private
ObjectPool::ObjectNode::cpObject	object_pool.h	/^			TObject*	cpObject;$/;"	m	struct:ObjectPool::ObjectNode	access:public
ObjectPool::ObjectNode::ctCreateTime	object_pool.h	/^			time_t	ctCreateTime;$/;"	m	struct:ObjectPool::ObjectNode	access:public
ObjectPool::ObjectNode::ctVisitTime	object_pool.h	/^			time_t	ctVisitTime;$/;"	m	struct:ObjectPool::ObjectNode	access:public
ObjectPool::ObjectPool	object_pool.h	/^		ObjectPool( );$/;"	p	class:ObjectPool	access:public	signature:( )
ObjectPool::ObjectPool	object_pool.h	/^		ObjectPool( int iPoolSize, int iMaxObject, int iReserveTimeout = 0 );$/;"	p	class:ObjectPool	access:public	signature:( int iPoolSize, int iMaxObject, int iReserveTimeout = 0 )
ObjectPool::ObjectPool	object_pool.h	/^ObjectPool<TObject, ConstructorType>::ObjectPool( )$/;"	f	class:ObjectPool	signature:( )
ObjectPool::ObjectPool	object_pool.h	/^ObjectPool<TObject, ConstructorType>::ObjectPool( int aiPoolSize, int aiMaxConn,$/;"	f	class:ObjectPool	signature:( int aiPoolSize, int aiMaxConn, int aiReserveTimeout )
ObjectPool::PrintStatistic	object_pool.h	/^		void PrintStatistic( void );$/;"	p	class:ObjectPool	access:public	signature:( void )
ObjectPool::PrintStatistic	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::PrintStatistic( void )$/;"	f	class:ObjectPool	signature:( void )
ObjectPool::ReleaseAll	object_pool.h	/^		virtual void ReleaseAll( );$/;"	p	class:ObjectPool	access:protected	signature:( )
ObjectPool::ReleaseAll	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::ReleaseAll( )$/;"	f	class:ObjectPool	signature:( )
ObjectPool::ReleaseObject	object_pool.h	/^		virtual void ReleaseObject( TObject * apoConn );$/;"	p	class:ObjectPool	access:public	signature:( TObject * apoConn )
ObjectPool::ReleaseObject	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::ReleaseObject( TObject * apoConn )$/;"	f	class:ObjectPool	signature:( TObject * apoConn )
ObjectPool::SaveObject	object_pool.h	/^		void SaveObject( ObjectNode &aoNode ){$/;"	f	class:ObjectPool	access:private	signature:( ObjectNode &aoNode )
ObjectPool::ciCachePoolSize	object_pool.h	/^		int ciCachePoolSize;$/;"	m	class:ObjectPool	access:private
ObjectPool::ciMaxConnection	object_pool.h	/^		int ciMaxConnection;$/;"	m	class:ObjectPool	access:private
ObjectPool::ciReserveTimeout	object_pool.h	/^		int ciReserveTimeout;$/;"	m	class:ObjectPool	access:private
ObjectPool::ciUsingCount	object_pool.h	/^		int ciUsingCount;$/;"	m	class:ObjectPool	access:private
ObjectPool::coCheckoutConnection	object_pool.h	/^		map< size_t, ObjectNode > coCheckoutConnection; \/\/ size_tºÊ»›64Œªª˙∆˜£¨≥§∂»ø…“‘»›ƒ…÷∏’Î$/;"	m	class:ObjectPool	access:private
ObjectPool::coConstructorType	object_pool.h	/^		ConstructorType coConstructorType;$/;"	m	class:ObjectPool	access:private
ObjectPool::coFreeConnections	object_pool.h	/^		deque<ObjectNode> coFreeConnections;$/;"	m	class:ObjectPool	access:private
ObjectPool::ctCheckoutMutex	object_pool.h	/^		pthread_mutex_t	ctCheckoutMutex;$/;"	m	class:ObjectPool	access:private
ObjectPool::ctFreeMutex	object_pool.h	/^		pthread_mutex_t ctFreeMutex;$/;"	m	class:ObjectPool	access:private
ObjectPool::ctLock	object_pool.h	/^		pthread_mutex_t ctLock;$/;"	m	class:ObjectPool	access:private
ObjectPool::~ObjectPool	object_pool.h	/^		virtual ~ObjectPool( );$/;"	p	class:ObjectPool	access:public	signature:( )
ObjectPool::~ObjectPool	object_pool.h	/^ObjectPool<TObject, ConstructorType>::~ObjectPool( )$/;"	f	class:ObjectPool	signature:( )
P	crypt_sha1.c	72;"	d	file:
P	crypt_sha256.c	82;"	d	file:
PACKF_BE_CUT_OFF	pack.h	/^    PACKF_BE_CUT_OFF    = -4,$/;"	e	enum:__anon2
PACKF_EXPECT_FORMAT	pack.h	/^    PACKF_EXPECT_FORMAT = -3,$/;"	e	enum:__anon2
PACKF_NOT_FORMAT	pack.h	/^    PACKF_NOT_FORMAT    = -2,$/;"	e	enum:__anon2
PACKF_NOT_MATCH	pack.h	/^    PACKF_NOT_MATCH     = -3,$/;"	e	enum:__anon2
PACKF_NULL_POINTER	pack.h	/^    PACKF_NULL_POINTER  = -5,$/;"	e	enum:__anon2
PACKF_OUT_OF_BUF	pack.h	/^    PACKF_OUT_OF_BUF    = -1,$/;"	e	enum:__anon2
PACK_PASS	pack.h	257;"	d
PARSING_HEADER	http.c	288;"	d	file:
PRINT_ERR_FMT	pack.c	42;"	d	file:
PROXY_CONNECTION	http.c	89;"	d	file:
PUT_UINT32	crypt_3des.c	199;"	d	file:
PUT_UINT32	crypt_sha1.c	22;"	d	file:
PUT_uint32_t	crypt_sha256.c	19;"	d	file:
PrintStatistic	object_pool.h	/^		void PrintStatistic( void );$/;"	p	class:ObjectPool	access:public	signature:( void )
PrintStatistic	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::PrintStatistic( void )$/;"	f	class:ObjectPool	signature:( void )
Query	mongoc_json.cpp	/^int  CMongodb::Query(string json, uint32_t skip, uint32_t limit)$/;"	f	class:CMongodb	signature:(string json, uint32_t skip, uint32_t limit)
Query	mongoc_json.h	/^		int		Query(string json, uint32_t skip=0, uint32_t limit=0); 	\/\/Êü•ËØ¢$/;"	p	class:CMongodb	access:public	signature:(string json, uint32_t skip=0, uint32_t limit=0)
R	crypt_sha1.c	65;"	d	file:
R	crypt_sha256.c	76;"	d	file:
RDTSC	optimized_time.h	32;"	d
RDTSCP	optimized_time.h	33;"	d
REGET_TIME_US	optimized_time.h	84;"	d
RHs	crypt_3des.c	/^static uint32_t RHs[16] =$/;"	v	file:
ROTR	crypt_sha256.c	65;"	d	file:
ROUNDS	crypt_tea.cpp	23;"	d	file:
ReInit	mongoc_json.cpp	/^int CMongodb::ReInit(const char* collection)$/;"	f	class:CMongodb	signature:(const char* collection)
ReInit	mongoc_json.cpp	/^int CMongodb::ReInit(const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* db, const char* collection)
ReInit	mongoc_json.cpp	/^int CMongodb::ReInit(const char* uri, const char* db, const char* collection)$/;"	f	class:CMongodb	signature:(const char* uri, const char* db, const char* collection)
ReInit	mongoc_json.h	/^		int 	ReInit(const char* collection);					\/\/ÈáçÊñ∞ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* collection)
ReInit	mongoc_json.h	/^		int 	ReInit(const char* db, const char* collection);					\/\/ÈáçÊñ∞ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* db, const char* collection)
ReInit	mongoc_json.h	/^		int 	ReInit(const char* uri, const char* db, const char* collection);\/\/ÈáçÊñ∞ÂàùÂßãÂåñ$/;"	p	class:CMongodb	access:public	signature:(const char* uri, const char* db, const char* collection)
Release	mongoc_json.cpp	/^void CMongodb::Release()$/;"	f	class:CMongodb	signature:()
Release	mongoc_json.h	/^		void	Release();		\/\/ÈáäÊîæÊú¨Ê¨°Êü•ËØ¢Áõ∏ÂÖ≥ÂÜÖÂ≠ò$/;"	p	class:CMongodb	access:public	signature:()
ReleaseAll	object_pool.h	/^		virtual void ReleaseAll( );$/;"	p	class:ObjectPool	access:protected	signature:( )
ReleaseAll	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::ReleaseAll( )$/;"	f	class:ObjectPool	signature:( )
ReleaseObject	multi_object_pool.h	/^		void ReleaseObject( TObject * cpoTObject );$/;"	p	class:MultiObjectPool	access:public	signature:( TObject * cpoTObject )
ReleaseObject	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::ReleaseObject( TObject * apoTObject )$/;"	f	class:MultiObjectPool	signature:( TObject * apoTObject )
ReleaseObject	object_pool.h	/^		virtual void ReleaseObject( TObject * apoConn );$/;"	p	class:ObjectPool	access:public	signature:( TObject * apoConn )
ReleaseObject	object_pool.h	/^void ObjectPool<TObject, ConstructorType>::ReleaseObject( TObject * apoConn )$/;"	f	class:ObjectPool	signature:( TObject * apoConn )
RemoveObjectPool	multi_object_pool.h	/^		void RemoveObjectPool( string opname );$/;"	p	class:MultiObjectPool	access:protected	signature:( string opname )
RemoveObjectPool	multi_object_pool.h	/^void MultiObjectPool<TObject, ConstructorType, TObjectPool>::RemoveObjectPool( string opname)$/;"	f	class:MultiObjectPool	signature:( string opname)
S	crypt_sha1.c	63;"	d	file:
S0	crypt_sha256.c	67;"	d	file:
S1	crypt_sha256.c	68;"	d	file:
S11	md5.cpp	41;"	d	file:
S12	md5.cpp	42;"	d	file:
S13	md5.cpp	43;"	d	file:
S14	md5.cpp	44;"	d	file:
S2	crypt_sha256.c	70;"	d	file:
S21	md5.cpp	45;"	d	file:
S22	md5.cpp	46;"	d	file:
S23	md5.cpp	47;"	d	file:
S24	md5.cpp	48;"	d	file:
S3	crypt_sha256.c	71;"	d	file:
S31	md5.cpp	49;"	d	file:
S32	md5.cpp	50;"	d	file:
S33	md5.cpp	51;"	d	file:
S34	md5.cpp	52;"	d	file:
S41	md5.cpp	53;"	d	file:
S42	md5.cpp	54;"	d	file:
S43	md5.cpp	55;"	d	file:
S44	md5.cpp	56;"	d	file:
SALT_LEN	crypt_tea.cpp	98;"	d	file:
SB1	crypt_3des.c	/^uint32_t SB1[64] =$/;"	v
SB2	crypt_3des.c	/^static uint32_t SB2[64] =$/;"	v	file:
SB3	crypt_3des.c	/^static uint32_t SB3[64] =$/;"	v	file:
SB4	crypt_3des.c	/^static uint32_t SB4[64] =$/;"	v	file:
SB5	crypt_3des.c	/^static uint32_t SB5[64] =$/;"	v	file:
SB6	crypt_3des.c	/^static uint32_t SB6[64] =$/;"	v	file:
SB7	crypt_3des.c	/^static uint32_t SB7[64] =$/;"	v	file:
SB8	crypt_3des.c	/^static uint32_t SB8[64] =$/;"	v	file:
SET_ERRNO	http.c	43;"	d	file:
SET_ERRNO	http.c	49;"	d	file:
SET_LEN	pack.c	535;"	d	file:
SET_LV	pack.c	238;"	d	file:
SET_LV_LEN	pack.c	231;"	d	file:
SHR	crypt_sha256.c	64;"	d	file:
SIZE_IP_ADDR	object_pool.h	28;"	d
SLIM_IP_INDEX_SIZE	wry.c	12;"	d	file:
SOURCE	Makefile	/^SOURCE  := $(wildcard *.c *.cpp)$/;"	m
SPINLOCK_INITIALIZER	spin_lock.h	24;"	d
STRICT_CHECK	http.c	342;"	d	file:
STRICT_CHECK	http.c	351;"	d	file:
STR_OF	pack.h	253;"	d
SUCCESS	file_lock.h	/^    const static int SUCCESS = 0;$/;"	m	class:CFileLock	access:public
SVarNode	Attr_API_Var.c	/^} SVarNode;$/;"	t	typeref:struct:__anon9	file:
SaveObject	object_pool.h	/^		void SaveObject( ObjectNode &aoNode ){$/;"	f	class:ObjectPool	access:private	signature:( ObjectNode &aoNode )
Singleton	singleton.h	/^class Singleton$/;"	c
Singleton::Instance	singleton.h	/^		static T& Instance()$/;"	f	class:Singleton	access:public	signature:()
Singleton::p	singleton.h	/^		static T* p;$/;"	m	class:Singleton	access:private
Singleton::p	singleton.h	/^T* Singleton<T>::p = new T;$/;"	m	class:Singleton
SyncRequest	sync_request.h	/^		SyncRequest()$/;"	f	class:SyncRequest	access:public	signature:()
SyncRequest	sync_request.h	/^class SyncRequest$/;"	c
SyncRequest::SyncRequest	sync_request.h	/^		SyncRequest()$/;"	f	class:SyncRequest	access:public	signature:()
SyncRequest::_mutex	sync_request.h	/^	pthread_mutex_t _mutex;$/;"	m	class:SyncRequest	access:public
SyncRequest::get	sync_request.h	/^		int get(T t)$/;"	f	class:SyncRequest	access:public	signature:(T t)
SyncRequest::set	sync_request.h	/^		void set(T t, int value)$/;"	f	class:SyncRequest	access:public	signature:(T t, int value)
SyncRequest::syncrequest	sync_request.h	/^	map<T, int> syncrequest;$/;"	m	class:SyncRequest	access:public
TARGET	Makefile	/^TARGET=libutil.a$/;"	m
TARGET	objpools/Makefile	/^TARGET  := test$/;"	m
TARGET	test/Makefile	/^TARGET  := test$/;"	m
TIME_ADD_US	optimized_time.h	88;"	d
TOKEN	http.c	322;"	d	file:
TRANSFER_ENCODING	http.c	92;"	d	file:
TT	test/test.cpp	/^class TT$/;"	c	file:
TT::out	test/test.cpp	/^		void out(){$/;"	f	class:TT	access:public	signature:()
TX_HOOK_LOG_OUTPUT	object_pool.h	43;"	d
TX_LOG	object_pool.h	63;"	d
TX_LOG_CALL	object_pool.h	68;"	d
TX_LOG_ERROR	object_pool.h	64;"	d
TX_LOG_INFO	object_pool.h	66;"	d
TX_LOG_RETN	object_pool.h	69;"	d
TX_LOG_STAT	object_pool.h	67;"	d
TX_LOG_TRACE	object_pool.h	70;"	d
TX_LOG_WARN	object_pool.h	65;"	d
TeaDecryptECB	crypt_tea.cpp	/^inline void TeaDecryptECB(const uint8_t *pInBuf, const uint8_t *pKey, uint8_t *pOutBuf)$/;"	f	signature:(const uint8_t *pInBuf, const uint8_t *pKey, uint8_t *pOutBuf)
TeaEncryptECB	crypt_tea.cpp	/^inline void TeaEncryptECB(const uint8_t *pInBuf, const uint8_t *pKey, uint8_t *pOutBuf)$/;"	f	signature:(const uint8_t *pInBuf, const uint8_t *pKey, uint8_t *pOutBuf)
Time	test/test.cpp	/^		Time(){$/;"	f	class:Time	access:public	signature:()
Time	test/test.cpp	/^class Time$/;"	c	file:
Time::Time	test/test.cpp	/^		Time(){$/;"	f	class:Time	access:public	signature:()
Time::_timer	test/test.cpp	/^		nw_timer _timer;$/;"	m	class:Time	file:	access:private
Time::a	test/test.cpp	/^		int a;$/;"	m	class:Time	file:	access:private
Time::callback	test/test.cpp	/^		void callback()$/;"	f	class:Time	access:public	signature:()
Time::callback_static	test/test.cpp	/^		static void callback_static()$/;"	f	class:Time	access:public	signature:()
Time::init	test/test.cpp	/^		void init()$/;"	f	class:Time	access:public	signature:()
Trim	conf.cpp	/^void  Trim(char *szString)$/;"	f	signature:(char *szString)
TrimStr	conf.cpp	/^void TrimStr(string&  in)$/;"	f	signature:(string& in)
ULONG	Attr_API_Str.c	140;"	d	file:
UPDATE_METHOD_PTR	Attr_API.c	/^typedef int (*UPDATE_METHOD_PTR)(volatile AGENT_ATTR_NODE*, uint32_t, uint32_t, uint32_t*);$/;"	t	file:
UPDATE_METHOD_PTR	Attr_API_Var.c	/^typedef int (*UPDATE_METHOD_PTR)(volatile SVarNode*, int, uint32_t, uint32_t*);$/;"	t	file:
UPGRADE	http.c	93;"	d	file:
UTF82GBK	convert.cpp	/^int UTF82GBK(char* src, int inlen, char* dest, int outlen)$/;"	f	signature:(char* src, int inlen, char* dest, int outlen)
UTIL_BASE64_C_	base64.c	10;"	d	file:
UTIL_BASE64_H_	base64.h	9;"	d
UTIL_CONFIG_H_	conf.h	9;"	d
UTIL_CRYPT_3DES_H_	crypt_3des.h	30;"	d
UTIL_CRYPT_MD5_H_	crypt_md5.h	31;"	d
UTIL_CRYPT_SHA1_H_	crypt_sha1.h	30;"	d
UTIL_CRYPT_SHA256_H_	crypt_sha256.h	30;"	d
UTIL_CRYPT_TEA_H__	crypt_tea.h	10;"	d
UT_BYTE_H_	byte.h	10;"	d
UT_CRYPTO_H_	crypto.h	10;"	d
UT_FIFO_H_	fifo.h	10;"	d
UT_HTTP_H_	http.h	31;"	d
UT_MYSQL_H_	ut_mysql.h	9;"	d
UT_PY_H_	py.h	13;"	d
UT_STR_H_	ut_str.h	10;"	d
UT_UTF8_H_	utf8.h	13;"	d
UT_WRY_H_	wry.h	10;"	d
UnInit	mongoc_json.cpp	/^int CMongodb::UnInit()$/;"	f	class:CMongodb	signature:()
UnInit	mongoc_json.h	/^		int 	UnInit();$/;"	p	class:CMongodb	access:public	signature:()
UnLock	RollLog.cpp	/^void CDayLog::UnLock()$/;"	f	class:CDayLog	signature:()
UnLock	RollLog.h	/^	void UnLock();\/\/{if(_lock) {if(_os.is_open()) _os<<unlock; _lock = false;} }$/;"	p	class:CDayLog	access:protected	signature:()
UnLock	file_lock.cpp	/^int CFileLock::UnLock(int iOffSet, int iSize)$/;"	f	class:CFileLock	signature:(int iOffSet, int iSize)
UnLock	file_lock.h	/^    int UnLock(int iOffSet, int iSize);$/;"	p	class:CFileLock	access:public	signature:(int iOffSet, int iSize)
Update	mongoc_json.cpp	/^int CMongodb::Update(string json_set, string json_query, bool upsert)$/;"	f	class:CMongodb	signature:(string json_set, string json_query, bool upsert)
Update	mongoc_json.h	/^		int		Update(string json_set, string json_query, bool upsert=false);	\/\/Êõ¥Êñ∞ upsert=true‰∏çÂ≠òÂú®Â∞±ÊèíÂÖ•$/;"	p	class:CMongodb	access:public	signature:(string json_set, string json_query, bool upsert=false)
VAR_MAX_ATTEMPT_TIMES	Attr_API_Var.c	34;"	d	file:
VAR_SET_SHM_KEY	Attr_API_Var.c	27;"	d	file:
VAR_SHM_HASH_LEN	Attr_API_Var.c	30;"	d	file:
VAR_SHM_HASH_TIMES	Attr_API_Var.c	31;"	d	file:
VAR_SHM_SIZE	Attr_API_Var.c	/^const int VAR_SHM_SIZE = sizeof(SVarNode) * VAR_SHM_HASH_LEN * VAR_SHM_HASH_TIMES;$/;"	v
VAR_SUM_SHM_KEY	Attr_API_Var.c	26;"	d	file:
XX	Makefile	/^XX      := g++$/;"	m
XX	Makefile	/^XX = g++ -O3 -Wall -fno-strict-aliasing -fomit-frame-pointer -fasynchronous-unwind-tables -fPIC $/;"	m
ZERO_LEN	crypt_tea.cpp	99;"	d	file:
_CRC_32_H_	crc32.h	2;"	d
_FILE_LOCK_H_	file_lock.h	2;"	d
_GNU_SOURCE	pack.c	12;"	d	file:
_OI_DEBUG_H	debug.h	2;"	d
_OI_SHM_H	shm.h	3;"	d
_PACKF_H_	pack.h	12;"	d
__CAS_64BIT_H__	CAS_64bit.h	19;"	d
__COMM_DEF_H_sunnyhao__	comm_def.h	19;"	d
__Day_Func	RollLog.h	/^typedef CDayLog& (*__Day_Func)(CDayLog&);$/;"	t
__DefaultMultiPoolConstructor	multi_object_pool.h	/^struct __DefaultMultiPoolConstructor$/;"	s
__DefaultMultiPoolConstructor::operator ()	multi_object_pool.h	/^    TObjectPool* operator () ( string opname )$/;"	f	struct:__DefaultMultiPoolConstructor	access:public	signature:( string opname )
__DefaultPoolConstructor	object_pool.h	/^struct __DefaultPoolConstructor$/;"	s
__DefaultPoolConstructor::operator ()	object_pool.h	/^    TObject* operator () ( )$/;"	f	struct:__DefaultPoolConstructor	access:public	signature:( )
__FLOAT_WORD_ORDER	pack.c	100;"	d	file:
__ISDIGIT	pack.c	134;"	d	file:
__MONGOC_JSON_H__	mongoc_json.h	8;"	d
__MULTI_OBJECT_POOL_H__	multi_object_pool.h	15;"	d
__OBJECT_POOL_H__	object_pool.h	14;"	d
__OPTIMIZED_TIME_H__	optimized_time.h	19;"	d
__Roll_Func	RollLog.h	/^typedef CRollLog& (*__Roll_Func)(CRollLog&);$/;"	t
__SINGLETON_H__	singleton.h	9;"	d
__SPIN_LOCK_H__	spin_lock.h	19;"	d
__STR_OF__	pack.h	252;"	d
__SYNC__REQUEST__	sync_request.h	9;"	d
__TIMER__H__	timer.h	11;"	d
__UTIL_H__	util.h	9;"	d
__WIRELESS_BASE_LIBRARY_LOG_H__	RollLog.h	3;"	d
__anon14::dsk	crypt_3des.h	/^    uint32_t dsk[32];     \/* DES decryption subkeys *\/$/;"	m	struct:__anon14	access:public
__anon14::esk	crypt_3des.h	/^    uint32_t esk[32];     \/* DES encryption subkeys *\/$/;"	m	struct:__anon14	access:public
__anon15::dsk	crypt_3des.h	/^    uint32_t dsk[96];     \/* Triple-DES decryption subkeys *\/$/;"	m	struct:__anon15	access:public
__anon15::esk	crypt_3des.h	/^    uint32_t esk[96];     \/* Triple-DES encryption subkeys *\/$/;"	m	struct:__anon15	access:public
__anon17::buffer	crypt_sha1.h	/^    uint8_t buffer[64];$/;"	m	struct:__anon17	access:public
__anon17::state	crypt_sha1.h	/^    uint32_t state[5];$/;"	m	struct:__anon17	access:public
__anon17::total	crypt_sha1.h	/^    uint32_t total[2];$/;"	m	struct:__anon17	access:public
__anon19::index	utf8.h	/^    unsigned int index;$/;"	m	struct:__anon19	access:public
__anon19::length	utf8.h	/^    unsigned int length;$/;"	m	struct:__anon19	access:public
__anon19::utf8_str	utf8.h	/^    const char *utf8_str;$/;"	m	struct:__anon19	access:public
__anon1::buf	fifo.h	/^	void* buf;	\/\/\/ the buffer$/;"	m	struct:__anon1	access:public
__anon1::rpos	fifo.h	/^	int rpos;	\/\/\/ the read position$/;"	m	struct:__anon1	access:public
__anon1::size	fifo.h	/^	int size;	\/\/\/ size of the buffer$/;"	m	struct:__anon1	access:public
__anon1::wpos	fifo.h	/^	int wpos;	\/\/\/ the write position$/;"	m	struct:__anon1	access:public
__anon21::buffer	crypt_sha256.h	/^    uint8_t buffer[64];$/;"	m	struct:__anon21	access:public
__anon21::state	crypt_sha256.h	/^    uint32_t state[8];$/;"	m	struct:__anon21	access:public
__anon21::total	crypt_sha256.h	/^    uint32_t total[2];$/;"	m	struct:__anon21	access:public
__anon22::_pinyin	py.h	/^	char* _pinyin;			\/\/[out]all pinyin will be stored here. set to NULL if you dont want it.$/;"	m	struct:__anon22	access:public
__anon22::_pinyin_count	py.h	/^	uint32_t _pinyin_count;	\/\/[in|out]the max count of elements in array @pinyin_pos when input, the result count when output. it must be set if one of @_pinyin_pos is not NULL.$/;"	m	struct:__anon22	access:public
__anon22::_pinyin_len	py.h	/^	uint32_t _pinyin_len;	\/\/[in|out]the max length of @pinyin when input, the result length of @pinyin when output. it must be set if @_pinyin is not NULL.$/;"	m	struct:__anon22	access:public
__anon22::_pinyin_pos	py.h	/^	uint32_t* _pinyin_pos;	\/\/[out]offset of each charater's pinyin. set to NULL if you dont want it. if @_pinyin is NULL, this property will be ignored.$/;"	m	struct:__anon22	access:public
__anon22::_pinyin_short	py.h	/^	char* _pinyin_short;	\/\/[out]acronym, short for @_pinyin. a list of initial letter of pinyin for each Chinese character.$/;"	m	struct:__anon22	access:public
__anon22::_pinyin_short_len	py.h	/^	uint32_t _pinyin_short_len;	\/\/[in|out]for @_pinyin_short, works like @_pinyin_len. it must be set if @_pinyin_short is not NULL.$/;"	m	struct:__anon22	access:public
__anon22::_string	py.h	/^	const char* _string;	\/\/[in]we will parse this string$/;"	m	struct:__anon22	access:public
__anon22::_string_len	py.h	/^	uint32_t _string_len;	\/\/[in]length of the @string$/;"	m	struct:__anon22	access:public
__anon23::next	ut_str.h	/^	unsigned char* next;$/;"	m	struct:__anon23	access:public
__anon23::patn	ut_str.h	/^	unsigned char* patn;$/;"	m	struct:__anon23	access:public
__anon23::patn_len	ut_str.h	/^	int patn_len;$/;"	m	struct:__anon23	access:public
__anon24::__anon25::dwAttrId	Attr_API.c	/^		uint32_t dwAttrId;$/;"	m	struct:__anon24::__anon25	file:	access:public
__anon24::__anon25::dwCurVal	Attr_API.c	/^		uint32_t dwCurVal;$/;"	m	struct:__anon24::__anon25	file:	access:public
__anon24::number_value	Attr_API.c	/^	uint64_t number_value;$/;"	m	union:__anon24	file:	access:public
__anon3::description	http.c	/^  const char *description;$/;"	m	struct:__anon3	file:	access:public
__anon3::name	http.c	/^  const char *name;$/;"	m	struct:__anon3	file:	access:public
__anon9::__anon10::__anon11::iAttrId	Attr_API_Var.c	/^			int iAttrId;                                \/*  Ù–‘id *\/$/;"	m	struct:__anon9::__anon10::__anon11	file:	access:public
__anon9::__anon10::__anon11::iVarKey	Attr_API_Var.c	/^			int iVarKey;                                \/* ±‰¡økey(ø…“‘Œ™∏∫ ˝) *\/$/;"	m	struct:__anon9::__anon10::__anon11	file:	access:public
__anon9::__anon10::key_number	Attr_API_Var.c	/^		uint64_t key_number;$/;"	m	union:__anon9::__anon10	file:	access:public
__anon9::__anon12::__anon13::iLastTime	Attr_API_Var.c	/^			int iLastTime;                              \/* ◊ÓΩ¸…œ±® ±º‰ *\/$/;"	m	struct:__anon9::__anon12::__anon13	file:	access:public
__anon9::__anon12::__anon13::iValue	Attr_API_Var.c	/^			int iValue;                                 \/* ∂‘”¶µƒ÷µ *\/$/;"	m	struct:__anon9::__anon12::__anon13	file:	access:public
__anon9::__anon12::val_number	Attr_API_Var.c	/^		uint64_t val_number;$/;"	m	union:__anon9::__anon12	file:	access:public
__atoi	pack.c	/^static inline int __atoi(char *s, size_t n)$/;"	f	file:	signature:(char *s, size_t n)
__bswap_d	pack.c	/^static double __bswap_d(double x)$/;"	f	file:	signature:(double x)
__bswap_f	pack.c	/^static float __bswap_f(float x)$/;"	f	file:	signature:(float x)
__call	timer.h	/^	inline void __call()$/;"	f	class:nw_timer	access:public	signature:()
__intra_charset	ut_mysql.h	/^	inline std::string& __intra_charset() { return _charset; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_cnnt_param	ut_mysql.h	/^	inline int32_t& __intra_cnnt_param() { return _cnnt_param; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_cnnt_timeout	ut_mysql.h	/^	inline int32_t& __intra_cnnt_timeout() { return _cnnt_timeout; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_connected	ut_mysql.h	/^	inline bool& __intra_connected() { return _connected; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_db_name	ut_mysql.h	/^	inline std::string& __intra_db_name() { return _db_name; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_execute_result	ut_mysql.h	/^	inline bool& __intra_execute_result() { return _execute_result; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_field_count	ut_mysql.h	/^	inline uint32_t& __intra_field_count() { return _field_count; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_field_len	ut_mysql.h	/^	inline unsigned long*& __intra_field_len() { return _field_len; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_host	ut_mysql.h	/^	inline std::string& __intra_host() { return _host; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_mysql	ut_mysql.h	/^	inline MYSQL& __intra_mysql() { return _mysql; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_on_connect_cb	ut_mysql.h	/^	inline callback_t& __intra_on_connect_cb() { return _on_connect_cb; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_on_connect_hdlr	ut_mysql.h	/^	inline handler_t*& __intra_on_connect_hdlr() { return _on_connect_hdlr; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_on_disconnect_cb	ut_mysql.h	/^	inline callback_t& __intra_on_disconnect_cb() { return _on_disconnect_cb; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_on_disconnect_hdlr	ut_mysql.h	/^	inline handler_t*& __intra_on_disconnect_hdlr() { return _on_disconnect_hdlr; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_on_mysql_options_cb	ut_mysql.h	/^	inline callback_t& __intra_on_mysql_options_cb() { return _on_mysql_options_cb; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_on_mysql_options_hdlr	ut_mysql.h	/^	inline handler_t*& __intra_on_mysql_options_hdlr() { return _on_mysql_options_hdlr; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_password	ut_mysql.h	/^	inline std::string& __intra_password() { return _password; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_port	ut_mysql.h	/^	inline uint16_t& __intra_port() { return _port; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_read_timeout	ut_mysql.h	/^	inline int32_t& __intra_read_timeout() { return _read_timeout; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_res	ut_mysql.h	/^	inline MYSQL_RES*& __intra_res() { return _res; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_row	ut_mysql.h	/^	inline MYSQL_ROW& __intra_row() { return _row; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_row_count	ut_mysql.h	/^	inline uint64_t& __intra_row_count() { return _row_count; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_user_name	ut_mysql.h	/^	inline std::string& __intra_user_name() { return _user_name; }$/;"	f	class:ut_mysql	access:protected	signature:()
__intra_write_timeout	ut_mysql.h	/^	inline int32_t& __intra_write_timeout() { return _write_timeout; }$/;"	f	class:ut_mysql	access:protected	signature:()
__isalpha	ut_str.cpp	/^inline static bool __isalpha(const char c) { return ( (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')); }$/;"	f	file:	signature:(const char c)
__packf	pack.c	/^static int __packf(void **net, int *left_len, char const *format, \\$/;"	f	file:	signature:(void **net, int *left_len, char const *format, \ int from, va_list va, void **locale)
__struct_len_locale	pack.c	/^static int __struct_len_locale(char const *format)$/;"	f	file:	signature:(char const *format)
__unpackf	pack.c	/^static int __unpackf(void **net, int *left_len, char const *format, \\$/;"	f	file:	signature:(void **net, int *left_len, char const *format, \ int from, va_list va, void **locale)
_arg	timer.h	/^	void* _arg;$/;"	m	class:nw_timer	access:private
_buf_count	RollLog.h	/^	unsigned _buf_count;$/;"	m	class:CRollLog	access:protected
_cb	timer.h	/^	}_cb;$/;"	m	class:nw_timer	typeref:union:nw_timer::__anon18	access:private
_charset	ut_mysql.h	/^	std::string _charset;$/;"	m	class:ut_mysql	access:private
_cnnt_param	ut_mysql.h	/^	int32_t _cnnt_param;$/;"	m	class:ut_mysql	access:private
_cnnt_timeout	ut_mysql.h	/^	int32_t _cnnt_timeout;$/;"	m	class:ut_mysql	access:private
_connected	ut_mysql.h	/^	bool _connected;$/;"	m	class:ut_mysql	access:private
_data	byte.h	/^	uint8_t	_data;$/;"	m	struct:ut_block	access:private
_data	byte.h	/^	uint8_t	_data[bytes_len];$/;"	m	struct:ut_block	access:private
_data	byte.h	/^	uint8_t _data[max_bytes_len];$/;"	m	struct:ut_buf	access:public
_data	byte.h	/^	uint8_t* _data;$/;"	m	struct:ut_bytes	access:public
_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon4	access:private
_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon5	access:private
_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon7	access:private
_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon8	access:private
_db_name	ut_mysql.h	/^	std::string _db_name;$/;"	m	class:ut_mysql	access:private
_debugtip	RollLog.h	/^	std::string _debugtip;$/;"	m	class:CRollLog	access:protected
_des_ecb_decrypt	crypto.cpp	/^bool _des_ecb_decrypt(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key)$/;"	f	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key)
_des_ecb_decrypt	crypto.h	/^bool _des_ecb_decrypt(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key);$/;"	p	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key)
_des_ecb_encrypt	crypto.cpp	/^bool _des_ecb_encrypt(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key)$/;"	f	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key)
_des_ecb_encrypt	crypto.h	/^bool _des_ecb_encrypt(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key);$/;"	p	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len, const void* key)
_err_code	ut_mysql.h	/^	uint32_t _err_code;$/;"	m	class:ut_mysql	access:private
_err_msg	ut_mysql.h	/^	char _err_msg[_err_msg_max_len];$/;"	m	class:ut_mysql	access:private
_err_msg_max_len	ut_mysql.h	/^	static const uint32_t _err_msg_max_len = 512;$/;"	m	class:ut_mysql	access:private
_exec	timer.h	/^	bool	 _exec;			\/\/ÊâßË°åÊ†áÂøó$/;"	m	class:nw_timer	access:private
_execute_result	ut_mysql.h	/^	bool _execute_result;$/;"	m	class:ut_mysql	access:private
_fd	RollLog.h	/^	int _fd;$/;"	m	class:CDayLog	access:protected
_fd	RollLog.h	/^	int _fd;$/;"	m	class:CRollLog	access:protected
_field_count	ut_mysql.h	/^	uint32_t _field_count;$/;"	m	class:ut_mysql	access:private
_field_len	ut_mysql.h	/^	unsigned long* _field_len;$/;"	m	class:ut_mysql	access:private
_filename	RollLog.h	/^	std::string _filename;$/;"	m	class:CDayLog	access:protected
_filename	RollLog.h	/^	std::string _filename;$/;"	m	class:CRollLog	access:protected
_flags	RollLog.h	/^	bool _flags[3];$/;"	m	class:CDayLog	access:protected
_flags	RollLog.h	/^	bool _flags[4];$/;"	m	class:CRollLog	access:protected
_hdlr	timer.h	/^	handler_t* _hdlr;$/;"	m	class:nw_timer	access:private
_hh	timer.h	/^	int _hh;$/;"	m	class:nw_timer	access:private
_host	ut_mysql.h	/^	std::string _host;$/;"	m	class:ut_mysql	access:private
_json_escape_tbl	ut_str.cpp	/^static json_escape_t _json_escape_tbl[256];$/;"	v	file:
_json_escape_tbl_inited	ut_str.cpp	/^static bool _json_escape_tbl_inited = false;$/;"	v	file:
_last	RollLog.h	/^	time_t _last;$/;"	m	class:CDayLog	access:protected
_len	byte.h	/^	static const int _len = 1;$/;"	m	struct:ut_block	access:public
_len	byte.h	/^	static const int _len = 2;$/;"	m	struct:ut_block	access:public
_len	byte.h	/^	static const int _len = 3;$/;"	m	struct:ut_block	access:public
_len	byte.h	/^	static const int _len = 4;$/;"	m	struct:ut_block	access:public
_len	byte.h	/^	static const int _len = 8;$/;"	m	struct:ut_block	access:public
_len	byte.h	/^	static const int _len = bytes_len;$/;"	m	struct:ut_block	access:public
_len	byte.h	/^	uint32_t _len;$/;"	m	struct:ut_buf	access:public
_len	byte.h	/^	uint32_t _len;$/;"	m	struct:ut_bytes	access:public
_level	RollLog.h	/^	Log_Level _level;$/;"	m	class:CRollLog	access:protected
_lock	RollLog.h	/^	bool _lock;$/;"	m	class:CDayLog	access:protected
_lock	RollLog.h	/^	bool _lock;$/;"	m	class:CRollLog	access:protected
_log_buffer	RollLog.h	/^	std::string _log_buffer;$/;"	m	class:CDayLog	access:protected
_log_buffer	RollLog.h	/^	std::string _log_buffer;$/;"	m	class:CRollLog	access:protected
_max_len	byte.h	/^	static const uint32_t _max_len = max_bytes_len;$/;"	m	struct:ut_buf	access:public
_max_log_num	RollLog.h	/^	unsigned _max_log_num;$/;"	m	class:CRollLog	access:protected
_max_log_size	RollLog.h	/^	unsigned _max_log_size;$/;"	m	class:CRollLog	access:protected
_member_function	timer.h	/^		handle_member_func_t _member_function;$/;"	m	union:nw_timer::__anon18	access:public
_member_function	ut_mysql.h	/^		void (handler_t::*_member_function)(self_t*);$/;"	m	union:ut_mysql::callback_t	access:public
_mm	timer.h	/^	int _mm;$/;"	m	class:nw_timer	access:private
_module	RollLog.h	/^	std::string _module;$/;"	m	class:CDayLog	access:protected
_module	RollLog.h	/^	std::string _module;$/;"	m	class:CRollLog	access:protected
_mutex	RollLog.h	/^static pthread_mutex_t  _mutex;$/;"	v
_mutex	sync_request.h	/^	pthread_mutex_t _mutex;$/;"	m	class:SyncRequest	access:public
_mysql	ut_mysql.h	/^	MYSQL _mysql;$/;"	m	class:ut_mysql	access:private
_n	ut_str.cpp	/^	char _n[2];$/;"	m	union:json_escape_t	file:	access:public
_null_string	ut_mysql.cpp	/^const char ut_mysql::_null_string[1] = {'\\0'};$/;"	m	class:ut_mysql	file:
_null_string	ut_mysql.h	/^	static const char _null_string[1];$/;"	m	class:ut_mysql	access:private
_on_connect_cb	ut_mysql.h	/^	callback_t _on_connect_cb;$/;"	m	class:ut_mysql	access:private
_on_connect_hdlr	ut_mysql.h	/^	handler_t* _on_connect_hdlr;$/;"	m	class:ut_mysql	access:private
_on_disconnect_cb	ut_mysql.h	/^	callback_t _on_disconnect_cb;$/;"	m	class:ut_mysql	access:private
_on_disconnect_hdlr	ut_mysql.h	/^	handler_t* _on_disconnect_hdlr;$/;"	m	class:ut_mysql	access:private
_on_mysql_options_cb	ut_mysql.h	/^	callback_t _on_mysql_options_cb;$/;"	m	class:ut_mysql	access:private
_on_mysql_options_hdlr	ut_mysql.h	/^	handler_t* _on_mysql_options_hdlr;$/;"	m	class:ut_mysql	access:private
_password	ut_mysql.h	/^	std::string _password;$/;"	m	class:ut_mysql	access:private
_pid	RollLog.h	/^	unsigned _pid;$/;"	m	class:CDayLog	access:protected
_pid	RollLog.h	/^	unsigned _pid;$/;"	m	class:CRollLog	access:protected
_pinyin	py.h	/^	char* _pinyin;			\/\/[out]all pinyin will be stored here. set to NULL if you dont want it.$/;"	m	struct:__anon22	access:public
_pinyin_count	py.h	/^	uint32_t _pinyin_count;	\/\/[in|out]the max count of elements in array @pinyin_pos when input, the result count when output. it must be set if one of @_pinyin_pos is not NULL.$/;"	m	struct:__anon22	access:public
_pinyin_len	py.h	/^	uint32_t _pinyin_len;	\/\/[in|out]the max length of @pinyin when input, the result length of @pinyin when output. it must be set if @_pinyin is not NULL.$/;"	m	struct:__anon22	access:public
_pinyin_pos	py.h	/^	uint32_t* _pinyin_pos;	\/\/[out]offset of each charater's pinyin. set to NULL if you dont want it. if @_pinyin is NULL, this property will be ignored.$/;"	m	struct:__anon22	access:public
_pinyin_short	py.h	/^	char* _pinyin_short;	\/\/[out]acronym, short for @_pinyin. a list of initial letter of pinyin for each Chinese character.$/;"	m	struct:__anon22	access:public
_pinyin_short_len	py.h	/^	uint32_t _pinyin_short_len;	\/\/[in|out]for @_pinyin_short, works like @_pinyin_len. it must be set if @_pinyin_short is not NULL.$/;"	m	struct:__anon22	access:public
_port	ut_mysql.h	/^	uint16_t _port;$/;"	m	class:ut_mysql	access:private
_read_timeout	ut_mysql.h	/^	int32_t _read_timeout;$/;"	m	class:ut_mysql	access:private
_repeat	timer.h	/^	bool _repeat;$/;"	m	class:nw_timer	access:private
_res	ut_mysql.h	/^	MYSQL_RES *_res;$/;"	m	class:ut_mysql	access:private
_retry	mongoc_json.h	/^		int _retry;$/;"	m	class:CMongodb	access:private
_row	ut_mysql.h	/^	MYSQL_ROW _row;$/;"	m	class:ut_mysql	access:private
_row_count	ut_mysql.h	/^	uint64_t _row_count;$/;"	m	class:ut_mysql	access:private
_running	timer.h	/^	bool _running;$/;"	m	class:nw_timer	access:private
_s	byte.h	/^		}_s;$/;"	m	union:ut_block::__anon5	typeref:struct:ut_block::__anon5::__anon6	access:public
_setlevel	RollLog.h	/^	Log_Level _setlevel;$/;"	m	class:CRollLog	access:protected
_static_function	timer.h	/^		handle_func_t _static_function;$/;"	m	union:nw_timer::__anon18	access:public
_static_function	ut_mysql.h	/^		void (*_static_function)(self_t*);$/;"	m	union:ut_mysql::callback_t	access:public
_string	py.h	/^	const char* _string;	\/\/[in]we will parse this string$/;"	m	struct:__anon22	access:public
_string_len	py.h	/^	uint32_t _string_len;	\/\/[in]length of the @string$/;"	m	struct:__anon22	access:public
_time_format	RollLog.h	/^	std::string _time_format;$/;"	m	class:CDayLog	access:protected
_time_format	RollLog.h	/^	std::string _time_format;$/;"	m	class:CRollLog	access:protected
_timer	test/test.cpp	/^		nw_timer _timer;$/;"	m	class:Time	file:	access:private
_tv	timer.h	/^	double _tv;				\/\/ÂÆöÊó∂Âô®Èó¥Èöî$/;"	m	class:nw_timer	access:private
_tv_front	timer.h	/^	uint64_t _tv_front;		\/\/‰∏ä‰∏ÄÊ¨°ÊâßË°åÊó∂Èó¥$/;"	m	class:nw_timer	access:private
_u16	byte.h	/^			uint16_t _u16;$/;"	m	struct:ut_block::__anon5::__anon6	access:public
_u16	byte.h	/^		uint16_t _u16;$/;"	m	union:ut_block::__anon4	access:public
_u32	byte.h	/^		uint32_t _u32;$/;"	m	union:ut_block::__anon7	access:public
_u64	byte.h	/^		uint64_t _u64;$/;"	m	union:ut_block::__anon8	access:public
_u8	byte.h	/^			uint8_t _u8;$/;"	m	struct:ut_block::__anon5::__anon6	access:public
_u8	byte.h	/^		uint8_t	_u8[2];$/;"	m	union:ut_block::__anon4	access:public
_u8	byte.h	/^		uint8_t	_u8[3];$/;"	m	union:ut_block::__anon5	access:public
_u8	byte.h	/^		uint8_t	_u8[4];$/;"	m	union:ut_block::__anon7	access:public
_u8	byte.h	/^		uint8_t	_u8[8];$/;"	m	union:ut_block::__anon8	access:public
_user_name	ut_mysql.h	/^	std::string _user_name;$/;"	m	class:ut_mysql	access:private
_v	ut_str.cpp	/^	uint16_t _v;$/;"	m	union:json_escape_t	file:	access:public
_wait	timer.h	/^	uint32_t _wait;			\/\/Á¨¨‰∏ÄÊ¨°Á≠âÂæÖÊó∂Èïø$/;"	m	class:nw_timer	access:private
_write_timeout	ut_mysql.h	/^	int32_t _write_timeout;$/;"	m	class:ut_mysql	access:private
a	test/test.cpp	/^		int a;$/;"	m	class:Time	file:	access:private
adderror	RollLog.h	/^	friend CRollLog& adderror(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
adderror	RollLog.h	/^inline CRollLog& adderror(CRollLog& log)$/;"	f	signature:(CRollLog& log)
affected_rows	ut_mysql.h	/^	inline uint64_t affected_rows() { return mysql_affected_rows(&_mysql); }$/;"	f	class:ut_mysql	access:public	signature:()
affected_rows	ut_mysql.h	/^	inline uint64_t affected_rows(MYSQL_STMT* stmt) { return mysql_stmt_affected_rows(stmt); }$/;"	f	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
arg	timer.h	/^	inline void arg(void* p) { _arg = p; }$/;"	f	class:nw_timer	access:public	signature:(void* p)
arg	timer.h	/^	inline void* arg(void) const { return _arg; }$/;"	f	class:nw_timer	access:public	signature:(void) const
attrA	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int attrA;$/;"	m	class:MyObject	file:	access:private
attrA	objpools/test_object_pool.cpp	/^		int attrA;$/;"	m	class:MyObject	file:	access:private
attrB	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int attrB;$/;"	m	class:MyObject	file:	access:private
attrB	objpools/test_object_pool.cpp	/^		int attrB;$/;"	m	class:MyObject	file:	access:private
base64_decode	base64.c	/^int32_t  base64_decode(uint8_t* output, const uint8_t* input, int32_t input_len)$/;"	f	signature:(uint8_t* output, const uint8_t* input, int32_t input_len)
base64_decode	base64.h	/^int32_t  base64_decode(uint8_t* output, const uint8_t* input, int32_t input_len);$/;"	p	signature:(uint8_t* output, const uint8_t* input, int32_t input_len)
base64_decode	crypto.cpp	/^bool base64_decode(void* output, uint32_t& output_len, const void* input, uint32_t input_len)$/;"	f	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len)
base64_decode	crypto.h	/^bool base64_decode(void* output, uint32_t& output_len, const void* input, uint32_t input_len);$/;"	p	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len)
base64_encode	base64.c	/^int32_t  base64_encode(uint8_t* output, const uint8_t* input, int32_t input_len)$/;"	f	signature:(uint8_t* output, const uint8_t* input, int32_t input_len)
base64_encode	base64.h	/^int32_t  base64_encode(uint8_t* output, const uint8_t* input, int32_t input_len);$/;"	p	signature:(uint8_t* output, const uint8_t* input, int32_t input_len)
base64_encode	crypto.cpp	/^bool base64_encode(void* output, uint32_t& output_len, const void* input, uint32_t input_len)$/;"	f	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len)
base64_encode	crypto.h	/^bool base64_encode(void* output, uint32_t& output_len, const void* input, uint32_t input_len);$/;"	p	signature:(void* output, uint32_t& output_len, const void* input, uint32_t input_len)
base_t	byte.h	/^	typedef ut_block<bytes_len> base_t;$/;"	t	struct:ut_block_uint32	access:public
be16toh	pack.c	77;"	d	file:
be16toh	pack.c	87;"	d	file:
be16toh	pack.c	94;"	d	file:
be32toh	pack.c	78;"	d	file:
be32toh	pack.c	88;"	d	file:
be32toh	pack.c	95;"	d	file:
be64toh	pack.c	79;"	d	file:
be64toh	pack.c	89;"	d	file:
be64toh	pack.c	96;"	d	file:
bedtoh	pack.c	124;"	d	file:
bedtoh	pack.c	129;"	d	file:
bedtoh	pack.c	81;"	d	file:
beftoh	pack.c	123;"	d	file:
beftoh	pack.c	128;"	d	file:
beftoh	pack.c	80;"	d	file:
bin2hex	ut_str.cpp	/^void bin2hex(void* hex_output, const void* mem, int mem_len)$/;"	f	signature:(void* hex_output, const void* mem, int mem_len)
bin2hex	ut_str.h	/^void bin2hex(void* hex_output, const void* mem, int mem_len);$/;"	p	signature:(void* hex_output, const void* mem, int mem_len)
bits	crypt_md5.h	/^        uint32_t bits[2];$/;"	m	struct:MD5Context	access:public
blocksize	md5.h	/^  enum {blocksize = 64}; \/\/ VC6 won't eat a const static int here$/;"	e	enum:MD5::__anon20
bool	CAS_64bit.h	/^typedef _Bool bool;$/;"	t
buf	crypt_md5.h	/^        uint32_t buf[4];$/;"	m	struct:MD5Context	access:public
buf	fifo.h	/^	void* buf;	\/\/\/ the buffer$/;"	m	struct:__anon1	access:public
buffer	crypt_sha1.h	/^    uint8_t buffer[64];$/;"	m	struct:__anon17	access:public
buffer	crypt_sha256.h	/^    uint8_t buffer[64];$/;"	m	struct:__anon21	access:public
buffer	md5.h	/^  uint1 buffer[blocksize]; \/\/ bytes that didn't fit in last 64 byte chunk$/;"	m	class:MD5	access:private
byteReverse	crypt_md5.c	/^void byteReverse(buf, longs)$/;"	f
byteReverse	crypt_md5.c	21;"	d	file:
callback	test/test.cpp	/^		void callback()$/;"	f	class:Time	access:public	signature:()
callback_AddValue	Attr_API.c	/^static inline int callback_AddValue(volatile AGENT_ATTR_NODE* pNode, uint32_t dwAttrId, uint32_t dwNewVal, uint32_t *pdwValue)$/;"	f	file:	signature:(volatile AGENT_ATTR_NODE* pNode, uint32_t dwAttrId, uint32_t dwNewVal, uint32_t *pdwValue)
callback_AddValue	Attr_API_Var.c	/^static inline int callback_AddValue(volatile SVarNode* pNode, int iCurTime, uint32_t dwNewVal, uint32_t *pdwValue)$/;"	f	file:	signature:(volatile SVarNode* pNode, int iCurTime, uint32_t dwNewVal, uint32_t *pdwValue)
callback_SetValue	Attr_API.c	/^static inline int callback_SetValue(volatile AGENT_ATTR_NODE* pNode, uint32_t dwAttrId, uint32_t dwNewVal, uint32_t *pdwValue)$/;"	f	file:	signature:(volatile AGENT_ATTR_NODE* pNode, uint32_t dwAttrId, uint32_t dwNewVal, uint32_t *pdwValue)
callback_SetValue	Attr_API_Var.c	/^static inline int callback_SetValue(volatile SVarNode* pNode, int iCurTime, uint32_t dwNewVal, uint32_t *pdwValue)$/;"	f	file:	signature:(volatile SVarNode* pNode, int iCurTime, uint32_t dwNewVal, uint32_t *pdwValue)
callback_static	test/test.cpp	/^		static void callback_static()$/;"	f	class:Time	access:public	signature:()
callback_t	ut_mysql.h	/^	union callback_t$/;"	u	class:ut_mysql	access:protected
cb64	base64.c	/^static const char cb64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v	file:
cd64	base64.c	/^static const char cd64[] =$/;"	v	file:
check	timer.h	/^	inline void check()$/;"	f	class:nw_timer	access:public	signature:()
check_level	RollLog.cpp	/^bool CRollLog::check_level()$/;"	f	class:CRollLog	signature:()
check_level	RollLog.h	/^	bool check_level(); $/;"	p	class:CRollLog	access:protected	signature:()
ciCachePoolSize	object_pool.h	/^		int ciCachePoolSize;$/;"	m	class:ObjectPool	access:private
ciMaxConnection	object_pool.h	/^		int ciMaxConnection;$/;"	m	class:ObjectPool	access:private
ciReserveTimeout	object_pool.h	/^		int ciReserveTimeout;$/;"	m	class:ObjectPool	access:private
ciUsingCount	object_pool.h	/^		int ciUsingCount;$/;"	m	class:ObjectPool	access:private
city	wry.h	/^	uint8_t* city;$/;"	m	struct:wry_loc	access:public
city_len	wry.h	/^	uint8_t city_len;$/;"	m	struct:wry_loc	access:public
clear_titleflag	RollLog.h	/^	void clear_titleflag(title_flag f) {_flags[f] = false;}$/;"	f	class:CDayLog	access:public	signature:(title_flag f)
clear_titleflag	RollLog.h	/^	void clear_titleflag(title_flag f) {_flags[f] = false;}$/;"	f	class:CRollLog	access:public	signature:(title_flag f)
close_connection	ut_mysql.h	/^	inline void close_connection() { disconnect(); }$/;"	f	class:ut_mysql	access:public	signature:()
close_stmt	ut_mysql.h	/^	inline void close_stmt(MYSQL_STMT* stmt) { mysql_stmt_free_result(stmt); mysql_stmt_close(stmt); }$/;"	f	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
cnf_section_t	conf.h	/^	typedef std::map< std::string, std::string > cnf_section_t;$/;"	t	class:Conf	access:private
coCheckOutConnection	multi_object_pool.h	/^		map<size_t,stObjectOfGroup> coCheckOutConnection; \/\/ size_tºÊ»›64Œªª˙∆˜£¨≥§∂»ø…“‘»›ƒ…÷∏’Î$/;"	m	class:MultiObjectPool	access:private
coCheckoutConnection	object_pool.h	/^		map< size_t, ObjectNode > coCheckoutConnection; \/\/ size_tºÊ»›64Œªª˙∆˜£¨≥§∂»ø…“‘»›ƒ…÷∏’Î$/;"	m	class:ObjectPool	access:private
coConnectionGroup	multi_object_pool.h	/^		map<string,TObjectPool *> coConnectionGroup;$/;"	m	class:MultiObjectPool	access:private
coConstructorType	multi_object_pool.h	/^		ConstructorType coConstructorType;$/;"	m	class:MultiObjectPool	access:private
coConstructorType	object_pool.h	/^		ConstructorType coConstructorType;$/;"	m	class:ObjectPool	access:private
coFreeConnections	object_pool.h	/^		deque<ObjectNode> coFreeConnections;$/;"	m	class:ObjectPool	access:private
config	conf.h	/^	section_map_t config;$/;"	m	class:Conf	access:private
connect	ut_mysql.cpp	/^bool ut_mysql::connect()$/;"	f	class:ut_mysql	signature:()
connect	ut_mysql.h	/^	bool connect();$/;"	p	class:ut_mysql	access:private	signature:()
connected	ut_mysql.h	/^	inline bool connected() const { return _connected; }$/;"	f	class:ut_mysql	access:public	signature:() const
connection_id	ut_mysql.h	/^	inline uint64_t connection_id() { return mysql_thread_id(&_mysql); }$/;"	f	class:ut_mysql	access:public	signature:()
content_length	http.h	/^  int64_t content_length;$/;"	m	struct:http_parser	access:public
count	md5.h	/^  uint4 count[2];   \/\/ 64bit counter for number of bits (lo, hi)$/;"	m	class:MD5	access:private
cpObject	object_pool.h	/^			TObject*	cpObject;$/;"	m	struct:ObjectPool::ObjectNode	access:public
cpoTObject	multi_object_pool.h	/^			TObject * cpoTObject;$/;"	m	struct:MultiObjectPool::stObjectOfGroup	access:public
cpuspeed_mhz	optimized_time.h	/^static int cpuspeed_mhz;$/;"	v
crc32_table	crc32.c	/^uint32_t crc32_table[256] = {$/;"	v
crc_32	crc32.c	/^uint32_t crc_32(uint32_t sed, unsigned char const * data, uint32_t length)$/;"	f	signature:(uint32_t sed, unsigned char const * data, uint32_t length)
crc_32	crc32.h	/^uint32_t crc_32(uint32_t sed, unsigned char const * data, uint32_t length);$/;"	p	signature:(uint32_t sed, unsigned char const * data, uint32_t length)
create_and_prepare_stmt	ut_mysql.cpp	/^MYSQL_STMT* ut_mysql::create_and_prepare_stmt(const char* sql, uint32_t len)$/;"	f	class:ut_mysql	signature:(const char* sql, uint32_t len)
create_and_prepare_stmt	ut_mysql.h	/^	MYSQL_STMT* create_and_prepare_stmt(const char* sql, uint32_t len);$/;"	p	class:ut_mysql	access:public	signature:(const char* sql, uint32_t len)
csName	multi_object_pool.h	/^			string csName;$/;"	m	struct:MultiObjectPool::stObjectOfGroup	access:public
ctCheckOutMutex	multi_object_pool.h	/^		pthread_mutex_t ctCheckOutMutex;$/;"	m	class:MultiObjectPool	access:private
ctCheckoutMutex	object_pool.h	/^		pthread_mutex_t	ctCheckoutMutex;$/;"	m	class:ObjectPool	access:private
ctCreateTime	object_pool.h	/^			time_t	ctCreateTime;$/;"	m	struct:ObjectPool::ObjectNode	access:public
ctFreeMutex	object_pool.h	/^		pthread_mutex_t ctFreeMutex;$/;"	m	class:ObjectPool	access:private
ctGroupMutex	multi_object_pool.h	/^		pthread_mutex_t ctGroupMutex;$/;"	m	class:MultiObjectPool	access:private
ctLock	object_pool.h	/^		pthread_mutex_t ctLock;$/;"	m	class:ObjectPool	access:private
ctVisitTime	object_pool.h	/^			time_t	ctVisitTime;$/;"	m	struct:ObjectPool::ObjectNode	access:public
ctos	util.cpp	/^string ctos(char c)$/;"	f	signature:(char c)
ctos	util.h	/^string ctos(char c);$/;"	p	signature:(char c)
cur_time	RollLog.cpp	/^inline string CRollLog::cur_time()$/;"	f	class:CRollLog	signature:()
cur_time	RollLog.h	/^	std::string cur_time();$/;"	p	class:CRollLog	access:protected	signature:()
data	byte.h	/^	inline const uint8_t* data() const { return &_data; }$/;"	f	struct:ut_block	access:public	signature:() const
data	byte.h	/^	inline const uint8_t* data() const { return _data._u8; }$/;"	f	struct:ut_block	access:public	signature:() const
data	byte.h	/^	inline const uint8_t* data() const { return _data; }$/;"	f	struct:ut_block	access:public	signature:() const
data	byte.h	/^	inline uint8_t* data() { return &_data; }$/;"	f	struct:ut_block	access:public	signature:()
data	byte.h	/^	inline uint8_t* data() { return _data._u8; }$/;"	f	struct:ut_block	access:public	signature:()
data	byte.h	/^	inline uint8_t* data() { return _data; }$/;"	f	struct:ut_block	access:public	signature:()
data	http.h	/^  void *data; \/* A pointer to get hook to the "connection" or "socket" object *\/$/;"	m	struct:http_parser	access:public
debug	RollLog.h	/^	friend CRollLog& debug(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
debug	RollLog.h	/^inline CRollLog& debug(CRollLog& log)$/;"	f	signature:(CRollLog& log)
decode	md5.cpp	/^void MD5::decode(uint4 output[], const uint1 input[], size_type len)$/;"	f	class:MD5	signature:(uint4 output[], const uint1 input[], size_type len)
decode	md5.h	/^  static void decode(uint4 output[], const uint1 input[], size_type len);$/;"	p	class:MD5	access:private	signature:(uint4 output[], const uint1 input[], size_type len)
des3_context	crypt_3des.h	/^} des3_context;$/;"	t	typeref:struct:__anon15
des3_crypt	crypt_3des.c	/^void des3_crypt( uint32_t SK[96], const uint8_t input[8], uint8_t output[8] )$/;"	f	signature:( uint32_t SK[96], const uint8_t input[8], uint8_t output[8] )
des3_decrypt	crypt_3des.c	/^void des3_decrypt( des3_context *ctx, const uint8_t input[8], uint8_t output[8] )$/;"	f	signature:( des3_context *ctx, const uint8_t input[8], uint8_t output[8] )
des3_decrypt	crypt_3des.h	/^void des3_decrypt( des3_context *ctx, const uint8_t input[8], uint8_t output[8] );$/;"	p	signature:( des3_context *ctx, const uint8_t input[8], uint8_t output[8] )
des3_encrypt	crypt_3des.c	/^void des3_encrypt( des3_context *ctx, const uint8_t input[8], uint8_t output[8] )$/;"	f	signature:( des3_context *ctx, const uint8_t input[8], uint8_t output[8] )
des3_encrypt	crypt_3des.h	/^void des3_encrypt( des3_context *ctx, const uint8_t input[8], uint8_t output[8] );$/;"	p	signature:( des3_context *ctx, const uint8_t input[8], uint8_t output[8] )
des3_set_2keys	crypt_3des.c	/^int des3_set_2keys( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8] )$/;"	f	signature:( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8] )
des3_set_2keys	crypt_3des.h	/^int des3_set_2keys( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8] );$/;"	p	signature:( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8] )
des3_set_3keys	crypt_3des.c	/^int des3_set_3keys( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8], const uint8_t key3[8] )$/;"	f	signature:( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8], const uint8_t key3[8] )
des3_set_3keys	crypt_3des.h	/^int des3_set_3keys( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8], const uint8_t key3[8] );$/;"	p	signature:( des3_context *ctx, const uint8_t key1[8], const uint8_t key2[8], const uint8_t key3[8] )
des_context	crypt_3des.h	/^} des_context;$/;"	t	typeref:struct:__anon14
des_crypt	crypt_3des.c	/^void des_crypt( uint32_t SK[32], const uint8_t input[8], uint8_t output[8] )$/;"	f	signature:( uint32_t SK[32], const uint8_t input[8], uint8_t output[8] )
des_decrypt	crypt_3des.c	/^void des_decrypt( des_context *ctx, const uint8_t input[8], uint8_t output[8] )$/;"	f	signature:( des_context *ctx, const uint8_t input[8], uint8_t output[8] )
des_decrypt	crypt_3des.h	/^void des_decrypt( des_context *ctx, const uint8_t input[8], uint8_t output[8] );$/;"	p	signature:( des_context *ctx, const uint8_t input[8], uint8_t output[8] )
des_encrypt	crypt_3des.c	/^void des_encrypt( des_context *ctx, const uint8_t input[8], uint8_t output[8] )$/;"	f	signature:( des_context *ctx, const uint8_t input[8], uint8_t output[8] )
des_encrypt	crypt_3des.h	/^void des_encrypt( des_context *ctx, const uint8_t input[8], uint8_t output[8] );$/;"	p	signature:( des_context *ctx, const uint8_t input[8], uint8_t output[8] )
des_main_ks	crypt_3des.c	/^int des_main_ks( uint32_t SK[32], const uint8_t key[8] )$/;"	f	signature:( uint32_t SK[32], const uint8_t key[8] )
des_set_key	crypt_3des.c	/^int des_set_key( des_context *ctx, const uint8_t key[8] )$/;"	f	signature:( des_context *ctx, const uint8_t key[8] )
des_set_key	crypt_3des.h	/^int des_set_key( des_context *ctx, const uint8_t key[8] );$/;"	p	signature:( des_context *ctx, const uint8_t key[8] )
description	http.c	/^  const char *description;$/;"	m	struct:__anon3	file:	access:public
digest	md5.h	/^  uint1 digest[16]; \/\/ the result$/;"	m	class:MD5	access:private
disconnect	ut_mysql.cpp	/^void ut_mysql::disconnect()$/;"	f	class:ut_mysql	signature:()
disconnect	ut_mysql.h	/^	void disconnect();$/;"	p	class:ut_mysql	access:private	signature:()
dsk	crypt_3des.h	/^    uint32_t dsk[32];     \/* DES decryption subkeys *\/$/;"	m	struct:__anon14	access:public
dsk	crypt_3des.h	/^    uint32_t dsk[96];     \/* Triple-DES decryption subkeys *\/$/;"	m	struct:__anon15	access:public
dwAttrId	Attr_API.c	/^		uint32_t dwAttrId;$/;"	m	struct:__anon24::__anon25	file:	access:public
dwCurVal	Attr_API.c	/^		uint32_t dwCurVal;$/;"	m	struct:__anon24::__anon25	file:	access:public
encode	md5.cpp	/^void MD5::encode(uint1 output[], const uint4 input[], size_type len)$/;"	f	class:MD5	signature:(uint1 output[], const uint4 input[], size_type len)
encode	md5.h	/^  static void encode(uint1 output[], const uint4 input[], size_type len);$/;"	p	class:MD5	access:private	signature:(uint1 output[], const uint4 input[], size_type len)
endl	RollLog.h	/^	friend CDayLog& endl(CDayLog& log);$/;"	p	class:CDayLog	access:friend	signature:(CDayLog& log)
endl	RollLog.h	/^	friend CRollLog& endl(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
endl	RollLog.h	/^inline CDayLog& endl(CDayLog& log)$/;"	f	signature:(CDayLog& log)
endl	RollLog.h	/^inline CRollLog& endl(CRollLog& log)$/;"	f	signature:(CRollLog& log)
ensure_connection	ut_mysql.h	/^	inline bool ensure_connection() { if(!_connected) return connect(); return true; }$/;"	f	class:ut_mysql	access:public	signature:()
equal	byte.h	/^	inline bool equal(const void* data, uint32_t len) const$/;"	f	struct:ut_buf	access:public	signature:(const void* data, uint32_t len) const
err_is_connect_lost	ut_mysql.cpp	/^inline static bool err_is_connect_lost(uint32_t err)$/;"	f	file:	signature:(uint32_t err)
err_msg	pack.c	/^static char const *err_msg[] =$/;"	v	file:
error_code	ut_mysql.h	/^	inline uint32_t error_code() const { return _err_code;	}$/;"	f	class:ut_mysql	access:public	signature:() const
error_cr_server_lost	ut_mysql.h	/^	inline bool error_cr_server_lost() const { return is_err_cr_server_lost(_err_code); }$/;"	f	class:ut_mysql	access:public	signature:() const
error_key_dup	ut_mysql.h	/^	inline bool error_key_dup() const { return is_err_key_dup(_err_code); }$/;"	f	class:ut_mysql	access:public	signature:() const
error_lineno	http.h	/^  uint32_t error_lineno;$/;"	m	struct:http_parser	access:public
error_msg	ut_mysql.h	/^	inline const char* error_msg() const { return _err_msg; }$/;"	f	class:ut_mysql	access:public	signature:() const
escape	ut_mysql.h	/^	inline uint64_t escape(char*to, const char* from, uint64_t len) { return mysql_real_escape_string(&_mysql, to, from, len); }$/;"	f	class:ut_mysql	access:public	signature:(char*to, const char* from, uint64_t len)
esk	crypt_3des.h	/^    uint32_t esk[32];     \/* DES encryption subkeys *\/$/;"	m	struct:__anon14	access:public
esk	crypt_3des.h	/^    uint32_t esk[96];     \/* Triple-DES encryption subkeys *\/$/;"	m	struct:__anon15	access:public
execute	ut_mysql.cpp	/^bool ut_mysql::execute(MYSQL_STMT* stmt, MYSQL_BIND* param_bind)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind)
execute	ut_mysql.cpp	/^bool ut_mysql::execute(const char* sql, uint32_t len)$/;"	f	class:ut_mysql	signature:(const char* sql, uint32_t len)
execute	ut_mysql.h	/^	bool execute(MYSQL_STMT* stmt, MYSQL_BIND* param_bind);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind)
execute	ut_mysql.h	/^	bool execute(const char* sql, uint32_t len);$/;"	p	class:ut_mysql	access:public	signature:(const char* sql, uint32_t len)
field	ut_mysql.h	/^	inline const char* field(const std::string& name) const { int idx = field_index(name); if(idx>=0) return field(idx); return NULL; }$/;"	f	class:ut_mysql	access:public	signature:(const std::string& name) const
field	ut_mysql.h	/^	inline const char* field(const uint32_t index) const { if(index<field_count()) return _row[index]; return NULL; }$/;"	f	class:ut_mysql	access:public	signature:(const uint32_t index) const
field_count	ut_mysql.h	/^	inline uint32_t field_count() const { return _execute_result? _field_count : 0; }$/;"	f	class:ut_mysql	access:public	signature:() const
field_index	ut_mysql.cpp	/^int ut_mysql::field_index(const std::string& name) const$/;"	f	class:ut_mysql	signature:(const std::string& name) const
field_index	ut_mysql.h	/^	int field_index(const std::string& name) const;$/;"	p	class:ut_mysql	access:public	signature:(const std::string& name) const
field_len	ut_mysql.h	/^	inline const uint64_t field_len(const std::string& name) const { return field_len(field_index(name)); }$/;"	f	class:ut_mysql	access:public	signature:(const std::string& name) const
field_len	ut_mysql.h	/^	inline const uint64_t field_len(const uint32_t index) const { if(index<field_count()) return _field_len[index]; return 0; }$/;"	f	class:ut_mysql	access:public	signature:(const uint32_t index) const
fifo_init	fifo.c	/^void fifo_init(Fifo* fifo, void* buf, int len)$/;"	f	signature:(Fifo* fifo, void* buf, int len)
fifo_init	fifo.h	/^void fifo_init(Fifo* fifo, void* buf, int size);$/;"	p	signature:(Fifo* fifo, void* buf, int size)
fifo_pre_read	fifo.c	/^bool fifo_pre_read(const Fifo* fifo, void* buf, int len)$/;"	f	signature:(const Fifo* fifo, void* buf, int len)
fifo_pre_read	fifo.h	/^bool fifo_pre_read(const Fifo* fifo, void* buf, int len);$/;"	p	signature:(const Fifo* fifo, void* buf, int len)
fifo_pre_write	fifo.c	/^bool fifo_pre_write(Fifo* fifo, const void* buf, int len)$/;"	f	signature:(Fifo* fifo, const void* buf, int len)
fifo_pre_write	fifo.h	/^bool fifo_pre_write(Fifo* fifo, const void* buf, int len);$/;"	p	signature:(Fifo* fifo, const void* buf, int len)
fifo_ravai	fifo.c	/^int fifo_ravai(const Fifo* fifo)$/;"	f	signature:(const Fifo* fifo)
fifo_ravai	fifo.h	/^int fifo_ravai(const Fifo* fifo);$/;"	p	signature:(const Fifo* fifo)
fifo_read	fifo.c	/^bool fifo_read(Fifo* fifo, void* buf, int len)$/;"	f	signature:(Fifo* fifo, void* buf, int len)
fifo_read	fifo.h	/^bool fifo_read(Fifo* fifo, void* buf, int len);$/;"	p	signature:(Fifo* fifo, void* buf, int len)
fifo_reset	fifo.h	/^inline void fifo_reset(Fifo* fifo) { fifo->wpos = fifo->rpos = 0; }$/;"	f	signature:(Fifo* fifo)
fifo_rseek	fifo.c	/^bool fifo_rseek(Fifo* fifo, unsigned int offset)$/;"	f	signature:(Fifo* fifo, unsigned int offset)
fifo_rseek	fifo.h	/^bool fifo_rseek(Fifo* fifo, unsigned int offset);$/;"	p	signature:(Fifo* fifo, unsigned int offset)
fifo_rtell	fifo.h	/^inline int fifo_rtell(const Fifo* fifo) { return fifo->rpos; }$/;"	f	signature:(const Fifo* fifo)
fifo_size	fifo.h	/^inline int fifo_size(const Fifo* fifo) { return fifo->size; }$/;"	f	signature:(const Fifo* fifo)
fifo_write	fifo.c	/^bool fifo_write(Fifo* fifo, const void* buf, int len)$/;"	f	signature:(Fifo* fifo, const void* buf, int len)
fifo_write	fifo.h	/^bool fifo_write(Fifo* fifo, const void* buf, int len);$/;"	p	signature:(Fifo* fifo, const void* buf, int len)
fifo_wseek	fifo.c	/^bool fifo_wseek(Fifo* fifo, unsigned int offset)$/;"	f	signature:(Fifo* fifo, unsigned int offset)
fifo_wseek	fifo.h	/^bool fifo_wseek(Fifo* fifo, unsigned int offset);$/;"	p	signature:(Fifo* fifo, unsigned int offset)
fifo_wspace	fifo.c	/^int fifo_wspace(const Fifo* fifo)$/;"	f	signature:(const Fifo* fifo)
fifo_wspace	fifo.h	/^int fifo_wspace(const Fifo* fifo);$/;"	p	signature:(const Fifo* fifo)
fifo_wtell	fifo.h	/^inline int fifo_wtell(const Fifo* fifo) { return fifo->wpos; }$/;"	f	signature:(const Fifo* fifo)
fill	byte.h	/^	inline void fill(const int8_t c) { _data = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = _data._u8[2] = _data._u8[3] = _data._u8[4] = _data._u8[5] = _data._u8[6] = _data._u8[7] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = _data._u8[2] = _data._u8[3] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = _data._u8[2] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
fill	byte.h	/^	inline void fill(const int8_t c) { memset(_data, c, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
fill	byte.h	/^	inline void fill(const int8_t c) { memset(_data, c, max_bytes_len); }$/;"	f	struct:ut_buf	access:public	signature:(const int8_t c)
finalize	md5.cpp	/^MD5& MD5::finalize()$/;"	f	class:MD5	signature:()
finalize	md5.h	/^  MD5& finalize();$/;"	p	class:MD5	access:public	signature:()
finalized	md5.h	/^  bool finalized;$/;"	m	class:MD5	access:private
first_index_offset	wry.h	/^	int32_t first_index_offset;$/;"	m	struct:wry_head	access:public
flags	http.h	/^  unsigned char flags : 6; \/* F_* values from 'flags' enum; semi-public *\/$/;"	m	struct:http_parser	access:public
flags	http.h	/^enum flags$/;"	g
g_arrMod	Attr_API.c	/^static const int g_arrMod[AGENT_ATTR_SHM_HASH_TIMES] = {998, 997, 991, 983, 982, 977, 976, 974, 971, 967, $/;"	v	file:
g_arrMod	Attr_API_Var.c	/^static const int g_arrMod[VAR_SHM_HASH_TIMES] = {998, 997, 991, 983, 982, 977, 976, 974, 971, 967, $/;"	v	file:
g_pBusiShareMem	Attr_API_Str.c	/^static char *g_pBusiShareMem = NULL;$/;"	v	file:
g_pSetShm	Attr_API.c	/^static void* g_pSetShm = NULL;$/;"	v	file:
g_pSetShm	Attr_API_Var.c	/^static void* g_pSetShm = NULL;$/;"	v	file:
g_pSumShm	Attr_API.c	/^static void* g_pSumShm = NULL;$/;"	v	file:
g_pSumShm	Attr_API_Var.c	/^static void* g_pSumShm = NULL;$/;"	v	file:
get	conf.cpp	/^char* Conf::get(const std::string& section, const std::string& name, char* value, const std::string& def)$/;"	f	class:Conf	signature:(const std::string& section, const std::string& name, char* value, const std::string& def)
get	conf.cpp	/^std::string& Conf::get(const std::string& section, const std::string& name, std::string& value, const std::string& def)$/;"	f	class:Conf	signature:(const std::string& section, const std::string& name, std::string& value, const std::string& def)
get	conf.h	/^	T& get(const std::string& section, const std::string& name, T& value, const std::string& def = "")$/;"	f	class:Conf	access:public	signature:(const std::string& section, const std::string& name, T& value, const std::string& def = ”)
get	conf.h	/^	char* get(const std::string& section, const std::string& name, char* value, const std::string& def = "");$/;"	p	class:Conf	access:public	signature:(const std::string& section, const std::string& name, char* value, const std::string& def = ”)
get	conf.h	/^	std::string& get(const std::string& section, const std::string& name, std::string& value, const std::string& def = "");$/;"	p	class:Conf	access:public	signature:(const std::string& section, const std::string& name, std::string& value, const std::string& def = ”)
get	sync_request.h	/^		int get(T t)$/;"	f	class:SyncRequest	access:public	signature:(T t)
get_day_of_week	util.cpp	/^uint32_t get_day_of_week(time_t stamp)$/;"	f	signature:(time_t stamp)
get_day_of_week	util.h	/^uint32_t get_day_of_week(time_t stamp);$/;"	p	signature:(time_t stamp)
get_three_bytes_int	wry.c	/^static inline unsigned int get_three_bytes_int(uint8_t* p)$/;"	f	file:	signature:(uint8_t* p)
get_usec_timestamp	util.cpp	/^uint64_t get_usec_timestamp()$/;"	f	signature:()
get_usec_timestamp	util.h	/^uint64_t get_usec_timestamp();$/;"	p	signature:()
get_ymd	util.cpp	/^uint32_t get_ymd(time_t stamp)$/;"	f	signature:(time_t stamp)
get_ymd	util.h	/^uint32_t get_ymd(time_t stamp);$/;"	p	signature:(time_t stamp)
getcpuspeed	optimized_time.h	/^static int getcpuspeed()$/;"	f	signature:()
getcpuspeed_mhz	optimized_time.h	/^static inline int getcpuspeed_mhz(unsigned int wait_us)$/;"	f	signature:(unsigned int wait_us)
h_C	http.c	/^  , h_C$/;"	e	enum:header_states	file:
h_CO	http.c	/^  , h_CO$/;"	e	enum:header_states	file:
h_CON	http.c	/^  , h_CON$/;"	e	enum:header_states	file:
h_connection	http.c	/^  , h_connection$/;"	e	enum:header_states	file:
h_connection_close	http.c	/^  , h_connection_close$/;"	e	enum:header_states	file:
h_connection_keep_alive	http.c	/^  , h_connection_keep_alive$/;"	e	enum:header_states	file:
h_content_length	http.c	/^  , h_content_length$/;"	e	enum:header_states	file:
h_general	http.c	/^  { h_general = 0$/;"	e	enum:header_states	file:
h_matching_connection	http.c	/^  , h_matching_connection$/;"	e	enum:header_states	file:
h_matching_connection_close	http.c	/^  , h_matching_connection_close$/;"	e	enum:header_states	file:
h_matching_connection_keep_alive	http.c	/^  , h_matching_connection_keep_alive$/;"	e	enum:header_states	file:
h_matching_content_length	http.c	/^  , h_matching_content_length$/;"	e	enum:header_states	file:
h_matching_proxy_connection	http.c	/^  , h_matching_proxy_connection$/;"	e	enum:header_states	file:
h_matching_transfer_encoding	http.c	/^  , h_matching_transfer_encoding$/;"	e	enum:header_states	file:
h_matching_transfer_encoding_chunked	http.c	/^  , h_matching_transfer_encoding_chunked$/;"	e	enum:header_states	file:
h_matching_upgrade	http.c	/^  , h_matching_upgrade$/;"	e	enum:header_states	file:
h_transfer_encoding	http.c	/^  , h_transfer_encoding$/;"	e	enum:header_states	file:
h_transfer_encoding_chunked	http.c	/^  , h_transfer_encoding_chunked$/;"	e	enum:header_states	file:
h_upgrade	http.c	/^  , h_upgrade$/;"	e	enum:header_states	file:
handle	timer.h	/^		inline void handle(function_type function)$/;"	f	class:nw_timer	access:public	signature:(function_type function)
handle	timer.h	/^		inline void handle(handler_type* handler, function_type function)$/;"	f	class:nw_timer	access:public	signature:(handler_type* handler, function_type function)
handle_func_t	timer.h	/^	typedef void (*handle_func_t)(self_t&);$/;"	t	class:nw_timer	access:private
handle_member_func_t	timer.h	/^	typedef void (handler_t::*handle_member_func_t)(self_t&);$/;"	t	class:nw_timer	access:private
handler_t	timer.h	/^	class handler_t { };$/;"	c	class:nw_timer	access:private
handler_t	ut_mysql.h	/^	class handler_t { };$/;"	c	class:ut_mysql	access:protected
head	wry.h	/^	struct wry_head head;$/;"	m	struct:wry_dict	typeref:struct:wry_dict::wry_head	access:public
header_state	http.h	/^  unsigned char header_state;$/;"	m	struct:http_parser	access:public
header_states	http.c	/^enum header_states$/;"	g	file:
hex2bin	ut_str.cpp	/^int hex2bin(void* bin_output, const void* hex, int hex_len)$/;"	f	signature:(void* bin_output, const void* hex, int hex_len)
hex2bin	ut_str.h	/^int hex2bin(void* bin_output, const void* hex, int hex_len);$/;"	p	signature:(void* bin_output, const void* hex, int hex_len)
hexdigest	md5.cpp	/^std::string MD5::hexdigest() const$/;"	f	class:MD5	signature:() const
hexdigest	md5.h	/^  std::string hexdigest() const;$/;"	p	class:MD5	access:public	signature:() const
htobe16	pack.c	72;"	d	file:
htobe16	pack.c	84;"	d	file:
htobe16	pack.c	91;"	d	file:
htobe32	pack.c	73;"	d	file:
htobe32	pack.c	85;"	d	file:
htobe32	pack.c	92;"	d	file:
htobe64	pack.c	74;"	d	file:
htobe64	pack.c	86;"	d	file:
htobe64	pack.c	93;"	d	file:
htobed	pack.c	122;"	d	file:
htobed	pack.c	127;"	d	file:
htobed	pack.c	76;"	d	file:
htobef	pack.c	121;"	d	file:
htobef	pack.c	126;"	d	file:
htobef	pack.c	75;"	d	file:
http_cb	http.h	/^typedef int (*http_cb) (http_parser*);$/;"	t
http_data_cb	http.h	/^typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);$/;"	t
http_errno	http.h	/^  unsigned char http_errno : 7;$/;"	m	struct:http_parser	access:public
http_errno	http.h	/^enum http_errno {$/;"	g
http_errno_description	http.c	/^http_errno_description(enum http_errno err) {$/;"	f	signature:(enum http_errno err)
http_errno_description	http.h	/^const char *http_errno_description(enum http_errno err);$/;"	p	signature:(enum http_errno err)
http_errno_name	http.c	/^http_errno_name(enum http_errno err) {$/;"	f	signature:(enum http_errno err)
http_errno_name	http.h	/^const char *http_errno_name(enum http_errno err);$/;"	p	signature:(enum http_errno err)
http_major	http.h	/^  unsigned short http_major;$/;"	m	struct:http_parser	access:public
http_method	http.h	/^enum http_method$/;"	g
http_method_str	http.c	/^const char * http_method_str (enum http_method m)$/;"	f	signature:(enum http_method m)
http_method_str	http.h	/^const char *http_method_str(enum http_method m);$/;"	p	signature:(enum http_method m)
http_minor	http.h	/^  unsigned short http_minor;$/;"	m	struct:http_parser	access:public
http_parser	http.h	/^struct http_parser {$/;"	s
http_parser	http.h	/^typedef struct http_parser http_parser;$/;"	t	typeref:struct:http_parser
http_parser::content_length	http.h	/^  int64_t content_length;$/;"	m	struct:http_parser	access:public
http_parser::data	http.h	/^  void *data; \/* A pointer to get hook to the "connection" or "socket" object *\/$/;"	m	struct:http_parser	access:public
http_parser::error_lineno	http.h	/^  uint32_t error_lineno;$/;"	m	struct:http_parser	access:public
http_parser::flags	http.h	/^  unsigned char flags : 6; \/* F_* values from 'flags' enum; semi-public *\/$/;"	m	struct:http_parser	access:public
http_parser::header_state	http.h	/^  unsigned char header_state;$/;"	m	struct:http_parser	access:public
http_parser::http_errno	http.h	/^  unsigned char http_errno : 7;$/;"	m	struct:http_parser	access:public
http_parser::http_major	http.h	/^  unsigned short http_major;$/;"	m	struct:http_parser	access:public
http_parser::http_minor	http.h	/^  unsigned short http_minor;$/;"	m	struct:http_parser	access:public
http_parser::index	http.h	/^  unsigned char index;$/;"	m	struct:http_parser	access:public
http_parser::method	http.h	/^  unsigned char method; \/* requests only *\/$/;"	m	struct:http_parser	access:public
http_parser::nread	http.h	/^  uint32_t nread;$/;"	m	struct:http_parser	access:public
http_parser::state	http.h	/^  unsigned char state;$/;"	m	struct:http_parser	access:public
http_parser::status_code	http.h	/^  unsigned short status_code; \/* responses only *\/$/;"	m	struct:http_parser	access:public
http_parser::type	http.h	/^  unsigned char type : 2;$/;"	m	struct:http_parser	access:public
http_parser::upgrade	http.h	/^  unsigned char upgrade : 1;$/;"	m	struct:http_parser	access:public
http_parser_execute	http.c	/^size_t http_parser_execute (http_parser *parser,$/;"	f	signature:(http_parser *parser, const http_parser_settings *settings, const char *data, size_t len)
http_parser_execute	http.h	/^size_t http_parser_execute(http_parser *parser,$/;"	p	signature:(http_parser *parser, const http_parser_settings *settings, const char *data, size_t len)
http_parser_init	http.c	/^http_parser_init (http_parser *parser, enum http_parser_type t)$/;"	f	signature:(http_parser *parser, enum http_parser_type t)
http_parser_init	http.h	/^void http_parser_init(http_parser *parser, enum http_parser_type type);$/;"	p	signature:(http_parser *parser, enum http_parser_type type)
http_parser_result	http.h	/^typedef struct http_parser_result http_parser_result;$/;"	t	typeref:struct:http_parser_result
http_parser_settings	http.h	/^struct http_parser_settings {$/;"	s
http_parser_settings	http.h	/^typedef struct http_parser_settings http_parser_settings;$/;"	t	typeref:struct:http_parser_settings
http_parser_settings::on_body	http.h	/^  http_data_cb on_body;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_header_field	http.h	/^  http_data_cb on_header_field;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_header_value	http.h	/^  http_data_cb on_header_value;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_headers_complete	http.h	/^  http_cb on_headers_complete;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_message_begin	http.h	/^  http_cb on_message_begin;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_message_complete	http.h	/^  http_cb on_message_complete;$/;"	m	struct:http_parser_settings	access:public
http_parser_settings::on_url	http.h	/^  http_data_cb on_url;$/;"	m	struct:http_parser_settings	access:public
http_parser_type	http.h	/^enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };$/;"	g
http_should_keep_alive	http.c	/^http_should_keep_alive (http_parser *parser)$/;"	f	signature:(http_parser *parser)
http_should_keep_alive	http.h	/^int http_should_keep_alive(http_parser *parser);$/;"	p	signature:(http_parser *parser)
http_strerror_tab	http.c	/^} http_strerror_tab[] = {$/;"	v	typeref:struct:__anon3	file:
iAttrId	Attr_API_Var.c	/^			int iAttrId;                                \/*  Ù–‘id *\/$/;"	m	struct:__anon9::__anon10::__anon11	file:	access:public
iInitRet	Attr_API.c	/^static int iInitRet = 0;$/;"	v	file:
iInitRet	Attr_API_Var.c	/^static int iInitRet = 0;$/;"	v	file:
iLastTime	Attr_API_Var.c	/^			int iLastTime;                              \/* ◊ÓΩ¸…œ±® ±º‰ *\/$/;"	m	struct:__anon9::__anon12::__anon13	file:	access:public
iValue	Attr_API_Var.c	/^			int iValue;                                 \/* ∂‘”¶µƒ÷µ *\/$/;"	m	struct:__anon9::__anon12::__anon13	file:	access:public
iVarKey	Attr_API_Var.c	/^			int iVarKey;                                \/* ±‰¡økey(ø…“‘Œ™∏∫ ˝) *\/$/;"	m	struct:__anon9::__anon10::__anon11	file:	access:public
in	crypt_md5.h	/^        unsigned char in[64];$/;"	m	struct:MD5Context	access:public
index	http.h	/^  unsigned char index;$/;"	m	struct:http_parser	access:public
index	utf8.h	/^    unsigned int index;$/;"	m	struct:__anon19	access:public
init	md5.cpp	/^void MD5::init()$/;"	f	class:MD5	signature:()
init	md5.h	/^  void init();$/;"	p	class:MD5	access:private	signature:()
init	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int init() {attrA = 5, attrB = 10; return 0;};$/;"	f	class:MyObject	access:public	signature:()
init	objpools/test_object_pool.cpp	/^		int init() {attrA = 5, attrB = 10; return 0;};$/;"	f	class:MyObject	access:public	signature:()
init	test/test.cpp	/^		void init()$/;"	f	class:Time	access:public	signature:()
init_json_escape_table	ut_str.cpp	/^static void init_json_escape_table()$/;"	f	file:	signature:()
ip_end	wry.h	/^	uint32_t ip_end;$/;"	m	struct:wry_index	access:public
ip_list	wry.h	/^	struct wry_index* ip_list;$/;"	m	struct:wry_dict	typeref:struct:wry_dict::wry_index	access:public
ip_list_size	wry.h	/^	int32_t ip_list_size;$/;"	m	struct:wry_dict	access:public
ip_start	wry.h	/^	uint32_t ip_start;$/;"	m	struct:wry_index	access:public
is_email	ut_str.h	/^bool is_email(const void* str, int32_t len);$/;"	p	signature:(const void* str, int32_t len)
is_err_cr_server_lost	ut_mysql.h	/^	inline static bool is_err_cr_server_lost(uint32_t code)$/;"	f	class:ut_mysql	access:public	signature:(uint32_t code)
is_err_key_dup	ut_mysql.h	/^	inline static bool is_err_key_dup(uint32_t code)$/;"	f	class:ut_mysql	access:public	signature:(uint32_t code)
is_hex	ut_str.cpp	/^bool is_hex(const void* str, int len)$/;"	f	signature:(const void* str, int len)
is_hex	ut_str.h	/^bool is_hex(const void* str, int len);$/;"	p	signature:(const void* str, int len)
is_integer	ut_str.cpp	/^bool is_integer(const void* str, int len)$/;"	f	signature:(const void* str, int len)
is_integer	ut_str.h	/^bool is_integer(const void* str, int len);$/;"	p	signature:(const void* str, int len)
is_same_day	RollLog.h	/^	bool is_same_day(time_t t1,time_t t2);$/;"	p	class:CDayLog	access:protected	signature:(time_t t1,time_t t2)
is_viewable_ascii	ut_str.h	/^inline bool is_viewable_ascii(uint32_t ch) { return ch>=32 && ch<=126; }$/;"	f	signature:(uint32_t ch)
isodate_to_stamp	mongoc_json.cpp	/^uint32_t   isodate_to_stamp(Json::Value& r)$/;"	f	signature:(Json::Value& r)
isodate_to_stamp	mongoc_json.h	/^uint32_t   isodate_to_stamp(Json::Value& r);$/;"	p	signature:(Json::Value& r)
json_escape_t	ut_str.cpp	/^union json_escape_t$/;"	u	file:
json_escape_t::_n	ut_str.cpp	/^	char _n[2];$/;"	m	union:json_escape_t	file:	access:public
json_escape_t::_v	ut_str.cpp	/^	uint16_t _v;$/;"	m	union:json_escape_t	file:	access:public
key_number	Attr_API_Var.c	/^		uint64_t key_number;$/;"	m	union:__anon9::__anon10	file:	access:public
last_index_offset	wry.h	/^	int32_t last_index_offset;$/;"	m	struct:wry_head	access:public
last_insert_id	ut_mysql.h	/^	inline uint64_t last_insert_id() { return static_cast<uint64_t>(mysql_insert_id(&_mysql)); }$/;"	f	class:ut_mysql	access:public	signature:()
length	utf8.h	/^    unsigned int length;$/;"	m	struct:__anon19	access:public
load	conf.cpp	/^bool Conf::load(const std::string& file_name)$/;"	f	class:Conf	signature:(const std::string& file_name)
load	conf.h	/^	bool load(const std::string& file_name);$/;"	p	class:Conf	access:public	signature:(const std::string& file_name)
load_data_from_stream	conf.cpp	/^bool Conf::load_data_from_stream(std::basic_istream<char>& ifs)$/;"	f	class:Conf	signature:(std::basic_istream<char>& ifs)
load_data_from_stream	conf.h	/^	bool load_data_from_stream(std::basic_istream<char>& stream);$/;"	p	class:Conf	access:private	signature:(std::basic_istream<char>& stream)
location	wry.h	/^	struct wry_loc location;$/;"	m	struct:wry_index	typeref:struct:wry_index::wry_loc	access:public
location_mem	wry.h	/^	uint8_t* location_mem;$/;"	m	struct:wry_dict	access:public
location_mem_len	wry.h	/^	int32_t location_mem_len;$/;"	m	struct:wry_dict	access:public
lock	Attr_API.c	/^static spinlock_t lock = SPINLOCK_INITIALIZER;$/;"	v	file:
lock	Attr_API_Var.c	/^static spinlock_t lock = SPINLOCK_INITIALIZER;$/;"	v	file:
log_handler	mongoc_json.cpp	/^static void log_handler (mongoc_log_level_t  log_level, const char* log_domain, const char* message, void* user_data)$/;"	f	file:	signature:(mongoc_log_level_t log_level, const char* log_domain, const char* message, void* user_data)
m_client	mongoc_json.h	/^		mongoc_client_t*		m_client;		\/\/ÂÆ¢Êà∑Á´Ø$/;"	m	class:CMongodb	access:private
m_collection	mongoc_json.h	/^		mongoc_collection_t*	m_collection;	\/\/Êü•ËØ¢ÈõÜÂêà$/;"	m	class:CMongodb	access:private
m_connected	mongoc_json.h	/^		bool					m_connected;	\/\/ÊòØÂê¶ËøûÊé•Áä∂ÊÄÅ$/;"	m	class:CMongodb	access:private
m_cursor	mongoc_json.h	/^		mongoc_cursor_t*		m_cursor;		\/\/Êü•ËØ¢Êó∂ÁöÑÊ∏∏Ê†á$/;"	m	class:CMongodb	access:private
m_db	mongoc_json.h	/^		string					m_db;			\/\/dbÂêçÂ≠ó$/;"	m	class:CMongodb	access:private
m_error	mongoc_json.h	/^		bson_error_t 			m_error;			\/\/ÈîôËØØ‰ø°ÊÅØÂ≠òÂÇ®$/;"	m	class:CMongodb	access:private
m_iFile	file_lock.h	/^    int m_iFile;$/;"	m	class:CFileLock	access:private
m_instance	mongoc_json.cpp	/^CMongodb*    CMongodb::m_instance = NULL;	$/;"	m	class:CMongodb	file:
m_instance	mongoc_json.h	/^		static CMongodb*    m_instance;	$/;"	m	class:CMongodb	access:private
m_pjson	mongoc_json.h	/^		char* 					m_pjson;		\/\/Êü•ËØ¢next‰πãÂêéÁöÑÂÜÖÂ≠ò $/;"	m	class:CMongodb	access:private
m_query	mongoc_json.h	/^		const bson_t*			m_query;		\/\/bson_t queryÂØπË±°$/;"	m	class:CMongodb	access:private
m_result	mongoc_json.h	/^		 bson_t*				m_result;		\/\/bson_t queryÂØπË±°$/;"	m	class:CMongodb	access:private
m_uri	mongoc_json.h	/^		string					m_uri;			\/\/mongodbËøûÊé•Âú∞ÂùÄ$/;"	m	class:CMongodb	access:private
main	crypt_3des.c	/^int main( void )$/;"	f	signature:( void )
main	crypt_sha1.c	/^int main( int argc, char *argv[] )$/;"	f	signature:( int argc, char *argv[] )
main	crypt_sha256.c	/^int main( int argc, char *argv[] )$/;"	f	signature:( int argc, char *argv[] )
main	objpools/objectpool/examples/test_multi_object_pool.cpp	/^int main()$/;"	f	signature:()
main	objpools/test_object_pool.cpp	/^int main()$/;"	f	signature:()
main	test/test.cpp	/^int main(int argv, char* argc[])$/;"	f	signature:(int argv, char* argc[])
md5	md5.cpp	/^std::string md5(const std::string str)$/;"	f	signature:(const std::string str)
md5	md5.h	/^std::string md5(const std::string str);$/;"	p	signature:(const std::string str)
mem2lower	ut_str.cpp	/^void mem2lower(void* output, const void* input, int len)$/;"	f	signature:(void* output, const void* input, int len)
mem2lower	ut_str.h	/^void mem2lower(void* output, const void* input, int len);$/;"	p	signature:(void* output, const void* input, int len)
mem2upper	ut_str.cpp	/^void mem2upper(void* output, const void* input, int len)$/;"	f	signature:(void* output, const void* input, int len)
mem2upper	ut_str.h	/^void mem2upper(void* output, const void* input, int len);$/;"	p	signature:(void* output, const void* input, int len)
memstr	ut_str.cpp	/^void* memstr(const void* haystack, int haystack_size, const char* needle)$/;"	f	signature:(const void* haystack, int haystack_size, const char* needle)
memstr	ut_str.h	/^void* memstr(const void* haystack, int haystack_size, const char* needle);$/;"	p	signature:(const void* haystack, int haystack_size, const char* needle)
method	http.h	/^  unsigned char method; \/* requests only *\/$/;"	m	struct:http_parser	access:public
method_strings	http.c	/^static const char *method_strings[] =$/;"	v	file:
mod_table	base64.c	/^static int mod_table[] = {0, 2, 1};$/;"	v	file:
msg	crypt_sha1.c	/^static char *msg[] =$/;"	v	file:
msg	crypt_sha256.c	/^static char *msg[] =$/;"	v	file:
msleep	util.h	/^inline void msleep(uint32_t t)$/;"	f	signature:(uint32_t t)
name	http.c	/^  const char *name;$/;"	m	struct:__anon3	file:	access:public
nation	wry.h	/^	uint8_t* nation;$/;"	m	struct:wry_loc	access:public
nation_len	wry.h	/^	uint8_t nation_len;$/;"	m	struct:wry_loc	access:public
next	ut_mysql.cpp	/^bool ut_mysql::next()$/;"	f	class:ut_mysql	signature:()
next	ut_mysql.cpp	/^bool ut_mysql::next(MYSQL_STMT* stmt)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt)
next	ut_mysql.h	/^	bool next();$/;"	p	class:ut_mysql	access:public	signature:()
next	ut_mysql.h	/^	bool next(MYSQL_STMT* stmt);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
next	ut_str.h	/^	unsigned char* next;$/;"	m	struct:__anon23	access:public
nolog	RollLog.h	/^	friend CRollLog& nolog(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
nolog	RollLog.h	/^inline CRollLog& nolog(CRollLog& log)$/;"	f	signature:(CRollLog& log)
normal	RollLog.h	/^	friend CRollLog& normal(CRollLog& log);$/;"	p	class:CRollLog	access:friend	signature:(CRollLog& log)
normal	RollLog.h	/^inline CRollLog& normal(CRollLog& log)$/;"	f	signature:(CRollLog& log)
normal_url_char	http.c	/^static const uint8_t normal_url_char[256] = {$/;"	v	file:
nread	http.h	/^  uint32_t nread;$/;"	m	struct:http_parser	access:public
number_value	Attr_API.c	/^	uint64_t number_value;$/;"	m	union:__anon24	file:	access:public
nw_timer	timer.h	/^	inline nw_timer():_hdlr(NULL), _arg(NULL), _repeat(false), _hh(-1), _mm(-1){ memset(&_cb, 0, sizeof(_cb)); _tv_front =0; _exec=false; _wait=0;}$/;"	f	class:nw_timer	access:public	signature:()
nw_timer	timer.h	/^class nw_timer$/;"	c
nw_timer::__anon18::_member_function	timer.h	/^		handle_member_func_t _member_function;$/;"	m	union:nw_timer::__anon18	access:public
nw_timer::__anon18::_static_function	timer.h	/^		handle_func_t _static_function;$/;"	m	union:nw_timer::__anon18	access:public
nw_timer::__call	timer.h	/^	inline void __call()$/;"	f	class:nw_timer	access:public	signature:()
nw_timer::_arg	timer.h	/^	void* _arg;$/;"	m	class:nw_timer	access:private
nw_timer::_cb	timer.h	/^	}_cb;$/;"	m	class:nw_timer	typeref:union:nw_timer::__anon18	access:private
nw_timer::_exec	timer.h	/^	bool	 _exec;			\/\/ÊâßË°åÊ†áÂøó$/;"	m	class:nw_timer	access:private
nw_timer::_hdlr	timer.h	/^	handler_t* _hdlr;$/;"	m	class:nw_timer	access:private
nw_timer::_hh	timer.h	/^	int _hh;$/;"	m	class:nw_timer	access:private
nw_timer::_mm	timer.h	/^	int _mm;$/;"	m	class:nw_timer	access:private
nw_timer::_repeat	timer.h	/^	bool _repeat;$/;"	m	class:nw_timer	access:private
nw_timer::_running	timer.h	/^	bool _running;$/;"	m	class:nw_timer	access:private
nw_timer::_tv	timer.h	/^	double _tv;				\/\/ÂÆöÊó∂Âô®Èó¥Èöî$/;"	m	class:nw_timer	access:private
nw_timer::_tv_front	timer.h	/^	uint64_t _tv_front;		\/\/‰∏ä‰∏ÄÊ¨°ÊâßË°åÊó∂Èó¥$/;"	m	class:nw_timer	access:private
nw_timer::_wait	timer.h	/^	uint32_t _wait;			\/\/Á¨¨‰∏ÄÊ¨°Á≠âÂæÖÊó∂Èïø$/;"	m	class:nw_timer	access:private
nw_timer::arg	timer.h	/^	inline void arg(void* p) { _arg = p; }$/;"	f	class:nw_timer	access:public	signature:(void* p)
nw_timer::arg	timer.h	/^	inline void* arg(void) const { return _arg; }$/;"	f	class:nw_timer	access:public	signature:(void) const
nw_timer::check	timer.h	/^	inline void check()$/;"	f	class:nw_timer	access:public	signature:()
nw_timer::handle	timer.h	/^		inline void handle(function_type function)$/;"	f	class:nw_timer	access:public	signature:(function_type function)
nw_timer::handle	timer.h	/^		inline void handle(handler_type* handler, function_type function)$/;"	f	class:nw_timer	access:public	signature:(handler_type* handler, function_type function)
nw_timer::handle_func_t	timer.h	/^	typedef void (*handle_func_t)(self_t&);$/;"	t	class:nw_timer	access:private
nw_timer::handle_member_func_t	timer.h	/^	typedef void (handler_t::*handle_member_func_t)(self_t&);$/;"	t	class:nw_timer	access:private
nw_timer::handler_t	timer.h	/^	class handler_t { };$/;"	c	class:nw_timer	access:private
nw_timer::nw_timer	timer.h	/^	inline nw_timer():_hdlr(NULL), _arg(NULL), _repeat(false), _hh(-1), _mm(-1){ memset(&_cb, 0, sizeof(_cb)); _tv_front =0; _exec=false; _wait=0;}$/;"	f	class:nw_timer	access:public	signature:()
nw_timer::real_set	timer.h	/^	inline void real_set(double tv, handle_func_t static_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)$/;"	f	class:nw_timer	access:private	signature:(double tv, handle_func_t static_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)
nw_timer::real_set	timer.h	/^	inline void real_set(double tv, handler_t* handler, handle_member_func_t member_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)$/;"	f	class:nw_timer	access:private	signature:(double tv, handler_t* handler, handle_member_func_t member_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)
nw_timer::repeat	timer.h	/^	inline bool repeat() { return _repeat; }$/;"	f	class:nw_timer	access:public	signature:()
nw_timer::repeat	timer.h	/^	inline void repeat(bool b) { _repeat = b; }$/;"	f	class:nw_timer	access:public	signature:(bool b)
nw_timer::reset	timer.h	/^	void reset()$/;"	f	class:nw_timer	access:public	signature:()
nw_timer::self_t	timer.h	/^	typedef nw_timer self_t;$/;"	t	class:nw_timer	access:private
nw_timer::set	timer.h	/^		inline void set(double tv, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)$/;"	f	class:nw_timer	access:public	signature:(double tv, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)
nw_timer::set	timer.h	/^		inline void set(double tv, handler_type* handler, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)$/;"	f	class:nw_timer	access:public	signature:(double tv, handler_type* handler, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)
nw_timer::set_fail	timer.h	/^	void set_fail() { _exec = false;}$/;"	f	class:nw_timer	access:public	signature:()
nw_timer::set_succ	timer.h	/^	void set_succ() { _exec = true;}$/;"	f	class:nw_timer	access:public	signature:()
nw_timer::~nw_timer	timer.h	/^	~nw_timer() { }$/;"	f	class:nw_timer	access:public	signature:()
offset	wry.h	/^	int32_t offset;$/;"	m	struct:wry_index	access:public
oi_symmetry_decrypt	crypt_tea.cpp	/^bool oi_symmetry_decrypt(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)$/;"	f	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
oi_symmetry_decrypt	crypt_tea.h	/^bool oi_symmetry_decrypt(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen);$/;"	p	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
oi_symmetry_decrypt2	crypt_tea.cpp	/^bool oi_symmetry_decrypt2(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)$/;"	f	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
oi_symmetry_decrypt2	crypt_tea.h	/^bool oi_symmetry_decrypt2(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen);$/;"	p	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
oi_symmetry_encrypt	crypt_tea.cpp	/^void oi_symmetry_encrypt(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)$/;"	f	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
oi_symmetry_encrypt	crypt_tea.h	/^void oi_symmetry_encrypt(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen);$/;"	p	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
oi_symmetry_encrypt2	crypt_tea.cpp	/^void oi_symmetry_encrypt2(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)$/;"	f	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
oi_symmetry_encrypt2	crypt_tea.h	/^void oi_symmetry_encrypt2(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen);$/;"	p	signature:(const uint8_t* pInBuf, int nInBufLen, const uint8_t* pKey, uint8_t* pOutBuf, int *pOutBufLen)
on_body	http.h	/^  http_data_cb on_body;$/;"	m	struct:http_parser_settings	access:public
on_connect	ut_mysql.cpp	/^void ut_mysql::on_connect()$/;"	f	class:ut_mysql	signature:()
on_connect	ut_mysql.h	/^	virtual void on_connect();$/;"	p	class:ut_mysql	access:protected	signature:()
on_disconnect	ut_mysql.cpp	/^void ut_mysql::on_disconnect()$/;"	f	class:ut_mysql	signature:()
on_disconnect	ut_mysql.h	/^	virtual void on_disconnect();$/;"	p	class:ut_mysql	access:protected	signature:()
on_header_field	http.h	/^  http_data_cb on_header_field;$/;"	m	struct:http_parser_settings	access:public
on_header_value	http.h	/^  http_data_cb on_header_value;$/;"	m	struct:http_parser_settings	access:public
on_headers_complete	http.h	/^  http_cb on_headers_complete;$/;"	m	struct:http_parser_settings	access:public
on_message_begin	http.h	/^  http_cb on_message_begin;$/;"	m	struct:http_parser_settings	access:public
on_message_complete	http.h	/^  http_cb on_message_complete;$/;"	m	struct:http_parser_settings	access:public
on_mysql_options	ut_mysql.cpp	/^void ut_mysql::on_mysql_options()$/;"	f	class:ut_mysql	signature:()
on_mysql_options	ut_mysql.h	/^	virtual void on_mysql_options();$/;"	p	class:ut_mysql	access:protected	signature:()
on_url	http.h	/^  http_data_cb on_url;$/;"	m	struct:http_parser_settings	access:public
op_printf	object_pool.h	/^int op_printf(char const *fmt, ...)$/;"	f	signature:(char const *fmt, ...)
operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data!=v[0]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._s._u16!=*reinterpret_cast<const uint16_t*>(v) || _data._s._u8!=v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._u16!=*reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._u32!=*reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._u64!=*reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(strlen(v)!=bytes_len) return true; return 0!=memcmp(_data,v,bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return 0!=memcmp(_data, rhs._data, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data!=rhs._data; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._s._u16!=rhs._data._s._u16 && _data._s._u8==rhs._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._u16!=rhs._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._u32!=rhs._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._u64!=rhs._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator !=	byte.h	/^	inline bool operator!=(const ut_buf& buf) const { return !(*this==buf); }$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf) const
operator !=	byte.h	/^	inline bool operator!=(const ut_bytes& rhs) const { return _len!=rhs._len || 0!=memcmp(_data, rhs._data, _len); }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& rhs) const
operator ()	multi_object_pool.h	/^    TObjectPool* operator () ( string opname )$/;"	f	struct:__DefaultMultiPoolConstructor	access:public	signature:( string opname )
operator ()	object_pool.h	/^    TObject* operator () ( )$/;"	f	struct:__DefaultPoolConstructor	access:public	signature:( )
operator ()	objpools/objectpool/examples/test_multi_object_pool.cpp	/^	MyObject* operator()()$/;"	f	struct:MyObjectPoolConstructor	access:public	signature:()
operator ()	objpools/objectpool/examples/test_multi_object_pool.cpp	/^	MyObjectPool* operator () ( std::string gname)$/;"	f	struct:MyMultiMyObjectPoolConstructor	access:public	signature:( std::string gname)
operator ()	objpools/test_object_pool.cpp	/^	MyObject* operator()()$/;"	f	struct:MyObjectPoolConstructor	access:public	signature:()
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(char n)$/;"	f	class:CDayLog	signature:(char n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(const string& s)$/;"	f	class:CDayLog	signature:(const string& s)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(double n)$/;"	f	class:CDayLog	signature:(double n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(float n)$/;"	f	class:CDayLog	signature:(float n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(int n)$/;"	f	class:CDayLog	signature:(int n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(long long n)$/;"	f	class:CDayLog	signature:(long long n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(long n)$/;"	f	class:CDayLog	signature:(long n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(short n)$/;"	f	class:CDayLog	signature:(short n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned char n) $/;"	f	class:CDayLog	signature:(unsigned char n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned int n)$/;"	f	class:CDayLog	signature:(unsigned int n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned long long n)$/;"	f	class:CDayLog	signature:(unsigned long long n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned long n)$/;"	f	class:CDayLog	signature:(unsigned long n)
operator <<	RollLog.cpp	/^CDayLog& CDayLog::operator<<(unsigned short n)$/;"	f	class:CDayLog	signature:(unsigned short n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(char n)$/;"	f	class:CRollLog	signature:(char n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(const string& s)$/;"	f	class:CRollLog	signature:(const string& s)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(double n)$/;"	f	class:CRollLog	signature:(double n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(float n)$/;"	f	class:CRollLog	signature:(float n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(int n)$/;"	f	class:CRollLog	signature:(int n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(long long n)$/;"	f	class:CRollLog	signature:(long long n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(long n)$/;"	f	class:CRollLog	signature:(long n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(short n)$/;"	f	class:CRollLog	signature:(short n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned char n) $/;"	f	class:CRollLog	signature:(unsigned char n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned int n)$/;"	f	class:CRollLog	signature:(unsigned int n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned long long n)$/;"	f	class:CRollLog	signature:(unsigned long long n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned long n)$/;"	f	class:CRollLog	signature:(unsigned long n)
operator <<	RollLog.cpp	/^CRollLog& CRollLog::operator<<(unsigned short n)$/;"	f	class:CRollLog	signature:(unsigned short n)
operator <<	RollLog.h	/^	CDayLog& operator<<(__Day_Func func){ return (*func)(*this);}$/;"	f	class:CDayLog	access:public	signature:(__Day_Func func)
operator <<	RollLog.h	/^	CDayLog& operator<<(char n);$/;"	p	class:CDayLog	access:public	signature:(char n)
operator <<	RollLog.h	/^	CDayLog& operator<<(const std::string& s);$/;"	p	class:CDayLog	access:public	signature:(const std::string& s)
operator <<	RollLog.h	/^	CDayLog& operator<<(double n);$/;"	p	class:CDayLog	access:public	signature:(double n)
operator <<	RollLog.h	/^	CDayLog& operator<<(float n);$/;"	p	class:CDayLog	access:public	signature:(float n)
operator <<	RollLog.h	/^	CDayLog& operator<<(int n);$/;"	p	class:CDayLog	access:public	signature:(int n)
operator <<	RollLog.h	/^	CDayLog& operator<<(long long n);$/;"	p	class:CDayLog	access:public	signature:(long long n)
operator <<	RollLog.h	/^	CDayLog& operator<<(long n);$/;"	p	class:CDayLog	access:public	signature:(long n)
operator <<	RollLog.h	/^	CDayLog& operator<<(short n);$/;"	p	class:CDayLog	access:public	signature:(short n)
operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned char n);$/;"	p	class:CDayLog	access:public	signature:(unsigned char n)
operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned int n);$/;"	p	class:CDayLog	access:public	signature:(unsigned int n)
operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned long long n);$/;"	p	class:CDayLog	access:public	signature:(unsigned long long n)
operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned long n);$/;"	p	class:CDayLog	access:public	signature:(unsigned long n)
operator <<	RollLog.h	/^	CDayLog& operator<<(unsigned short n);$/;"	p	class:CDayLog	access:public	signature:(unsigned short n)
operator <<	RollLog.h	/^	CRollLog& operator<<(__Roll_Func func){ return (*func)(*this);}$/;"	f	class:CRollLog	access:public	signature:(__Roll_Func func)
operator <<	RollLog.h	/^	CRollLog& operator<<(char n);$/;"	p	class:CRollLog	access:public	signature:(char n)
operator <<	RollLog.h	/^	CRollLog& operator<<(const std::string& s);$/;"	p	class:CRollLog	access:public	signature:(const std::string& s)
operator <<	RollLog.h	/^	CRollLog& operator<<(double n);$/;"	p	class:CRollLog	access:public	signature:(double n)
operator <<	RollLog.h	/^	CRollLog& operator<<(float n);$/;"	p	class:CRollLog	access:public	signature:(float n)
operator <<	RollLog.h	/^	CRollLog& operator<<(int n);$/;"	p	class:CRollLog	access:public	signature:(int n)
operator <<	RollLog.h	/^	CRollLog& operator<<(long long n);$/;"	p	class:CRollLog	access:public	signature:(long long n)
operator <<	RollLog.h	/^	CRollLog& operator<<(long n);$/;"	p	class:CRollLog	access:public	signature:(long n)
operator <<	RollLog.h	/^	CRollLog& operator<<(short n);$/;"	p	class:CRollLog	access:public	signature:(short n)
operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned char n);$/;"	p	class:CRollLog	access:public	signature:(unsigned char n)
operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned int n);$/;"	p	class:CRollLog	access:public	signature:(unsigned int n)
operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned long long n);$/;"	p	class:CRollLog	access:public	signature:(unsigned long long n)
operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned long n);$/;"	p	class:CRollLog	access:public	signature:(unsigned long n)
operator <<	RollLog.h	/^	CRollLog& operator<<(unsigned short n);$/;"	p	class:CRollLog	access:public	signature:(unsigned short n)
operator <<	md5.cpp	/^std::ostream& operator<<(std::ostream& out, MD5 md5)$/;"	f	signature:(std::ostream& out, MD5 md5)
operator <<	md5.h	/^  friend std::ostream& operator<<(std::ostream&, MD5 md5);$/;"	p	class:MD5	access:friend	signature:(std::ostream&, MD5 md5)
operator =	byte.h	/^	inline void operator=(const self_t& block) { *reinterpret_cast<base_t*>(this) = *reinterpret_cast<const base_t*>(&block);\/*memcpy(base_t::_data, block._data, bytes_len);*\/ }$/;"	f	struct:ut_block_uint32	access:public	signature:(const self_t& block)
operator =	byte.h	/^	inline void operator=(const self_t& block) { _data = block._data; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._s._u16 = block._data._s._u16; _data._s._u8 = block._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._u16 = block._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._u32 = block._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._u64 = block._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
operator =	byte.h	/^	inline void operator=(const self_t& block) { memcpy(_data, block._data, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
operator =	byte.h	/^	inline void operator=(const std::string& str) { *reinterpret_cast<base_t*>(this) = str;\/*memcpy(base_t::_data, str.c_str(), bytes_len);*\/ }$/;"	f	struct:ut_block_uint32	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const std::string& str) { _data = str.c_str()[0]; }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const std::string& str) { _data._u16 = *reinterpret_cast<const uint16_t*>(str.c_str()); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const std::string& str) { _data._u32 = *reinterpret_cast<const uint32_t*>(str.c_str()); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const std::string& str) { _data._u64 = *reinterpret_cast<const uint64_t*>(str.c_str()); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const std::string& str) { const char* v = str.c_str(); _data._s._u16 = *reinterpret_cast<const uint16_t*>(v); _data._s._u8 = v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const std::string& str) { memcpy(_data, str.c_str(), _len=str.size()); }$/;"	f	struct:ut_buf	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const std::string& str) { memcpy(_data, str.c_str(), bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._s._u16 = *reinterpret_cast<const uint16_t*>(v); _data._s._u8 = v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._u16 = *reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._u32 = *reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._u64 = *reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
operator =	byte.h	/^	inline void operator=(const ut_buf& buf) { memcpy(_data, buf._data, _len=buf._len); }$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf)
operator =	byte.h	/^	inline void operator=(const ut_bytes& bytes) { _data = bytes._data; _len = bytes._len; }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& bytes)
operator =	byte.h	/^	inline void operator=(const void* v) { *reinterpret_cast<base_t*>(this) = (const uint8_t*)v;\/*memcpy(base_t::_data, v, bytes_len);*\/ }$/;"	f	struct:ut_block_uint32	access:public	signature:(const void* v)
operator =	byte.h	/^	inline void operator=(const void* v) { _data = ((const uint8_t*)v)[0]; }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
operator =	byte.h	/^	inline void operator=(const void* v) { memcpy(_data, v, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
operator =	byte.h	/^	void operator=(const uint32_t v) { util_u322n(v, base_t::data(), bytes_len); }$/;"	f	struct:ut_block_uint32	access:public	signature:(const uint32_t v)
operator =	ut_mysql.h	/^	ut_mysql& operator=(const ut_mysql& rhs);$/;"	p	class:ut_mysql	access:private	signature:(const ut_mysql& rhs)
operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._s._u16==*reinterpret_cast<const uint16_t*>(v) && _data._s._u8==v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._u16==*reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._u32==*reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._u64==*reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data==v[0]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(strlen(v)!=bytes_len) return false; return 0==memcmp(_data,v,bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return 0==memcmp(_data, rhs._data, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._s._u16==rhs._data._s._u16 && _data._s._u8==rhs._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._u16==rhs._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._u32==rhs._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._u64==rhs._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data==rhs._data; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
operator ==	byte.h	/^	inline bool operator==(const ut_buf& buf) const$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf) const
operator ==	byte.h	/^	inline bool operator==(const ut_bytes& rhs) const { return _len==rhs._len && 0==memcmp(_data, rhs._data, _len); }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& rhs) const
optimezed_gettimeofday	optimized_time.h	/^static int optimezed_gettimeofday(struct timeval *tv)$/;"	f	signature:(struct timeval *tv)
optimized_time	optimized_time.h	/^static inline time_t optimized_time(time_t* pt)$/;"	f	signature:(time_t* pt)
out	test/test.cpp	/^		void out(){$/;"	f	class:TT	access:public	signature:()
p	singleton.h	/^		static T* p;$/;"	m	class:Singleton	access:private
p	singleton.h	/^T* Singleton<T>::p = new T;$/;"	m	class:Singleton
packf	pack.c	/^int packf(void *dest, size_t max, char const *format, ...)$/;"	f	signature:(void *dest, size_t max, char const *format, ...)
packf	pack.h	/^extern int packf(void *dest, size_t max, char const *format, ...);$/;"	p	signature:(void *dest, size_t max, char const *format, ...)
packf_error_format	pack.c	/^char *packf_error_format = NULL;$/;"	v
packf_print_error	pack.c	/^int packf_print_error = 0;$/;"	v
parse	conf.cpp	/^bool Conf::parse(const std::string& data)$/;"	f	class:Conf	signature:(const std::string& data)
parse	conf.h	/^	bool parse(const std::string& data);$/;"	p	class:Conf	access:public	signature:(const std::string& data)
patn	ut_str.h	/^	unsigned char* patn;$/;"	m	struct:__anon23	access:public
patn_len	ut_str.h	/^	int patn_len;$/;"	m	struct:__anon23	access:public
ping	ut_mysql.cpp	/^bool ut_mysql::ping()$/;"	f	class:ut_mysql	signature:()
ping	ut_mysql.h	/^	bool ping();$/;"	p	class:ut_mysql	access:public	signature:()
pinyin_all_pinyin	py.c	/^static const char *pinyin_all_pinyin[412] = {$/;"	v	file:
pinyin_count	py.c	/^static const char pinyin_count[20903] = {$/;"	v	file:
pinyin_index	py.c	/^static const char *pinyin_index[20903] = {$/;"	v	file:
pinyin_isabc	py.c	5331;"	d	file:
pinyin_ishanzi	py.c	5330;"	d	file:
pinyin_lowercase	py.c	5332;"	d	file:
pkcs7_depad	crypto.h	/^inline uint32_t pkcs7_depad(const void* data, uint32_t len) { return len - ((const uint8_t*)data)[len-1]; }$/;"	f	signature:(const void* data, uint32_t len)
pkcs7_pad	crypto.h	/^inline uint8_t pkcs7_pad(uint32_t len, uint8_t block_size) { return block_size - len%block_size; }$/;"	f	signature:(uint32_t len, uint8_t block_size)
py_get	py.c	/^int py_get(wchar_t uni, const char* pinyins[4])$/;"	f	signature:(wchar_t uni, const char* pinyins[4])
py_get	py.h	/^int py_get(wchar_t uni, const char* pinyins[4]);$/;"	p	signature:(wchar_t uni, const char* pinyins[4])
py_get_string	py.c	/^void py_get_string(py_handle* hdl)$/;"	f	signature:(py_handle* hdl)
py_get_string	py.h	/^void py_get_string(py_handle* hdl);$/;"	p	signature:(py_handle* hdl)
py_handle	py.h	/^}py_handle;$/;"	t	typeref:struct:__anon22
query	ut_mysql.cpp	/^bool ut_mysql::query(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind)
query	ut_mysql.cpp	/^bool ut_mysql::query(const char* sql, uint32_t len)$/;"	f	class:ut_mysql	signature:(const char* sql, uint32_t len)
query	ut_mysql.h	/^	bool query(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind)
query	ut_mysql.h	/^	bool query(const char* sql, uint32_t len);$/;"	p	class:ut_mysql	access:public	signature:(const char* sql, uint32_t len)
real_set	timer.h	/^	inline void real_set(double tv, handle_func_t static_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)$/;"	f	class:nw_timer	access:private	signature:(double tv, handle_func_t static_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)
real_set	timer.h	/^	inline void real_set(double tv, handler_t* handler, handle_member_func_t member_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)$/;"	f	class:nw_timer	access:private	signature:(double tv, handler_t* handler, handle_member_func_t member_function, void* arg, bool repeat, int hh, int mm, uint32_t wait)
real_set_on_connect	ut_mysql.h	/^	inline void real_set_on_connect(handler_t* handler, void(handler_t::*member_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(handler_t* handler, void(handler_t::*member_function)(self_t*))
real_set_on_connect	ut_mysql.h	/^	inline void real_set_on_connect(void(*static_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(void(*static_function)(self_t*))
real_set_on_disconnect	ut_mysql.h	/^	inline void real_set_on_disconnect(handler_t* handler, void(handler_t::*member_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(handler_t* handler, void(handler_t::*member_function)(self_t*))
real_set_on_disconnect	ut_mysql.h	/^	inline void real_set_on_disconnect(void(*static_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(void(*static_function)(self_t*))
real_set_on_mysql_options	ut_mysql.h	/^	inline void real_set_on_mysql_options(handler_t* handler, void(handler_t::*member_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(handler_t* handler, void(handler_t::*member_function)(self_t*))
real_set_on_mysql_options	ut_mysql.h	/^	inline void real_set_on_mysql_options(void(*static_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(void(*static_function)(self_t*))
repeat	timer.h	/^	inline bool repeat() { return _repeat; }$/;"	f	class:nw_timer	access:public	signature:()
repeat	timer.h	/^	inline void repeat(bool b) { _repeat = b; }$/;"	f	class:nw_timer	access:public	signature:(bool b)
reset	timer.h	/^	void reset()$/;"	f	class:nw_timer	access:public	signature:()
rotate_left	md5.cpp	/^inline MD5::uint4 MD5::rotate_left(uint4 x, int n) {$/;"	f	class:MD5	signature:(uint4 x, int n)
rotate_left	md5.h	/^  static inline uint4 rotate_left(uint4 x, int n);$/;"	p	class:MD5	access:private	signature:(uint4 x, int n)
row_count	ut_mysql.h	/^	inline uint64_t row_count() const { return _execute_result? _row_count : 0ull; }$/;"	f	class:ut_mysql	access:public	signature:() const
rpos	fifo.h	/^	int rpos;	\/\/\/ the read position$/;"	m	struct:__anon1	access:public
s_body_identity	http.c	/^  , s_body_identity$/;"	e	enum:state	file:
s_body_identity_eof	http.c	/^  , s_body_identity_eof$/;"	e	enum:state	file:
s_chunk_data	http.c	/^  , s_chunk_data$/;"	e	enum:state	file:
s_chunk_data_almost_done	http.c	/^  , s_chunk_data_almost_done$/;"	e	enum:state	file:
s_chunk_data_done	http.c	/^  , s_chunk_data_done$/;"	e	enum:state	file:
s_chunk_parameters	http.c	/^  , s_chunk_parameters$/;"	e	enum:state	file:
s_chunk_size	http.c	/^  , s_chunk_size$/;"	e	enum:state	file:
s_chunk_size_almost_done	http.c	/^  , s_chunk_size_almost_done$/;"	e	enum:state	file:
s_chunk_size_start	http.c	/^  , s_chunk_size_start$/;"	e	enum:state	file:
s_day	RollLog.cpp	/^inline string CDayLog::s_day(time_t t)$/;"	f	class:CDayLog	signature:(time_t t)
s_day	RollLog.h	/^	std::string s_day(time_t t);$/;"	p	class:CDayLog	access:protected	signature:(time_t t)
s_dead	http.c	/^  { s_dead = 1 \/* important that this is > 0 *\/$/;"	e	enum:state	file:
s_header_almost_done	http.c	/^  , s_header_almost_done$/;"	e	enum:state	file:
s_header_field	http.c	/^  , s_header_field$/;"	e	enum:state	file:
s_header_field_start	http.c	/^  , s_header_field_start$/;"	e	enum:state	file:
s_header_value	http.c	/^  , s_header_value$/;"	e	enum:state	file:
s_header_value_lws	http.c	/^  , s_header_value_lws$/;"	e	enum:state	file:
s_header_value_start	http.c	/^  , s_header_value_start$/;"	e	enum:state	file:
s_headers_almost_done	http.c	/^  , s_headers_almost_done$/;"	e	enum:state	file:
s_req_first_http_major	http.c	/^  , s_req_first_http_major$/;"	e	enum:state	file:
s_req_first_http_minor	http.c	/^  , s_req_first_http_minor$/;"	e	enum:state	file:
s_req_fragment	http.c	/^  , s_req_fragment$/;"	e	enum:state	file:
s_req_fragment_start	http.c	/^  , s_req_fragment_start$/;"	e	enum:state	file:
s_req_host	http.c	/^  , s_req_host$/;"	e	enum:state	file:
s_req_http_H	http.c	/^  , s_req_http_H$/;"	e	enum:state	file:
s_req_http_HT	http.c	/^  , s_req_http_HT$/;"	e	enum:state	file:
s_req_http_HTT	http.c	/^  , s_req_http_HTT$/;"	e	enum:state	file:
s_req_http_HTTP	http.c	/^  , s_req_http_HTTP$/;"	e	enum:state	file:
s_req_http_major	http.c	/^  , s_req_http_major$/;"	e	enum:state	file:
s_req_http_minor	http.c	/^  , s_req_http_minor$/;"	e	enum:state	file:
s_req_http_start	http.c	/^  , s_req_http_start$/;"	e	enum:state	file:
s_req_line_almost_done	http.c	/^  , s_req_line_almost_done$/;"	e	enum:state	file:
s_req_method	http.c	/^  , s_req_method$/;"	e	enum:state	file:
s_req_path	http.c	/^  , s_req_path$/;"	e	enum:state	file:
s_req_port	http.c	/^  , s_req_port$/;"	e	enum:state	file:
s_req_query_string	http.c	/^  , s_req_query_string$/;"	e	enum:state	file:
s_req_query_string_start	http.c	/^  , s_req_query_string_start$/;"	e	enum:state	file:
s_req_schema	http.c	/^  , s_req_schema$/;"	e	enum:state	file:
s_req_schema_slash	http.c	/^  , s_req_schema_slash$/;"	e	enum:state	file:
s_req_schema_slash_slash	http.c	/^  , s_req_schema_slash_slash$/;"	e	enum:state	file:
s_req_spaces_before_url	http.c	/^  , s_req_spaces_before_url$/;"	e	enum:state	file:
s_res_H	http.c	/^  , s_res_H$/;"	e	enum:state	file:
s_res_HT	http.c	/^  , s_res_HT$/;"	e	enum:state	file:
s_res_HTT	http.c	/^  , s_res_HTT$/;"	e	enum:state	file:
s_res_HTTP	http.c	/^  , s_res_HTTP$/;"	e	enum:state	file:
s_res_first_http_major	http.c	/^  , s_res_first_http_major$/;"	e	enum:state	file:
s_res_first_http_minor	http.c	/^  , s_res_first_http_minor$/;"	e	enum:state	file:
s_res_first_status_code	http.c	/^  , s_res_first_status_code$/;"	e	enum:state	file:
s_res_http_major	http.c	/^  , s_res_http_major$/;"	e	enum:state	file:
s_res_http_minor	http.c	/^  , s_res_http_minor$/;"	e	enum:state	file:
s_res_line_almost_done	http.c	/^  , s_res_line_almost_done$/;"	e	enum:state	file:
s_res_or_resp_H	http.c	/^  , s_res_or_resp_H$/;"	e	enum:state	file:
s_res_status	http.c	/^  , s_res_status$/;"	e	enum:state	file:
s_res_status_code	http.c	/^  , s_res_status_code$/;"	e	enum:state	file:
s_start_req	http.c	/^  , s_start_req$/;"	e	enum:state	file:
s_start_req_or_res	http.c	/^  , s_start_req_or_res$/;"	e	enum:state	file:
s_start_res	http.c	/^  , s_start_res$/;"	e	enum:state	file:
s_time	RollLog.cpp	/^inline string CDayLog::s_time(time_t t)$/;"	f	class:CDayLog	signature:(time_t t)
s_time	RollLog.h	/^	std::string s_time(time_t t);$/;"	p	class:CDayLog	access:protected	signature:(time_t t)
section_map_t	conf.h	/^	typedef std::map< std::string, cnf_section_t > section_map_t;$/;"	t	class:Conf	access:private
self_t	byte.h	/^	typedef ut_block<1> self_t;$/;"	t	struct:ut_block	access:public
self_t	byte.h	/^	typedef ut_block<2> self_t;$/;"	t	struct:ut_block	access:public
self_t	byte.h	/^	typedef ut_block<3> self_t;$/;"	t	struct:ut_block	access:public
self_t	byte.h	/^	typedef ut_block<4> self_t;$/;"	t	struct:ut_block	access:public
self_t	byte.h	/^	typedef ut_block<8> self_t;$/;"	t	struct:ut_block	access:public
self_t	byte.h	/^	typedef ut_block<bytes_len> self_t;$/;"	t	struct:ut_block	access:public
self_t	byte.h	/^	typedef ut_block_uint32<bytes_len> self_t;$/;"	t	struct:ut_block_uint32	access:public
self_t	timer.h	/^	typedef nw_timer self_t;$/;"	t	class:nw_timer	access:private
self_t	ut_mysql.h	/^	typedef ut_mysql self_t;$/;"	t	class:ut_mysql	access:private
semlock	Attr_API_Str.c	/^semlock()$/;"	f	file:
semunlock	Attr_API_Str.c	/^semunlock()$/;"	f	file:
set	byte.h	/^	inline uint32_t set(const void* data, uint32_t len)$/;"	f	struct:ut_buf	access:public	signature:(const void* data, uint32_t len)
set	byte.h	/^	inline void set(const void* data, uint32_t len) { _data = const_cast<uint8_t*>((const uint8_t*)data); _len = len; }$/;"	f	struct:ut_bytes	access:public	signature:(const void* data, uint32_t len)
set	sync_request.h	/^		void set(T t, int value)$/;"	f	class:SyncRequest	access:public	signature:(T t, int value)
set	timer.h	/^		inline void set(double tv, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)$/;"	f	class:nw_timer	access:public	signature:(double tv, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)
set	timer.h	/^		inline void set(double tv, handler_type* handler, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)$/;"	f	class:nw_timer	access:public	signature:(double tv, handler_type* handler, function_type function, void* arg, bool repeat, int hh=-1, int mm=-1, uint32_t wait=0)
set	ut_str.cpp	/^inline void set(json_escape_t& t, const char* str)$/;"	f	signature:(json_escape_t& t, const char* str)
setNumAttrWithIP	Attr_API.h	/^	int setNumAttrWithIP(const char* szIP, int iAttrId, int iValue);$/;"	p	signature:(const char* szIP, int iAttrId, int iValue)
setNumAttrWithIP	Attr_API_Str.c	/^int setNumAttrWithIP(const char* szIP, int iAttrId, int iValue)$/;"	f	signature:(const char* szIP, int iAttrId, int iValue)
setStrAttrWithIP	Attr_API.h	/^	int setStrAttrWithIP(const char* strIP, int iAttrID, size_t len , char* pval);$/;"	p	signature:(const char* strIP, int iAttrID, size_t len , char* pval)
setStrAttrWithIP	Attr_API_Str.c	/^int setStrAttrWithIP(const char* strIP, int iAttrID, size_t len , char* pval) $/;"	f	signature:(const char* strIP, int iAttrID, size_t len , char* pval)
setULong_H	Attr_API_Str.c	141;"	d	file:
set_connect_param	ut_mysql.h	/^	inline void set_connect_param(int param) { _cnnt_param = param;}$/;"	f	class:ut_mysql	access:public	signature:(int param)
set_daemon	util.cpp	/^int set_daemon()$/;"	f	signature:()
set_daemon	util.h	/^int  set_daemon();$/;"	p	signature:()
set_database	ut_mysql.cpp	/^void ut_mysql::set_database(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param, int32_t cnnt_timeout, int32_t read_timeout, int32_t write_timeout)$/;"	f	class:ut_mysql	signature:(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param, int32_t cnnt_timeout, int32_t read_timeout, int32_t write_timeout)
set_database	ut_mysql.h	/^	inline void set_database(const ut_mysql_cfg_t& cfg)$/;"	f	class:ut_mysql	access:public	signature:(const ut_mysql_cfg_t& cfg)
set_database	ut_mysql.h	/^	void set_database(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param = 0, int32_t cnnt_timeout=-1, int32_t read_timeout=-1, int32_t write_timeout=-1);$/;"	p	class:ut_mysql	access:public	signature:(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param = 0, int32_t cnnt_timeout=-1, int32_t read_timeout=-1, int32_t write_timeout=-1)
set_err	ut_mysql.h	/^	inline void set_err(uint32_t err_code, const char* err_msg)$/;"	f	class:ut_mysql	access:public	signature:(uint32_t err_code, const char* err_msg)
set_fail	timer.h	/^	void set_fail() { _exec = false;}$/;"	f	class:nw_timer	access:public	signature:()
set_level	RollLog.h	/^	void set_level(Log_Level l){_setlevel = l;}$/;"	f	class:CRollLog	access:public	signature:(Log_Level l)
set_limit_core	util.cpp	/^int set_limit_core(uint32_t size)$/;"	f	signature:(uint32_t size)
set_limit_core	util.h	/^int set_limit_core(uint32_t size);$/;"	p	signature:(uint32_t size)
set_module	RollLog.h	/^	void set_module(const std::string& module){_module = module;}$/;"	f	class:CRollLog	access:public	signature:(const std::string& module)
set_on_connect	ut_mysql.h	/^	inline void set_on_connect(function_type function)$/;"	f	class:ut_mysql	access:public	signature:(function_type function)
set_on_connect	ut_mysql.h	/^	inline void set_on_connect(handler_type* handler, function_type function)$/;"	f	class:ut_mysql	access:public	signature:(handler_type* handler, function_type function)
set_on_disconnect	ut_mysql.h	/^	inline void set_on_disconnect(function_type function)$/;"	f	class:ut_mysql	access:public	signature:(function_type function)
set_on_disconnect	ut_mysql.h	/^	inline void set_on_disconnect(handler_type* handler, function_type function)$/;"	f	class:ut_mysql	access:public	signature:(handler_type* handler, function_type function)
set_on_mysql_options	ut_mysql.h	/^	inline void set_on_mysql_options(function_type function)$/;"	f	class:ut_mysql	access:public	signature:(function_type function)
set_on_mysql_options	ut_mysql.h	/^	inline void set_on_mysql_options(handler_type* handler, function_type function)$/;"	f	class:ut_mysql	access:public	signature:(handler_type* handler, function_type function)
set_succ	timer.h	/^	void set_succ() { _exec = true;}$/;"	f	class:nw_timer	access:public	signature:()
set_titleflag	RollLog.cpp	/^void CDayLog::set_titleflag(title_flag f)$/;"	f	class:CDayLog	signature:(title_flag f)
set_titleflag	RollLog.cpp	/^void CRollLog::set_titleflag(title_flag f)$/;"	f	class:CRollLog	signature:(title_flag f)
set_titleflag	RollLog.h	/^	void set_titleflag(title_flag f); $/;"	p	class:CRollLog	access:public	signature:(title_flag f)
set_titleflag	RollLog.h	/^	void set_titleflag(title_flag f);$/;"	p	class:CDayLog	access:public	signature:(title_flag f)
sha1_context	crypt_sha1.h	/^sha1_context;$/;"	t	typeref:struct:__anon17
sha1_finish	crypt_sha1.c	/^void sha1_finish( sha1_context *ctx, uint8_t digest[20] )$/;"	f	signature:( sha1_context *ctx, uint8_t digest[20] )
sha1_finish	crypt_sha1.h	/^void sha1_finish( sha1_context *ctx, uint8_t digest[20] );$/;"	p	signature:( sha1_context *ctx, uint8_t digest[20] )
sha1_padding	crypt_sha1.c	/^static uint8_t sha1_padding[64] =$/;"	v	file:
sha1_process	crypt_sha1.c	/^void sha1_process( sha1_context *ctx, const uint8_t data[64] )$/;"	f	signature:( sha1_context *ctx, const uint8_t data[64] )
sha1_starts	crypt_sha1.c	/^void sha1_starts( sha1_context *ctx )$/;"	f	signature:( sha1_context *ctx )
sha1_starts	crypt_sha1.h	/^void sha1_starts( sha1_context *ctx );$/;"	p	signature:( sha1_context *ctx )
sha1_update	crypt_sha1.c	/^void sha1_update( sha1_context *ctx, const uint8_t *input, uint32_t length )$/;"	f	signature:( sha1_context *ctx, const uint8_t *input, uint32_t length )
sha1_update	crypt_sha1.h	/^void sha1_update( sha1_context *ctx, const uint8_t *input, uint32_t length );$/;"	p	signature:( sha1_context *ctx, const uint8_t *input, uint32_t length )
sha256_context	crypt_sha256.h	/^sha256_context;$/;"	t	typeref:struct:__anon21
sha256_finish	crypt_sha256.c	/^void sha256_finish( sha256_context *ctx, uint8_t digest[32] )$/;"	f	signature:( sha256_context *ctx, uint8_t digest[32] )
sha256_finish	crypt_sha256.h	/^void sha256_finish( sha256_context *ctx, uint8_t digest[32] );$/;"	p	signature:( sha256_context *ctx, uint8_t digest[32] )
sha256_padding	crypt_sha256.c	/^static uint8_t sha256_padding[64] =$/;"	v	file:
sha256_process	crypt_sha256.c	/^void sha256_process( sha256_context *ctx, const uint8_t data[64] )$/;"	f	signature:( sha256_context *ctx, const uint8_t data[64] )
sha256_starts	crypt_sha256.c	/^void sha256_starts( sha256_context *ctx )$/;"	f	signature:( sha256_context *ctx )
sha256_starts	crypt_sha256.h	/^void sha256_starts( sha256_context *ctx );$/;"	p	signature:( sha256_context *ctx )
sha256_update	crypt_sha256.c	/^void sha256_update( sha256_context *ctx, const uint8_t *input, uint32_t length )$/;"	f	signature:( sha256_context *ctx, const uint8_t *input, uint32_t length )
sha256_update	crypt_sha256.h	/^void sha256_update( sha256_context *ctx, const uint8_t *input, uint32_t length );$/;"	p	signature:( sha256_context *ctx, const uint8_t *input, uint32_t length )
size	fifo.h	/^	int size;	\/\/\/ size of the buffer$/;"	m	struct:__anon1	access:public
size_type	md5.h	/^  typedef unsigned int size_type; \/\/ must be 32bit$/;"	t	class:MD5	access:public
spinlock_lock	spin_lock.h	/^static inline void spinlock_lock(spinlock_t* pLock)$/;"	f	signature:(spinlock_t* pLock)
spinlock_t	spin_lock.h	/^typedef volatile uint64_t spinlock_t;$/;"	t
spinlock_unlock	spin_lock.h	/^static inline void spinlock_unlock(spinlock_t* pLock)$/;"	f	signature:(spinlock_t* pLock)
split	str.h	/^int split(char* buff, char* sep)$/;"	f	signature:(char* buff, char* sep)
stObjectOfGroup	multi_object_pool.h	/^		struct stObjectOfGroup {$/;"	s	class:MultiObjectPool	access:public
stamp_to_isodate	mongoc_json.cpp	/^Json::Value stamp_to_isodate(uint32_t t)$/;"	f	signature:(uint32_t t)
stamp_to_isodate	mongoc_json.h	/^Json::Value stamp_to_isodate(uint32_t t);$/;"	p	signature:(uint32_t t)
stamptostr	util.cpp	/^string stamptostr(time_t stamp, const char* format)$/;"	f	signature:(time_t stamp, const char* format)
stamptostr	util.h	/^string stamptostr(time_t stamp = time(NULL), const char* format="%Y-%m-%d %H:%M:%S");$/;"	p	signature:(time_t stamp = time(NULL), const char* format=”)
start_state	http.c	338;"	d	file:
state	crypt_sha1.h	/^    uint32_t state[5];$/;"	m	struct:__anon17	access:public
state	crypt_sha256.h	/^    uint32_t state[8];$/;"	m	struct:__anon21	access:public
state	http.c	/^enum state$/;"	g	file:
state	http.h	/^  unsigned char state;$/;"	m	struct:http_parser	access:public
state	md5.h	/^  uint4 state[4];   \/\/ digest so far$/;"	m	class:MD5	access:private
status_code	http.h	/^  unsigned short status_code; \/* responses only *\/$/;"	m	struct:http_parser	access:public
stmt_next	ut_mysql.h	/^	inline bool stmt_next(MYSQL_STMT* stmt) { return next(stmt); }$/;"	f	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
stoi	util.h	/^T stoi(const char* buff)$/;"	f	signature:(const char* buff)
store_crc	crc32.c	/^void store_crc(uint32_t x, unsigned char *buf)$/;"	f	signature:(uint32_t x, unsigned char *buf)
store_crc	crc32.h	/^void store_crc(uint32_t x, unsigned char *buf);$/;"	p	signature:(uint32_t x, unsigned char *buf)
str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(&_data),_len); }$/;"	f	struct:ut_block	access:public	signature:() const
str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(_data), static_cast<size_t>(_len)); }$/;"	f	struct:ut_buf	access:public	signature:() const
str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(_data),bytes_len); }$/;"	f	struct:ut_block	access:public	signature:() const
str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(_data._u8),_len); }$/;"	f	struct:ut_block	access:public	signature:() const
str	byte.h	/^	inline std::string str() { return std::string(reinterpret_cast<char*>(_data), static_cast<size_t>(_len)); }$/;"	f	struct:ut_bytes	access:public	signature:()
str	byte.h	/^	inline uint32_t str(const std::string& s) { return set(reinterpret_cast<const uint8_t*>(s.c_str()), static_cast<uint32_t>(s.size())); }$/;"	f	struct:ut_buf	access:public	signature:(const std::string& s)
strtostamp	util.cpp	/^time_t strtostamp(const char*  date, const char* format)$/;"	f	signature:(const char* date, const char* format)
strtotm	util.cpp	/^struct tm strtotm(const char*  date, const char* format)$/;"	f	signature:(const char* date, const char* format)
strtotm	util.h	/^struct tm strtotm(const char*  date, const char* format = "%Y-%m-%d %H:%M:%S");$/;"	p	signature:(const char* date, const char* format = ”)
success	ut_mysql.h	/^	inline bool success() const { return _execute_result; }$/;"	f	class:ut_mysql	access:public	signature:() const
sum	objpools/objectpool/examples/test_multi_object_pool.cpp	/^		int sum() {return attrA+attrB;};$/;"	f	class:MyObject	access:public	signature:()
sum	objpools/test_object_pool.cpp	/^		int sum() {return attrA+attrB;};$/;"	f	class:MyObject	access:public	signature:()
syncrequest	sync_request.h	/^	map<T, int> syncrequest;$/;"	m	class:SyncRequest	access:public
t_day	RollLog.cpp	/^inline time_t CDayLog::t_day(time_t t)$/;"	f	class:CDayLog	signature:(time_t t)
t_day	RollLog.h	/^	time_t t_day(time_t t);$/;"	p	class:CDayLog	access:protected	signature:(time_t t)
test_convert	test/test.cpp	/^int test_convert()$/;"	f	signature:()
test_ifstream	test/test.cpp	/^void test_ifstream()$/;"	f	signature:()
test_jsoncpp	test/test.cpp	/^void test_jsoncpp()$/;"	f	signature:()
test_log	test/test.cpp	/^void test_log()$/;"	f	signature:()
test_mongo	test/test.cpp	/^void test_mongo()$/;"	f	signature:()
test_rdtscp	optimized_time.h	/^static inline int test_rdtscp()$/;"	f	signature:()
time_format	RollLog.h	/^	void time_format(const std::string& format="[%H:%M:%S]") {_time_format = format;}$/;"	f	class:CDayLog	access:public	signature:(const std::string& format=”)
time_format	RollLog.h	/^	void time_format(const std::string& format="[%Y-%m-%d %H:%M:%S]") {_time_format = format;}$/;"	f	class:CRollLog	access:public	signature:(const std::string& format=”)
title_flag	RollLog.h	/^	enum title_flag {$/;"	g	class:CDayLog	access:public
title_flag	RollLog.h	/^	enum title_flag {$/;"	g	class:CRollLog	access:public
toa	util.h	/^string toa(T a)$/;"	f	signature:(T a)
tokens	http.c	/^static const char tokens[256] = {$/;"	v	file:
total	crypt_sha1.h	/^    uint32_t total[2];$/;"	m	struct:__anon17	access:public
total	crypt_sha256.h	/^    uint32_t total[2];$/;"	m	struct:__anon21	access:public
transform	md5.cpp	/^void MD5::transform(const uint1 block[blocksize])$/;"	f	class:MD5	signature:(const uint1 block[blocksize])
transform	md5.h	/^  void transform(const uint1 block[blocksize]);$/;"	p	class:MD5	access:private	signature:(const uint1 block[blocksize])
type	http.h	/^  unsigned char type : 2;$/;"	m	struct:http_parser	access:public
u16	byte.h	/^	inline uint16_t u16() const { return _data._u16; }$/;"	f	struct:ut_block	access:public	signature:() const
u32	byte.h	/^	inline uint32_t u32() const { return _data._u32; }$/;"	f	struct:ut_block	access:public	signature:() const
u64	byte.h	/^	inline uint64_t u64() const { return _data._u64; }$/;"	f	struct:ut_block	access:public	signature:() const
u8	byte.h	/^	inline uint8_t u8() const { return _data; }$/;"	f	struct:ut_block	access:public	signature:() const
uint1	md5.h	/^  typedef unsigned char uint1; \/\/  8bit$/;"	t	class:MD5	access:private
uint32_val	byte.h	/^	inline uint32_t uint32_val() const { return util_n2u32(base_t::data(), bytes_len); }$/;"	f	struct:ut_block_uint32	access:public	signature:() const
uint4	md5.h	/^  typedef unsigned int uint4;  \/\/ 32bit$/;"	t	class:MD5	access:private
unhex	http.c	/^static const int8_t unhex[256] =$/;"	v	file:
unpackf	pack.c	/^int unpackf(void *src, size_t max, char const *format, ...)$/;"	f	signature:(void *src, size_t max, char const *format, ...)
unpackf	pack.h	/^extern int unpackf(void *src, size_t max, char const *format, ...);$/;"	p	signature:(void *src, size_t max, char const *format, ...)
update	md5.cpp	/^void MD5::update(const char input[], size_type length)$/;"	f	class:MD5	signature:(const char input[], size_type length)
update	md5.cpp	/^void MD5::update(const unsigned char input[], size_type length)$/;"	f	class:MD5	signature:(const unsigned char input[], size_type length)
update	md5.h	/^  void update(const char *buf, size_type length);$/;"	p	class:MD5	access:public	signature:(const char *buf, size_type length)
update	md5.h	/^  void update(const unsigned char *buf, size_type length);$/;"	p	class:MD5	access:public	signature:(const unsigned char *buf, size_type length)
update_err	ut_mysql.cpp	/^void ut_mysql::update_err()$/;"	f	class:ut_mysql	signature:()
update_err	ut_mysql.cpp	/^void ut_mysql::update_err(MYSQL_STMT* stmt)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt)
update_err	ut_mysql.h	/^	void update_err();$/;"	p	class:ut_mysql	access:public	signature:()
update_err	ut_mysql.h	/^	void update_err(MYSQL_STMT* stmt);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
upgrade	http.h	/^  unsigned char upgrade : 1;$/;"	m	struct:http_parser	access:public
ut_add_slashes	ut_str.h	/^inline std::string ut_add_slashes(const std::string& str)$/;"	f	signature:(const std::string& str)
ut_block	byte.h	/^	inline ut_block() { }$/;"	f	struct:ut_block	access:public	signature:()
ut_block	byte.h	/^	inline ut_block():_data(0) { }$/;"	f	struct:ut_block	access:public	signature:()
ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._s._u16 = block._data._s._u16; _data._s._u8 = block._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._u16 = block._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._u32 = block._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._u64 = block._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block	byte.h	/^	inline ut_block(const self_t& block) { memcpy(_data, block._data, _len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block	byte.h	/^	inline ut_block(const self_t& block):_data(block._data) { }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block	byte.h	/^	inline ut_block(const void* v) { _data._s._u16 = *reinterpret_cast<const uint16_t*>(v); _data._s._u8 = ((const uint8_t*)v)[2]; }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block	byte.h	/^	inline ut_block(const void* v) { _data._u16 = *reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block	byte.h	/^	inline ut_block(const void* v) { _data._u32 = *reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block	byte.h	/^	inline ut_block(const void* v) { _data._u64 = *reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block	byte.h	/^	inline ut_block(const void* v) { memcpy(_data, v, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block	byte.h	/^	inline ut_block(const void* v):_data( ((const uint8_t*)v)[0] ) { }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block	byte.h	/^struct ut_block$/;"	s
ut_block	byte.h	/^struct ut_block<1>$/;"	s
ut_block	byte.h	/^struct ut_block<2>$/;"	s
ut_block	byte.h	/^struct ut_block<3>$/;"	s
ut_block	byte.h	/^struct ut_block<4>$/;"	s
ut_block	byte.h	/^struct ut_block<8>$/;"	s
ut_block::__anon4::_u16	byte.h	/^		uint16_t _u16;$/;"	m	union:ut_block::__anon4	access:public
ut_block::__anon4::_u8	byte.h	/^		uint8_t	_u8[2];$/;"	m	union:ut_block::__anon4	access:public
ut_block::__anon5::__anon6::_u16	byte.h	/^			uint16_t _u16;$/;"	m	struct:ut_block::__anon5::__anon6	access:public
ut_block::__anon5::__anon6::_u8	byte.h	/^			uint8_t _u8;$/;"	m	struct:ut_block::__anon5::__anon6	access:public
ut_block::__anon5::_s	byte.h	/^		}_s;$/;"	m	union:ut_block::__anon5	typeref:struct:ut_block::__anon5::__anon6	access:public
ut_block::__anon5::_u8	byte.h	/^		uint8_t	_u8[3];$/;"	m	union:ut_block::__anon5	access:public
ut_block::__anon7::_u32	byte.h	/^		uint32_t _u32;$/;"	m	union:ut_block::__anon7	access:public
ut_block::__anon7::_u8	byte.h	/^		uint8_t	_u8[4];$/;"	m	union:ut_block::__anon7	access:public
ut_block::__anon8::_u64	byte.h	/^		uint64_t _u64;$/;"	m	union:ut_block::__anon8	access:public
ut_block::__anon8::_u8	byte.h	/^		uint8_t	_u8[8];$/;"	m	union:ut_block::__anon8	access:public
ut_block::_data	byte.h	/^	uint8_t	_data;$/;"	m	struct:ut_block	access:private
ut_block::_data	byte.h	/^	uint8_t	_data[bytes_len];$/;"	m	struct:ut_block	access:private
ut_block::_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon4	access:private
ut_block::_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon5	access:private
ut_block::_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon7	access:private
ut_block::_data	byte.h	/^	}_data;$/;"	m	struct:ut_block	typeref:union:ut_block::__anon8	access:private
ut_block::_len	byte.h	/^	static const int _len = 1;$/;"	m	struct:ut_block	access:public
ut_block::_len	byte.h	/^	static const int _len = 2;$/;"	m	struct:ut_block	access:public
ut_block::_len	byte.h	/^	static const int _len = 3;$/;"	m	struct:ut_block	access:public
ut_block::_len	byte.h	/^	static const int _len = 4;$/;"	m	struct:ut_block	access:public
ut_block::_len	byte.h	/^	static const int _len = 8;$/;"	m	struct:ut_block	access:public
ut_block::_len	byte.h	/^	static const int _len = bytes_len;$/;"	m	struct:ut_block	access:public
ut_block::data	byte.h	/^	inline const uint8_t* data() const { return &_data; }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::data	byte.h	/^	inline const uint8_t* data() const { return _data._u8; }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::data	byte.h	/^	inline const uint8_t* data() const { return _data; }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::data	byte.h	/^	inline uint8_t* data() { return &_data; }$/;"	f	struct:ut_block	access:public	signature:()
ut_block::data	byte.h	/^	inline uint8_t* data() { return _data._u8; }$/;"	f	struct:ut_block	access:public	signature:()
ut_block::data	byte.h	/^	inline uint8_t* data() { return _data; }$/;"	f	struct:ut_block	access:public	signature:()
ut_block::fill	byte.h	/^	inline void fill(const int8_t c) { _data = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
ut_block::fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = _data._u8[2] = _data._u8[3] = _data._u8[4] = _data._u8[5] = _data._u8[6] = _data._u8[7] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
ut_block::fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = _data._u8[2] = _data._u8[3] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
ut_block::fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = _data._u8[2] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
ut_block::fill	byte.h	/^	inline void fill(const int8_t c) { _data._u8[0] = _data._u8[1] = c; }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
ut_block::fill	byte.h	/^	inline void fill(const int8_t c) { memset(_data, c, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const int8_t c)
ut_block::operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data!=v[0]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._s._u16!=*reinterpret_cast<const uint16_t*>(v) || _data._s._u8!=v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._u16!=*reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._u32!=*reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return true; return _data._u64!=*reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const char* v) const { if(strlen(v)!=bytes_len) return true; return 0!=memcmp(_data,v,bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return 0!=memcmp(_data, rhs._data, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data!=rhs._data; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._s._u16!=rhs._data._s._u16 && _data._s._u8==rhs._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._u16!=rhs._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._u32!=rhs._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator !=	byte.h	/^	inline bool operator!=(const self_t& rhs) const { return _data._u64!=rhs._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator =	byte.h	/^	inline void operator=(const self_t& block) { _data = block._data; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._s._u16 = block._data._s._u16; _data._s._u8 = block._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._u16 = block._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._u32 = block._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::operator =	byte.h	/^	inline void operator=(const self_t& block) { _data._u64 = block._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::operator =	byte.h	/^	inline void operator=(const self_t& block) { memcpy(_data, block._data, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::operator =	byte.h	/^	inline void operator=(const std::string& str) { _data = str.c_str()[0]; }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
ut_block::operator =	byte.h	/^	inline void operator=(const std::string& str) { _data._u16 = *reinterpret_cast<const uint16_t*>(str.c_str()); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
ut_block::operator =	byte.h	/^	inline void operator=(const std::string& str) { _data._u32 = *reinterpret_cast<const uint32_t*>(str.c_str()); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
ut_block::operator =	byte.h	/^	inline void operator=(const std::string& str) { _data._u64 = *reinterpret_cast<const uint64_t*>(str.c_str()); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
ut_block::operator =	byte.h	/^	inline void operator=(const std::string& str) { const char* v = str.c_str(); _data._s._u16 = *reinterpret_cast<const uint16_t*>(v); _data._s._u8 = v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
ut_block::operator =	byte.h	/^	inline void operator=(const std::string& str) { memcpy(_data, str.c_str(), bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const std::string& str)
ut_block::operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._s._u16 = *reinterpret_cast<const uint16_t*>(v); _data._s._u8 = v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
ut_block::operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._u16 = *reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
ut_block::operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._u32 = *reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
ut_block::operator =	byte.h	/^	inline void operator=(const uint8_t* v) { _data._u64 = *reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const uint8_t* v)
ut_block::operator =	byte.h	/^	inline void operator=(const void* v) { _data = ((const uint8_t*)v)[0]; }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block::operator =	byte.h	/^	inline void operator=(const void* v) { memcpy(_data, v, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block::operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._s._u16==*reinterpret_cast<const uint16_t*>(v) && _data._s._u8==v[2]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._u16==*reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._u32==*reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data._u64==*reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(static_cast<int>(strlen(v))!=_len) return false; return _data==v[0]; }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const char* v) const { if(strlen(v)!=bytes_len) return false; return 0==memcmp(_data,v,bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const char* v) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return 0==memcmp(_data, rhs._data, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._s._u16==rhs._data._s._u16 && _data._s._u8==rhs._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._u16==rhs._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._u32==rhs._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data._u64==rhs._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::operator ==	byte.h	/^	inline bool operator==(const self_t& rhs) const { return _data==rhs._data; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& rhs) const
ut_block::self_t	byte.h	/^	typedef ut_block<1> self_t;$/;"	t	struct:ut_block	access:public
ut_block::self_t	byte.h	/^	typedef ut_block<2> self_t;$/;"	t	struct:ut_block	access:public
ut_block::self_t	byte.h	/^	typedef ut_block<3> self_t;$/;"	t	struct:ut_block	access:public
ut_block::self_t	byte.h	/^	typedef ut_block<4> self_t;$/;"	t	struct:ut_block	access:public
ut_block::self_t	byte.h	/^	typedef ut_block<8> self_t;$/;"	t	struct:ut_block	access:public
ut_block::self_t	byte.h	/^	typedef ut_block<bytes_len> self_t;$/;"	t	struct:ut_block	access:public
ut_block::str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(&_data),_len); }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(_data),bytes_len); }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(_data._u8),_len); }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::u16	byte.h	/^	inline uint16_t u16() const { return _data._u16; }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::u32	byte.h	/^	inline uint32_t u32() const { return _data._u32; }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::u64	byte.h	/^	inline uint64_t u64() const { return _data._u64; }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::u8	byte.h	/^	inline uint8_t u8() const { return _data; }$/;"	f	struct:ut_block	access:public	signature:() const
ut_block::ut_block	byte.h	/^	inline ut_block() { }$/;"	f	struct:ut_block	access:public	signature:()
ut_block::ut_block	byte.h	/^	inline ut_block():_data(0) { }$/;"	f	struct:ut_block	access:public	signature:()
ut_block::ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._s._u16 = block._data._s._u16; _data._s._u8 = block._data._s._u8; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._u16 = block._data._u16; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._u32 = block._data._u32; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::ut_block	byte.h	/^	inline ut_block(const self_t& block) { _data._u64 = block._data._u64; }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::ut_block	byte.h	/^	inline ut_block(const self_t& block) { memcpy(_data, block._data, _len); }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::ut_block	byte.h	/^	inline ut_block(const self_t& block):_data(block._data) { }$/;"	f	struct:ut_block	access:public	signature:(const self_t& block)
ut_block::ut_block	byte.h	/^	inline ut_block(const void* v) { _data._s._u16 = *reinterpret_cast<const uint16_t*>(v); _data._s._u8 = ((const uint8_t*)v)[2]; }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block::ut_block	byte.h	/^	inline ut_block(const void* v) { _data._u16 = *reinterpret_cast<const uint16_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block::ut_block	byte.h	/^	inline ut_block(const void* v) { _data._u32 = *reinterpret_cast<const uint32_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block::ut_block	byte.h	/^	inline ut_block(const void* v) { _data._u64 = *reinterpret_cast<const uint64_t*>(v); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block::ut_block	byte.h	/^	inline ut_block(const void* v) { memcpy(_data, v, bytes_len); }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block::ut_block	byte.h	/^	inline ut_block(const void* v):_data( ((const uint8_t*)v)[0] ) { }$/;"	f	struct:ut_block	access:public	signature:(const void* v)
ut_block_uint32	byte.h	/^struct ut_block_uint32 : public ut_block<bytes_len>$/;"	s	inherits:ut_block
ut_block_uint32::base_t	byte.h	/^	typedef ut_block<bytes_len> base_t;$/;"	t	struct:ut_block_uint32	access:public
ut_block_uint32::operator =	byte.h	/^	inline void operator=(const self_t& block) { *reinterpret_cast<base_t*>(this) = *reinterpret_cast<const base_t*>(&block);\/*memcpy(base_t::_data, block._data, bytes_len);*\/ }$/;"	f	struct:ut_block_uint32	access:public	signature:(const self_t& block)
ut_block_uint32::operator =	byte.h	/^	inline void operator=(const std::string& str) { *reinterpret_cast<base_t*>(this) = str;\/*memcpy(base_t::_data, str.c_str(), bytes_len);*\/ }$/;"	f	struct:ut_block_uint32	access:public	signature:(const std::string& str)
ut_block_uint32::operator =	byte.h	/^	inline void operator=(const void* v) { *reinterpret_cast<base_t*>(this) = (const uint8_t*)v;\/*memcpy(base_t::_data, v, bytes_len);*\/ }$/;"	f	struct:ut_block_uint32	access:public	signature:(const void* v)
ut_block_uint32::operator =	byte.h	/^	void operator=(const uint32_t v) { util_u322n(v, base_t::data(), bytes_len); }$/;"	f	struct:ut_block_uint32	access:public	signature:(const uint32_t v)
ut_block_uint32::self_t	byte.h	/^	typedef ut_block_uint32<bytes_len> self_t;$/;"	t	struct:ut_block_uint32	access:public
ut_block_uint32::uint32_val	byte.h	/^	inline uint32_t uint32_val() const { return util_n2u32(base_t::data(), bytes_len); }$/;"	f	struct:ut_block_uint32	access:public	signature:() const
ut_bool_str	ut_str.cpp	/^std::string ut_bool_str(bool val)$/;"	f	signature:(bool val)
ut_bool_str	ut_str.h	/^std::string ut_bool_str(bool val);$/;"	p	signature:(bool val)
ut_buf	byte.h	/^	inline ut_buf():_len(0) { }$/;"	f	struct:ut_buf	access:public	signature:()
ut_buf	byte.h	/^	inline ut_buf(const ut_buf& buf):_len(buf._len) { memcpy(_data, buf._data, _len); }$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf)
ut_buf	byte.h	/^	inline ut_buf(const void* data, uint32_t len) { set(data, len); }$/;"	f	struct:ut_buf	access:public	signature:(const void* data, uint32_t len)
ut_buf	byte.h	/^	inline ut_buf(uint32_t len):_len(len) { }$/;"	f	struct:ut_buf	access:public	signature:(uint32_t len)
ut_buf	byte.h	/^struct ut_buf$/;"	s
ut_buf::_data	byte.h	/^	uint8_t _data[max_bytes_len];$/;"	m	struct:ut_buf	access:public
ut_buf::_len	byte.h	/^	uint32_t _len;$/;"	m	struct:ut_buf	access:public
ut_buf::_max_len	byte.h	/^	static const uint32_t _max_len = max_bytes_len;$/;"	m	struct:ut_buf	access:public
ut_buf::equal	byte.h	/^	inline bool equal(const void* data, uint32_t len) const$/;"	f	struct:ut_buf	access:public	signature:(const void* data, uint32_t len) const
ut_buf::fill	byte.h	/^	inline void fill(const int8_t c) { memset(_data, c, max_bytes_len); }$/;"	f	struct:ut_buf	access:public	signature:(const int8_t c)
ut_buf::operator !=	byte.h	/^	inline bool operator!=(const ut_buf& buf) const { return !(*this==buf); }$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf) const
ut_buf::operator =	byte.h	/^	inline void operator=(const std::string& str) { memcpy(_data, str.c_str(), _len=str.size()); }$/;"	f	struct:ut_buf	access:public	signature:(const std::string& str)
ut_buf::operator =	byte.h	/^	inline void operator=(const ut_buf& buf) { memcpy(_data, buf._data, _len=buf._len); }$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf)
ut_buf::operator ==	byte.h	/^	inline bool operator==(const ut_buf& buf) const$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf) const
ut_buf::set	byte.h	/^	inline uint32_t set(const void* data, uint32_t len)$/;"	f	struct:ut_buf	access:public	signature:(const void* data, uint32_t len)
ut_buf::str	byte.h	/^	inline std::string str() const { return std::string(reinterpret_cast<const char*>(_data), static_cast<size_t>(_len)); }$/;"	f	struct:ut_buf	access:public	signature:() const
ut_buf::str	byte.h	/^	inline uint32_t str(const std::string& s) { return set(reinterpret_cast<const uint8_t*>(s.c_str()), static_cast<uint32_t>(s.size())); }$/;"	f	struct:ut_buf	access:public	signature:(const std::string& s)
ut_buf::ut_buf	byte.h	/^	inline ut_buf():_len(0) { }$/;"	f	struct:ut_buf	access:public	signature:()
ut_buf::ut_buf	byte.h	/^	inline ut_buf(const ut_buf& buf):_len(buf._len) { memcpy(_data, buf._data, _len); }$/;"	f	struct:ut_buf	access:public	signature:(const ut_buf& buf)
ut_buf::ut_buf	byte.h	/^	inline ut_buf(const void* data, uint32_t len) { set(data, len); }$/;"	f	struct:ut_buf	access:public	signature:(const void* data, uint32_t len)
ut_buf::ut_buf	byte.h	/^	inline ut_buf(uint32_t len):_len(len) { }$/;"	f	struct:ut_buf	access:public	signature:(uint32_t len)
ut_bytes	byte.h	/^	inline ut_bytes():_data(NULL), _len(0) { }$/;"	f	struct:ut_bytes	access:public	signature:()
ut_bytes	byte.h	/^	inline ut_bytes(const ut_bytes& bytes):_data(bytes._data), _len(bytes._len) { }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& bytes)
ut_bytes	byte.h	/^	inline ut_bytes(const void* data, uint32_t len):_data(const_cast<uint8_t*>((const uint8_t*)data)), _len(len) { }$/;"	f	struct:ut_bytes	access:public	signature:(const void* data, uint32_t len)
ut_bytes	byte.h	/^struct ut_bytes$/;"	s
ut_bytes::_data	byte.h	/^	uint8_t* _data;$/;"	m	struct:ut_bytes	access:public
ut_bytes::_len	byte.h	/^	uint32_t _len;$/;"	m	struct:ut_bytes	access:public
ut_bytes::operator !=	byte.h	/^	inline bool operator!=(const ut_bytes& rhs) const { return _len!=rhs._len || 0!=memcmp(_data, rhs._data, _len); }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& rhs) const
ut_bytes::operator =	byte.h	/^	inline void operator=(const ut_bytes& bytes) { _data = bytes._data; _len = bytes._len; }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& bytes)
ut_bytes::operator ==	byte.h	/^	inline bool operator==(const ut_bytes& rhs) const { return _len==rhs._len && 0==memcmp(_data, rhs._data, _len); }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& rhs) const
ut_bytes::set	byte.h	/^	inline void set(const void* data, uint32_t len) { _data = const_cast<uint8_t*>((const uint8_t*)data); _len = len; }$/;"	f	struct:ut_bytes	access:public	signature:(const void* data, uint32_t len)
ut_bytes::str	byte.h	/^	inline std::string str() { return std::string(reinterpret_cast<char*>(_data), static_cast<size_t>(_len)); }$/;"	f	struct:ut_bytes	access:public	signature:()
ut_bytes::ut_bytes	byte.h	/^	inline ut_bytes():_data(NULL), _len(0) { }$/;"	f	struct:ut_bytes	access:public	signature:()
ut_bytes::ut_bytes	byte.h	/^	inline ut_bytes(const ut_bytes& bytes):_data(bytes._data), _len(bytes._len) { }$/;"	f	struct:ut_bytes	access:public	signature:(const ut_bytes& bytes)
ut_bytes::ut_bytes	byte.h	/^	inline ut_bytes(const void* data, uint32_t len):_data(const_cast<uint8_t*>((const uint8_t*)data)), _len(len) { }$/;"	f	struct:ut_bytes	access:public	signature:(const void* data, uint32_t len)
ut_ddump	ut_str.cpp	/^void ut_ddump(const void* mem, int len, FILE* file)$/;"	f	signature:(const void* mem, int len, FILE* file)
ut_ddump	ut_str.h	/^void ut_ddump(const void* mem, int len, FILE* file=NULL);$/;"	p	signature:(const void* mem, int len, FILE* file=NULL)
ut_dump	ut_str.cpp	/^std::string ut_dump(const void* mem, int len)$/;"	f	signature:(const void* mem, int len)
ut_dump	ut_str.h	/^std::string ut_dump(const void* mem, int len);$/;"	p	signature:(const void* mem, int len)
ut_hex_dump	ut_str.cpp	/^std::string ut_hex_dump(const void *mem, size_t size)$/;"	f	signature:(const void *mem, size_t size)
ut_hex_dump	ut_str.h	/^std::string ut_hex_dump(const void *mem, size_t len);$/;"	p	signature:(const void *mem, size_t len)
ut_json_escape	ut_str.cpp	/^std::string ut_json_escape(const std::string& plain)$/;"	f	signature:(const std::string& plain)
ut_json_escape	ut_str.h	/^std::string ut_json_escape(const std::string& plain);$/;"	p	signature:(const std::string& plain)
ut_kmp	ut_str.h	/^} ut_kmp;$/;"	t	typeref:struct:__anon23
ut_kmp_create	ut_str.cpp	/^ut_kmp * ut_kmp_create(const void* pat, int len)$/;"	f	signature:(const void* pat, int len)
ut_kmp_create	ut_str.h	/^ut_kmp * ut_kmp_create(const void* pat, int len);$/;"	p	signature:(const void* pat, int len)
ut_kmp_destroy	ut_str.cpp	/^void ut_kmp_destroy(ut_kmp *kmp)$/;"	f	signature:(ut_kmp *kmp)
ut_kmp_destroy	ut_str.h	/^void ut_kmp_destroy(ut_kmp *kmp);$/;"	p	signature:(ut_kmp *kmp)
ut_kmp_find	ut_str.cpp	/^int ut_kmp_find(const void* haystack, int haystack_size, ut_kmp *kmp)$/;"	f	signature:(const void* haystack, int haystack_size, ut_kmp *kmp)
ut_kmp_find	ut_str.h	/^int ut_kmp_find(const void* haystack, int haystack_size, ut_kmp *kmp);$/;"	p	signature:(const void* haystack, int haystack_size, ut_kmp *kmp)
ut_mysql	ut_mysql.cpp	/^ut_mysql::ut_mysql(void)$/;"	f	class:ut_mysql	signature:(void)
ut_mysql	ut_mysql.h	/^	ut_mysql(const ut_mysql& rhs);$/;"	p	class:ut_mysql	access:private	signature:(const ut_mysql& rhs)
ut_mysql	ut_mysql.h	/^	ut_mysql(void);$/;"	p	class:ut_mysql	access:public	signature:(void)
ut_mysql	ut_mysql.h	/^class ut_mysql$/;"	c
ut_mysql::__intra_charset	ut_mysql.h	/^	inline std::string& __intra_charset() { return _charset; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_cnnt_param	ut_mysql.h	/^	inline int32_t& __intra_cnnt_param() { return _cnnt_param; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_cnnt_timeout	ut_mysql.h	/^	inline int32_t& __intra_cnnt_timeout() { return _cnnt_timeout; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_connected	ut_mysql.h	/^	inline bool& __intra_connected() { return _connected; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_db_name	ut_mysql.h	/^	inline std::string& __intra_db_name() { return _db_name; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_execute_result	ut_mysql.h	/^	inline bool& __intra_execute_result() { return _execute_result; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_field_count	ut_mysql.h	/^	inline uint32_t& __intra_field_count() { return _field_count; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_field_len	ut_mysql.h	/^	inline unsigned long*& __intra_field_len() { return _field_len; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_host	ut_mysql.h	/^	inline std::string& __intra_host() { return _host; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_mysql	ut_mysql.h	/^	inline MYSQL& __intra_mysql() { return _mysql; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_on_connect_cb	ut_mysql.h	/^	inline callback_t& __intra_on_connect_cb() { return _on_connect_cb; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_on_connect_hdlr	ut_mysql.h	/^	inline handler_t*& __intra_on_connect_hdlr() { return _on_connect_hdlr; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_on_disconnect_cb	ut_mysql.h	/^	inline callback_t& __intra_on_disconnect_cb() { return _on_disconnect_cb; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_on_disconnect_hdlr	ut_mysql.h	/^	inline handler_t*& __intra_on_disconnect_hdlr() { return _on_disconnect_hdlr; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_on_mysql_options_cb	ut_mysql.h	/^	inline callback_t& __intra_on_mysql_options_cb() { return _on_mysql_options_cb; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_on_mysql_options_hdlr	ut_mysql.h	/^	inline handler_t*& __intra_on_mysql_options_hdlr() { return _on_mysql_options_hdlr; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_password	ut_mysql.h	/^	inline std::string& __intra_password() { return _password; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_port	ut_mysql.h	/^	inline uint16_t& __intra_port() { return _port; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_read_timeout	ut_mysql.h	/^	inline int32_t& __intra_read_timeout() { return _read_timeout; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_res	ut_mysql.h	/^	inline MYSQL_RES*& __intra_res() { return _res; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_row	ut_mysql.h	/^	inline MYSQL_ROW& __intra_row() { return _row; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_row_count	ut_mysql.h	/^	inline uint64_t& __intra_row_count() { return _row_count; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_user_name	ut_mysql.h	/^	inline std::string& __intra_user_name() { return _user_name; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::__intra_write_timeout	ut_mysql.h	/^	inline int32_t& __intra_write_timeout() { return _write_timeout; }$/;"	f	class:ut_mysql	access:protected	signature:()
ut_mysql::_charset	ut_mysql.h	/^	std::string _charset;$/;"	m	class:ut_mysql	access:private
ut_mysql::_cnnt_param	ut_mysql.h	/^	int32_t _cnnt_param;$/;"	m	class:ut_mysql	access:private
ut_mysql::_cnnt_timeout	ut_mysql.h	/^	int32_t _cnnt_timeout;$/;"	m	class:ut_mysql	access:private
ut_mysql::_connected	ut_mysql.h	/^	bool _connected;$/;"	m	class:ut_mysql	access:private
ut_mysql::_db_name	ut_mysql.h	/^	std::string _db_name;$/;"	m	class:ut_mysql	access:private
ut_mysql::_err_code	ut_mysql.h	/^	uint32_t _err_code;$/;"	m	class:ut_mysql	access:private
ut_mysql::_err_msg	ut_mysql.h	/^	char _err_msg[_err_msg_max_len];$/;"	m	class:ut_mysql	access:private
ut_mysql::_err_msg_max_len	ut_mysql.h	/^	static const uint32_t _err_msg_max_len = 512;$/;"	m	class:ut_mysql	access:private
ut_mysql::_execute_result	ut_mysql.h	/^	bool _execute_result;$/;"	m	class:ut_mysql	access:private
ut_mysql::_field_count	ut_mysql.h	/^	uint32_t _field_count;$/;"	m	class:ut_mysql	access:private
ut_mysql::_field_len	ut_mysql.h	/^	unsigned long* _field_len;$/;"	m	class:ut_mysql	access:private
ut_mysql::_host	ut_mysql.h	/^	std::string _host;$/;"	m	class:ut_mysql	access:private
ut_mysql::_mysql	ut_mysql.h	/^	MYSQL _mysql;$/;"	m	class:ut_mysql	access:private
ut_mysql::_null_string	ut_mysql.cpp	/^const char ut_mysql::_null_string[1] = {'\\0'};$/;"	m	class:ut_mysql	file:
ut_mysql::_null_string	ut_mysql.h	/^	static const char _null_string[1];$/;"	m	class:ut_mysql	access:private
ut_mysql::_on_connect_cb	ut_mysql.h	/^	callback_t _on_connect_cb;$/;"	m	class:ut_mysql	access:private
ut_mysql::_on_connect_hdlr	ut_mysql.h	/^	handler_t* _on_connect_hdlr;$/;"	m	class:ut_mysql	access:private
ut_mysql::_on_disconnect_cb	ut_mysql.h	/^	callback_t _on_disconnect_cb;$/;"	m	class:ut_mysql	access:private
ut_mysql::_on_disconnect_hdlr	ut_mysql.h	/^	handler_t* _on_disconnect_hdlr;$/;"	m	class:ut_mysql	access:private
ut_mysql::_on_mysql_options_cb	ut_mysql.h	/^	callback_t _on_mysql_options_cb;$/;"	m	class:ut_mysql	access:private
ut_mysql::_on_mysql_options_hdlr	ut_mysql.h	/^	handler_t* _on_mysql_options_hdlr;$/;"	m	class:ut_mysql	access:private
ut_mysql::_password	ut_mysql.h	/^	std::string _password;$/;"	m	class:ut_mysql	access:private
ut_mysql::_port	ut_mysql.h	/^	uint16_t _port;$/;"	m	class:ut_mysql	access:private
ut_mysql::_read_timeout	ut_mysql.h	/^	int32_t _read_timeout;$/;"	m	class:ut_mysql	access:private
ut_mysql::_res	ut_mysql.h	/^	MYSQL_RES *_res;$/;"	m	class:ut_mysql	access:private
ut_mysql::_row	ut_mysql.h	/^	MYSQL_ROW _row;$/;"	m	class:ut_mysql	access:private
ut_mysql::_row_count	ut_mysql.h	/^	uint64_t _row_count;$/;"	m	class:ut_mysql	access:private
ut_mysql::_user_name	ut_mysql.h	/^	std::string _user_name;$/;"	m	class:ut_mysql	access:private
ut_mysql::_write_timeout	ut_mysql.h	/^	int32_t _write_timeout;$/;"	m	class:ut_mysql	access:private
ut_mysql::affected_rows	ut_mysql.h	/^	inline uint64_t affected_rows() { return mysql_affected_rows(&_mysql); }$/;"	f	class:ut_mysql	access:public	signature:()
ut_mysql::affected_rows	ut_mysql.h	/^	inline uint64_t affected_rows(MYSQL_STMT* stmt) { return mysql_stmt_affected_rows(stmt); }$/;"	f	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
ut_mysql::callback_t	ut_mysql.h	/^	union callback_t$/;"	u	class:ut_mysql	access:protected
ut_mysql::callback_t::_member_function	ut_mysql.h	/^		void (handler_t::*_member_function)(self_t*);$/;"	m	union:ut_mysql::callback_t	access:public
ut_mysql::callback_t::_static_function	ut_mysql.h	/^		void (*_static_function)(self_t*);$/;"	m	union:ut_mysql::callback_t	access:public
ut_mysql::close_connection	ut_mysql.h	/^	inline void close_connection() { disconnect(); }$/;"	f	class:ut_mysql	access:public	signature:()
ut_mysql::close_stmt	ut_mysql.h	/^	inline void close_stmt(MYSQL_STMT* stmt) { mysql_stmt_free_result(stmt); mysql_stmt_close(stmt); }$/;"	f	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
ut_mysql::connect	ut_mysql.cpp	/^bool ut_mysql::connect()$/;"	f	class:ut_mysql	signature:()
ut_mysql::connect	ut_mysql.h	/^	bool connect();$/;"	p	class:ut_mysql	access:private	signature:()
ut_mysql::connected	ut_mysql.h	/^	inline bool connected() const { return _connected; }$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::connection_id	ut_mysql.h	/^	inline uint64_t connection_id() { return mysql_thread_id(&_mysql); }$/;"	f	class:ut_mysql	access:public	signature:()
ut_mysql::create_and_prepare_stmt	ut_mysql.cpp	/^MYSQL_STMT* ut_mysql::create_and_prepare_stmt(const char* sql, uint32_t len)$/;"	f	class:ut_mysql	signature:(const char* sql, uint32_t len)
ut_mysql::create_and_prepare_stmt	ut_mysql.h	/^	MYSQL_STMT* create_and_prepare_stmt(const char* sql, uint32_t len);$/;"	p	class:ut_mysql	access:public	signature:(const char* sql, uint32_t len)
ut_mysql::disconnect	ut_mysql.cpp	/^void ut_mysql::disconnect()$/;"	f	class:ut_mysql	signature:()
ut_mysql::disconnect	ut_mysql.h	/^	void disconnect();$/;"	p	class:ut_mysql	access:private	signature:()
ut_mysql::ensure_connection	ut_mysql.h	/^	inline bool ensure_connection() { if(!_connected) return connect(); return true; }$/;"	f	class:ut_mysql	access:public	signature:()
ut_mysql::error_code	ut_mysql.h	/^	inline uint32_t error_code() const { return _err_code;	}$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::error_cr_server_lost	ut_mysql.h	/^	inline bool error_cr_server_lost() const { return is_err_cr_server_lost(_err_code); }$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::error_key_dup	ut_mysql.h	/^	inline bool error_key_dup() const { return is_err_key_dup(_err_code); }$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::error_msg	ut_mysql.h	/^	inline const char* error_msg() const { return _err_msg; }$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::escape	ut_mysql.h	/^	inline uint64_t escape(char*to, const char* from, uint64_t len) { return mysql_real_escape_string(&_mysql, to, from, len); }$/;"	f	class:ut_mysql	access:public	signature:(char*to, const char* from, uint64_t len)
ut_mysql::execute	ut_mysql.cpp	/^bool ut_mysql::execute(MYSQL_STMT* stmt, MYSQL_BIND* param_bind)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind)
ut_mysql::execute	ut_mysql.cpp	/^bool ut_mysql::execute(const char* sql, uint32_t len)$/;"	f	class:ut_mysql	signature:(const char* sql, uint32_t len)
ut_mysql::execute	ut_mysql.h	/^	bool execute(MYSQL_STMT* stmt, MYSQL_BIND* param_bind);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind)
ut_mysql::execute	ut_mysql.h	/^	bool execute(const char* sql, uint32_t len);$/;"	p	class:ut_mysql	access:public	signature:(const char* sql, uint32_t len)
ut_mysql::field	ut_mysql.h	/^	inline const char* field(const std::string& name) const { int idx = field_index(name); if(idx>=0) return field(idx); return NULL; }$/;"	f	class:ut_mysql	access:public	signature:(const std::string& name) const
ut_mysql::field	ut_mysql.h	/^	inline const char* field(const uint32_t index) const { if(index<field_count()) return _row[index]; return NULL; }$/;"	f	class:ut_mysql	access:public	signature:(const uint32_t index) const
ut_mysql::field_count	ut_mysql.h	/^	inline uint32_t field_count() const { return _execute_result? _field_count : 0; }$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::field_index	ut_mysql.cpp	/^int ut_mysql::field_index(const std::string& name) const$/;"	f	class:ut_mysql	signature:(const std::string& name) const
ut_mysql::field_index	ut_mysql.h	/^	int field_index(const std::string& name) const;$/;"	p	class:ut_mysql	access:public	signature:(const std::string& name) const
ut_mysql::field_len	ut_mysql.h	/^	inline const uint64_t field_len(const std::string& name) const { return field_len(field_index(name)); }$/;"	f	class:ut_mysql	access:public	signature:(const std::string& name) const
ut_mysql::field_len	ut_mysql.h	/^	inline const uint64_t field_len(const uint32_t index) const { if(index<field_count()) return _field_len[index]; return 0; }$/;"	f	class:ut_mysql	access:public	signature:(const uint32_t index) const
ut_mysql::handler_t	ut_mysql.h	/^	class handler_t { };$/;"	c	class:ut_mysql	access:protected
ut_mysql::is_err_cr_server_lost	ut_mysql.h	/^	inline static bool is_err_cr_server_lost(uint32_t code)$/;"	f	class:ut_mysql	access:public	signature:(uint32_t code)
ut_mysql::is_err_key_dup	ut_mysql.h	/^	inline static bool is_err_key_dup(uint32_t code)$/;"	f	class:ut_mysql	access:public	signature:(uint32_t code)
ut_mysql::last_insert_id	ut_mysql.h	/^	inline uint64_t last_insert_id() { return static_cast<uint64_t>(mysql_insert_id(&_mysql)); }$/;"	f	class:ut_mysql	access:public	signature:()
ut_mysql::next	ut_mysql.cpp	/^bool ut_mysql::next()$/;"	f	class:ut_mysql	signature:()
ut_mysql::next	ut_mysql.cpp	/^bool ut_mysql::next(MYSQL_STMT* stmt)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt)
ut_mysql::next	ut_mysql.h	/^	bool next();$/;"	p	class:ut_mysql	access:public	signature:()
ut_mysql::next	ut_mysql.h	/^	bool next(MYSQL_STMT* stmt);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
ut_mysql::on_connect	ut_mysql.cpp	/^void ut_mysql::on_connect()$/;"	f	class:ut_mysql	signature:()
ut_mysql::on_connect	ut_mysql.h	/^	virtual void on_connect();$/;"	p	class:ut_mysql	access:protected	signature:()
ut_mysql::on_disconnect	ut_mysql.cpp	/^void ut_mysql::on_disconnect()$/;"	f	class:ut_mysql	signature:()
ut_mysql::on_disconnect	ut_mysql.h	/^	virtual void on_disconnect();$/;"	p	class:ut_mysql	access:protected	signature:()
ut_mysql::on_mysql_options	ut_mysql.cpp	/^void ut_mysql::on_mysql_options()$/;"	f	class:ut_mysql	signature:()
ut_mysql::on_mysql_options	ut_mysql.h	/^	virtual void on_mysql_options();$/;"	p	class:ut_mysql	access:protected	signature:()
ut_mysql::operator =	ut_mysql.h	/^	ut_mysql& operator=(const ut_mysql& rhs);$/;"	p	class:ut_mysql	access:private	signature:(const ut_mysql& rhs)
ut_mysql::ping	ut_mysql.cpp	/^bool ut_mysql::ping()$/;"	f	class:ut_mysql	signature:()
ut_mysql::ping	ut_mysql.h	/^	bool ping();$/;"	p	class:ut_mysql	access:public	signature:()
ut_mysql::query	ut_mysql.cpp	/^bool ut_mysql::query(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind)
ut_mysql::query	ut_mysql.cpp	/^bool ut_mysql::query(const char* sql, uint32_t len)$/;"	f	class:ut_mysql	signature:(const char* sql, uint32_t len)
ut_mysql::query	ut_mysql.h	/^	bool query(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt, MYSQL_BIND* param_bind, MYSQL_BIND* result_bind)
ut_mysql::query	ut_mysql.h	/^	bool query(const char* sql, uint32_t len);$/;"	p	class:ut_mysql	access:public	signature:(const char* sql, uint32_t len)
ut_mysql::real_set_on_connect	ut_mysql.h	/^	inline void real_set_on_connect(handler_t* handler, void(handler_t::*member_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(handler_t* handler, void(handler_t::*member_function)(self_t*))
ut_mysql::real_set_on_connect	ut_mysql.h	/^	inline void real_set_on_connect(void(*static_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(void(*static_function)(self_t*))
ut_mysql::real_set_on_disconnect	ut_mysql.h	/^	inline void real_set_on_disconnect(handler_t* handler, void(handler_t::*member_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(handler_t* handler, void(handler_t::*member_function)(self_t*))
ut_mysql::real_set_on_disconnect	ut_mysql.h	/^	inline void real_set_on_disconnect(void(*static_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(void(*static_function)(self_t*))
ut_mysql::real_set_on_mysql_options	ut_mysql.h	/^	inline void real_set_on_mysql_options(handler_t* handler, void(handler_t::*member_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(handler_t* handler, void(handler_t::*member_function)(self_t*))
ut_mysql::real_set_on_mysql_options	ut_mysql.h	/^	inline void real_set_on_mysql_options(void(*static_function)(self_t*))$/;"	f	class:ut_mysql	access:private	signature:(void(*static_function)(self_t*))
ut_mysql::row_count	ut_mysql.h	/^	inline uint64_t row_count() const { return _execute_result? _row_count : 0ull; }$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::self_t	ut_mysql.h	/^	typedef ut_mysql self_t;$/;"	t	class:ut_mysql	access:private
ut_mysql::set_connect_param	ut_mysql.h	/^	inline void set_connect_param(int param) { _cnnt_param = param;}$/;"	f	class:ut_mysql	access:public	signature:(int param)
ut_mysql::set_database	ut_mysql.cpp	/^void ut_mysql::set_database(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param, int32_t cnnt_timeout, int32_t read_timeout, int32_t write_timeout)$/;"	f	class:ut_mysql	signature:(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param, int32_t cnnt_timeout, int32_t read_timeout, int32_t write_timeout)
ut_mysql::set_database	ut_mysql.h	/^	inline void set_database(const ut_mysql_cfg_t& cfg)$/;"	f	class:ut_mysql	access:public	signature:(const ut_mysql_cfg_t& cfg)
ut_mysql::set_database	ut_mysql.h	/^	void set_database(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param = 0, int32_t cnnt_timeout=-1, int32_t read_timeout=-1, int32_t write_timeout=-1);$/;"	p	class:ut_mysql	access:public	signature:(const std::string& host, const unsigned short port, const std::string& db_name, const std::string& user_name, const std::string& password, const std::string& charset, int32_t cnnt_param = 0, int32_t cnnt_timeout=-1, int32_t read_timeout=-1, int32_t write_timeout=-1)
ut_mysql::set_err	ut_mysql.h	/^	inline void set_err(uint32_t err_code, const char* err_msg)$/;"	f	class:ut_mysql	access:public	signature:(uint32_t err_code, const char* err_msg)
ut_mysql::set_on_connect	ut_mysql.h	/^	inline void set_on_connect(function_type function)$/;"	f	class:ut_mysql	access:public	signature:(function_type function)
ut_mysql::set_on_connect	ut_mysql.h	/^	inline void set_on_connect(handler_type* handler, function_type function)$/;"	f	class:ut_mysql	access:public	signature:(handler_type* handler, function_type function)
ut_mysql::set_on_disconnect	ut_mysql.h	/^	inline void set_on_disconnect(function_type function)$/;"	f	class:ut_mysql	access:public	signature:(function_type function)
ut_mysql::set_on_disconnect	ut_mysql.h	/^	inline void set_on_disconnect(handler_type* handler, function_type function)$/;"	f	class:ut_mysql	access:public	signature:(handler_type* handler, function_type function)
ut_mysql::set_on_mysql_options	ut_mysql.h	/^	inline void set_on_mysql_options(function_type function)$/;"	f	class:ut_mysql	access:public	signature:(function_type function)
ut_mysql::set_on_mysql_options	ut_mysql.h	/^	inline void set_on_mysql_options(handler_type* handler, function_type function)$/;"	f	class:ut_mysql	access:public	signature:(handler_type* handler, function_type function)
ut_mysql::stmt_next	ut_mysql.h	/^	inline bool stmt_next(MYSQL_STMT* stmt) { return next(stmt); }$/;"	f	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
ut_mysql::success	ut_mysql.h	/^	inline bool success() const { return _execute_result; }$/;"	f	class:ut_mysql	access:public	signature:() const
ut_mysql::update_err	ut_mysql.cpp	/^void ut_mysql::update_err()$/;"	f	class:ut_mysql	signature:()
ut_mysql::update_err	ut_mysql.cpp	/^void ut_mysql::update_err(MYSQL_STMT* stmt)$/;"	f	class:ut_mysql	signature:(MYSQL_STMT* stmt)
ut_mysql::update_err	ut_mysql.h	/^	void update_err();$/;"	p	class:ut_mysql	access:public	signature:()
ut_mysql::update_err	ut_mysql.h	/^	void update_err(MYSQL_STMT* stmt);$/;"	p	class:ut_mysql	access:public	signature:(MYSQL_STMT* stmt)
ut_mysql::ut_mysql	ut_mysql.cpp	/^ut_mysql::ut_mysql(void)$/;"	f	class:ut_mysql	signature:(void)
ut_mysql::ut_mysql	ut_mysql.h	/^	ut_mysql(const ut_mysql& rhs);$/;"	p	class:ut_mysql	access:private	signature:(const ut_mysql& rhs)
ut_mysql::ut_mysql	ut_mysql.h	/^	ut_mysql(void);$/;"	p	class:ut_mysql	access:public	signature:(void)
ut_mysql::~ut_mysql	ut_mysql.cpp	/^ut_mysql::~ut_mysql(void)$/;"	f	class:ut_mysql	signature:(void)
ut_mysql::~ut_mysql	ut_mysql.h	/^	virtual ~ut_mysql(void);$/;"	p	class:ut_mysql	access:public	signature:(void)
ut_mysql_bind_blob	ut_mysql.h	385;"	d
ut_mysql_bind_blob2	ut_mysql.h	386;"	d
ut_mysql_bind_blob_const	ut_mysql.h	387;"	d
ut_mysql_bind_double	ut_mysql.h	380;"	d
ut_mysql_bind_int16	ut_mysql.h	374;"	d
ut_mysql_bind_int32	ut_mysql.h	376;"	d
ut_mysql_bind_int64	ut_mysql.h	378;"	d
ut_mysql_bind_int8	ut_mysql.h	372;"	d
ut_mysql_bind_str	ut_mysql.h	382;"	d
ut_mysql_bind_str2	ut_mysql.h	383;"	d
ut_mysql_bind_str_const	ut_mysql.h	384;"	d
ut_mysql_bind_uint16	ut_mysql.h	375;"	d
ut_mysql_bind_uint32	ut_mysql.h	377;"	d
ut_mysql_bind_uint64	ut_mysql.h	379;"	d
ut_mysql_bind_uint8	ut_mysql.h	373;"	d
ut_replace	ut_str.cpp	/^void ut_replace(std::string& str, const std::string& from, const std::string& to)$/;"	f	signature:(std::string& str, const std::string& from, const std::string& to)
ut_replace	ut_str.h	/^void ut_replace(std::string& str, const std::string& from, const std::string& to);$/;"	p	signature:(std::string& str, const std::string& from, const std::string& to)
ut_split	ut_str.cpp	/^uint32_t ut_split(const std::string& str, std::vector<std::string>& ret_, const std::string& sep, uint32_t limit)$/;"	f	signature:(const std::string& str, std::vector<std::string>& ret_, const std::string& sep, uint32_t limit)
ut_split	ut_str.h	/^uint32_t ut_split(const std::string& str, std::vector<std::string>& ret_, const std::string& sep = ",", uint32_t limit=4294967295u);$/;"	p	signature:(const std::string& str, std::vector<std::string>& ret_, const std::string& sep = ”, uint32_t limit=4294967295u)
ut_split2	ut_str.cpp	/^uint32_t ut_split2(const std::string& str, std::vector<std::string>& ret_, const std::string& sep, uint32_t limit)$/;"	f	signature:(const std::string& str, std::vector<std::string>& ret_, const std::string& sep, uint32_t limit)
ut_split2	ut_str.h	/^uint32_t ut_split2(const std::string& str, std::vector<std::string>& ret_, const std::string& sep = ",", uint32_t limit=4294967295u);$/;"	p	signature:(const std::string& str, std::vector<std::string>& ret_, const std::string& sep = ”, uint32_t limit=4294967295u)
ut_strhash_djb2	ut_str.cpp	/^uint32_t ut_strhash_djb2(const void *str, int len)$/;"	f	signature:(const void *str, int len)
ut_strhash_djb2	ut_str.h	/^uint32_t ut_strhash_djb2(const void *str, int len);$/;"	p	signature:(const void *str, int len)
ut_strhash_sdbm	ut_str.cpp	/^uint32_t ut_strhash_sdbm(const void *str, int len)$/;"	f	signature:(const void *str, int len)
ut_strhash_sdbm	ut_str.h	/^uint32_t ut_strhash_sdbm(const void *str, int len);$/;"	p	signature:(const void *str, int len)
ut_strhash_u64	ut_str.h	/^inline static uint64_t ut_strhash_u64(const void *str, int len)$/;"	f	signature:(const void *str, int len)
ut_trim	ut_str.cpp	/^void ut_trim(std::string& str)$/;"	f	signature:(std::string& str)
ut_trim	ut_str.h	/^void ut_trim(std::string& str);$/;"	p	signature:(std::string& str)
ut_utf8str_full2half	ut_str.cpp	/^void ut_utf8str_full2half(std::string & str)$/;"	f	signature:(std::string & str)
ut_utf8str_full2half	ut_str.h	/^void ut_utf8str_full2half(std::string& str);$/;"	p	signature:(std::string& str)
utf8_str	utf8.h	/^    const char *utf8_str;$/;"	m	struct:__anon19	access:public
utf8_validate	utf8.c	/^unsigned int utf8_validate(void* str, unsigned int len)$/;"	f	signature:(void* str, unsigned int len)
utf8_validate	utf8.h	/^unsigned int utf8_validate(void* str, unsigned int len);$/;"	p	signature:(void* str, unsigned int len)
utf8_vct	utf8.h	/^}utf8_vct;$/;"	t	typeref:struct:__anon19
utf8_vct_init	utf8.c	/^void utf8_vct_init(utf8_vct* vector, const void *utf8, unsigned int string_length)$/;"	f	signature:(utf8_vct* vector, const void *utf8, unsigned int string_length)
utf8_vct_init	utf8.h	/^void utf8_vct_init(utf8_vct* vector, const void *utf8, unsigned int string_length);$/;"	p	signature:(utf8_vct* vector, const void *utf8, unsigned int string_length)
utf8_vct_next	utf8.c	/^wchar_t utf8_vct_next(utf8_vct* vector)$/;"	f	signature:(utf8_vct* vector)
utf8_vct_next	utf8.h	/^wchar_t utf8_vct_next(utf8_vct* vector);$/;"	p	signature:(utf8_vct* vector)
utf8_vct_next_with_raw	utf8.c	/^wchar_t utf8_vct_next_with_raw(utf8_vct* vector, const char **raw, int *raw_length)$/;"	f	signature:(utf8_vct* vector, const char **raw, int *raw_length)
utf8_vct_next_with_raw	utf8.h	/^wchar_t utf8_vct_next_with_raw(utf8_vct* vector, const char **raw, int *raw_length);$/;"	p	signature:(utf8_vct* vector, const char **raw, int *raw_length)
utf8_vct_reset	utf8.c	/^void utf8_vct_reset(utf8_vct* vector)$/;"	f	signature:(utf8_vct* vector)
utf8_vct_reset	utf8.h	/^void utf8_vct_reset(utf8_vct* vector);$/;"	p	signature:(utf8_vct* vector)
utf8_vct_unichar_count	utf8.c	/^int utf8_vct_unichar_count(utf8_vct* vector)$/;"	f	signature:(utf8_vct* vector)
utf8_vct_unichar_count	utf8.h	/^int utf8_vct_unichar_count(utf8_vct* vector);$/;"	p	signature:(utf8_vct* vector)
utf8vector_check_eof	utf8.c	35;"	d	file:
util_is_email	ut_str.cpp	/^bool util_is_email(const void* _str, int32_t len)$/;"	f	signature:(const void* _str, int32_t len)
val	crypt_sha1.c	/^static char *val[] =$/;"	v	file:
val	crypt_sha256.c	/^static char *val[] =$/;"	v	file:
val_number	Attr_API_Var.c	/^		uint64_t val_number;$/;"	m	union:__anon9::__anon12	file:	access:public
vpacka	pack.c	/^int vpacka(void **current, int *left, char const *format, va_list arg)$/;"	f	signature:(void **current, int *left, char const *format, va_list arg)
vpacka	pack.h	/^extern int vpacka(void **current, int *left, char const *format, va_list arg);$/;"	p	signature:(void **current, int *left, char const *format, va_list arg)
vpackf	pack.c	/^int vpackf(void **current, int *left, char const *format, ...)$/;"	f	signature:(void **current, int *left, char const *format, ...)
vpackf	pack.h	/^extern int vpackf(void **current, int *left, char const *format, ...);$/;"	p	signature:(void **current, int *left, char const *format, ...)
vpackn	pack.c	/^int vpackn(void **current, int *left, void *buf, size_t n)$/;"	f	signature:(void **current, int *left, void *buf, size_t n)
vpackn	pack.h	/^extern int vpackn(void **current, int *left, void *buf, size_t n);$/;"	p	signature:(void **current, int *left, void *buf, size_t n)
vunpacka	pack.c	/^int vunpacka(void **current, int *left, char const *format, va_list arg)$/;"	f	signature:(void **current, int *left, char const *format, va_list arg)
vunpacka	pack.h	/^extern int vunpacka(void **current, int *left, char const *format, va_list arg);$/;"	p	signature:(void **current, int *left, char const *format, va_list arg)
vunpackf	pack.c	/^int vunpackf(void **current, int *left, char const *format, ...)$/;"	f	signature:(void **current, int *left, char const *format, ...)
vunpackf	pack.h	/^extern int vunpackf(void **current, int *left, char const *format, ...);$/;"	p	signature:(void **current, int *left, char const *format, ...)
vunpackn	pack.c	/^int vunpackn(void **current, int *left, void *buf, size_t n)$/;"	f	signature:(void **current, int *left, void *buf, size_t n)
vunpackn	pack.h	/^extern int vunpackn(void **current, int *left, void *buf, size_t n);$/;"	p	signature:(void **current, int *left, void *buf, size_t n)
walltick	optimized_time.h	/^static uint64_t walltick;$/;"	v
walltime	optimized_time.h	/^static struct timeval walltime;$/;"	v	typeref:struct:timeval
wpos	fifo.h	/^	int wpos;	\/\/\/ the write position$/;"	m	struct:__anon1	access:public
wry_dict	wry.h	/^struct wry_dict$/;"	s
wry_dict::head	wry.h	/^	struct wry_head head;$/;"	m	struct:wry_dict	typeref:struct:wry_dict::wry_head	access:public
wry_dict::ip_list	wry.h	/^	struct wry_index* ip_list;$/;"	m	struct:wry_dict	typeref:struct:wry_dict::wry_index	access:public
wry_dict::ip_list_size	wry.h	/^	int32_t ip_list_size;$/;"	m	struct:wry_dict	access:public
wry_dict::location_mem	wry.h	/^	uint8_t* location_mem;$/;"	m	struct:wry_dict	access:public
wry_dict::location_mem_len	wry.h	/^	int32_t location_mem_len;$/;"	m	struct:wry_dict	access:public
wry_dict_init	wry.c	/^int wry_dict_init(struct wry_dict* dict, const char* dictionary_file)$/;"	f	signature:(struct wry_dict* dict, const char* dictionary_file)
wry_dict_init	wry.h	/^int wry_dict_init(struct wry_dict* dict, const char* dictionary_file);$/;"	p	signature:(struct wry_dict* dict, const char* dictionary_file)
wry_dict_uninit	wry.c	/^void wry_dict_uninit(struct wry_dict* dict)$/;"	f	signature:(struct wry_dict* dict)
wry_dict_uninit	wry.h	/^void wry_dict_uninit(struct wry_dict* dict);$/;"	p	signature:(struct wry_dict* dict)
wry_find	wry.c	/^struct wry_loc * wry_find(struct wry_dict* dict, uint32_t ip)$/;"	f	signature:(struct wry_dict* dict, uint32_t ip)
wry_find	wry.h	/^struct wry_loc * wry_find(struct wry_dict* dict, uint32_t ip);$/;"	p	signature:(struct wry_dict* dict, uint32_t ip)
wry_head	wry.h	/^struct wry_head$/;"	s
wry_head::first_index_offset	wry.h	/^	int32_t first_index_offset;$/;"	m	struct:wry_head	access:public
wry_head::last_index_offset	wry.h	/^	int32_t last_index_offset;$/;"	m	struct:wry_head	access:public
wry_index	wry.h	/^struct wry_index$/;"	s
wry_index::ip_end	wry.h	/^	uint32_t ip_end;$/;"	m	struct:wry_index	access:public
wry_index::ip_start	wry.h	/^	uint32_t ip_start;$/;"	m	struct:wry_index	access:public
wry_index::location	wry.h	/^	struct wry_loc location;$/;"	m	struct:wry_index	typeref:struct:wry_index::wry_loc	access:public
wry_index::offset	wry.h	/^	int32_t offset;$/;"	m	struct:wry_index	access:public
wry_loc	wry.h	/^struct wry_loc$/;"	s
wry_loc::city	wry.h	/^	uint8_t* city;$/;"	m	struct:wry_loc	access:public
wry_loc::city_len	wry.h	/^	uint8_t city_len;$/;"	m	struct:wry_loc	access:public
wry_loc::nation	wry.h	/^	uint8_t* nation;$/;"	m	struct:wry_loc	access:public
wry_loc::nation_len	wry.h	/^	uint8_t nation_len;$/;"	m	struct:wry_loc	access:public
~CDayLog	RollLog.cpp	/^CDayLog::~CDayLog()$/;"	f	class:CDayLog	signature:()
~CDayLog	RollLog.h	/^	~CDayLog();$/;"	p	class:CDayLog	access:public	signature:()
~CFileLock	file_lock.cpp	/^CFileLock::~CFileLock(void)$/;"	f	class:CFileLock	signature:(void)
~CFileLock	file_lock.h	/^    ~CFileLock(void);$/;"	p	class:CFileLock	access:public	signature:(void)
~CMongodb	mongoc_json.cpp	/^CMongodb::~CMongodb()$/;"	f	class:CMongodb	signature:()
~CMongodb	mongoc_json.h	/^		~CMongodb();$/;"	p	class:CMongodb	access:public	signature:()
~CRollLog	RollLog.cpp	/^CRollLog::~CRollLog()$/;"	f	class:CRollLog	signature:()
~CRollLog	RollLog.h	/^	~CRollLog();$/;"	p	class:CRollLog	access:public	signature:()
~Conf	conf.cpp	/^Conf::~Conf(void)$/;"	f	class:Conf	signature:(void)
~Conf	conf.h	/^	~Conf(void);$/;"	p	class:Conf	access:public	signature:(void)
~MultiObjectPool	multi_object_pool.h	/^		virtual ~MultiObjectPool( );$/;"	p	class:MultiObjectPool	access:public	signature:( )
~MultiObjectPool	multi_object_pool.h	/^MultiObjectPool<TObject, ConstructorType, TObjectPool>::~MultiObjectPool( )$/;"	f	class:MultiObjectPool	signature:( )
~ObjectPool	object_pool.h	/^		virtual ~ObjectPool( );$/;"	p	class:ObjectPool	access:public	signature:( )
~ObjectPool	object_pool.h	/^ObjectPool<TObject, ConstructorType>::~ObjectPool( )$/;"	f	class:ObjectPool	signature:( )
~nw_timer	timer.h	/^	~nw_timer() { }$/;"	f	class:nw_timer	access:public	signature:()
~ut_mysql	ut_mysql.cpp	/^ut_mysql::~ut_mysql(void)$/;"	f	class:ut_mysql	signature:(void)
~ut_mysql	ut_mysql.h	/^	virtual ~ut_mysql(void);$/;"	p	class:ut_mysql	access:public	signature:(void)
